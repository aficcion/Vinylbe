La plataforma, en cristiano, deber√≠a funcionar as√≠ üëá

---

## 1. Visi√≥n y objetivo

**Vinilogy** es una plataforma (B2C al principio) que recomienda vinilos a una persona a partir de:

* Sus artistas / discos favoritos (introducidos manualmente).
* Sus datos de escucha (Last.fm ahora, Spotify u otros en el futuro).
* La informaci√≥n de cat√°logo (MusicBrainz, Discogs).
* Los precios disponibles en tiendas online (eBay, Amazon, tiendas indie‚Ä¶).

La gracia: **no es para descubrir m√∫sica nueva**, sino para decirte *‚Äúde lo que ya te flipa, cu√°l es el vinilo que tiene m√°s sentido comprar, y a qu√© precio‚Äù*.

---

## 2. Enfoque de arquitectura: monolito modular

Un **√∫nico deployable** (por ejemplo, FastAPI + worker + Postgres) pero dividido internamente en m√≥dulos bien separados:

* Cada m√≥dulo tiene:

  * Su *capa de dominio* (entidades, l√≥gica).
  * Su *capa de aplicaci√≥n* (casos de uso).
  * Sus *adaptadores* (API HTTP, integraciones externas, acceso a datos).
* No hay microservicios ‚Üí todo vive en el mismo repo, mismo proceso, misma base de datos, pero **sin mezclar responsabilidades**.

Estructura orientativa:

```text
/app
  /core              # shared kernel: config, base models, utils, auth base
  /modules
    /identity        # usuarios, login, auth
    /profiles        # perfil musical del usuario (gustos, seeds, conexiones externas)
    /catalog         # artistas, √°lbums, masters, ediciones de vinilo
    /integrations    # lastfm, musicbrainz, discogs, price providers
    /recommender     # l√≥gica de recomendaci√≥n y scoring
    /prices          # precios, ofertas y disponibilidad
    /collections     # wantlist, locks, dismissals
    /ops             # health checks, logs, m√©tricas, tareas admin
```

---

## 3. Roles y casos de uso

### 3.1. Usuario final (music fan)

Puede:

1. **Registrarse y hacer login** (email + password; OAuth en el futuro).
2. **Conectar cuentas externas** (Last.fm ahora; Spotify/Discogs despu√©s).
3. **Definir sus gustos**:

   * Buscar artistas mientras escribe (autocompletado).
   * Ver sugerencias de artistas similares.
   * A√±adir y quitar artistas ‚Äúsemilla‚Äù.
4. **Ver recomendaciones de vinilos**:

   * Lista de 10‚Äì20 vinilos recomendados.
   * Cada vinilo con: portada, artista, t√≠tulo, motivo de recomendaci√≥n (ej. ‚Äúlo escuchas much√≠simo en los √∫ltimos 6 meses‚Äù), rating, disponibilidad en vinilo y precios.
5. **Gestionar sus recomendaciones**:

   * **Lock / ‚Äúme interesa‚Äù** ‚Üí no se sobreescribe en futuras recomputaciones.
   * **Dismiss / ‚Äúno me interesa‚Äù** ‚Üí no vuelve a salir.
   * **Refrescar recomendaciones** bajo demanda.
6. **Guardar vinilos** en una wantlist personal.

### 3.2. Admin / owner (t√∫)

Puede:

* Ver estado de integraciones y cuotas.
* Ver logs de errores de APIs externas.
* Activar / desactivar providers de precio.
* Ejecutar recomputaciones manuales para pruebas.
* Configurar reglas (m√°ximo de recomendaciones, TTL de rec√°lculo, etc.).

---

## 4. M√≥dulos del monolito y responsabilidades

### 4.1. M√≥dulo `identity` (usuarios y autenticaci√≥n)

**Responsabilidad**: todo lo relacionado con usuarios y sesiones.

* Entidades:

  * `User(id, email, password_hash, created_at, locale, country, ‚Ä¶)`
  * `Session / RefreshToken` (si hace falta).
* Casos de uso:

  * `register_user`
  * `login_user`
  * `logout`
* Endpoints:

  * `POST /auth/register`
  * `POST /auth/login`
  * `POST /auth/logout`
* No sabe nada de m√∫sica, ni de integraciones externas.

---

### 4.2. M√≥dulo `profiles` (perfil musical del usuario)

**Responsabilidad**: entender el **gusto musical** del usuario.

* Entidades:

  * `UserProfile(user_id, lastfm_username, primary_source, last_updated, ‚Ä¶)`
  * `UserSeedArtist(user_id, artist_id, source, added_at)`
  * `ExternalAccount(user_id, provider, external_id, access_token, refresh_token, ‚Ä¶)`
  * `ListeningSnapshot(user_id, source, period, payload_hash, created_at)`
* Casos de uso:

  * Conectar Last.fm / Spotify.
  * Sincronizar datos de escucha (top artists/albums, etc.).
  * Agregar artistas a mano.
* Endpoints:

  * `POST /profiles/connect/lastfm`
  * `GET /profiles/seed-artists`
  * `POST /profiles/seed-artists`
  * `DELETE /profiles/seed-artists/{id}`

---

### 4.3. M√≥dulo `catalog` (artistas, √°lbumes y vinilos)

**Responsabilidad**: representar el **cat√°logo musical ‚Äúlimpio‚Äù**.

* Entidades:

  * `Artist(id, mbid?, name, normalized_name, image_url, ‚Ä¶)`
  * `Album(id, mbid?, artist_id, title, is_studio_album, popularity_score, ‚Ä¶)`
  * `VinylEdition(id, album_id, discogs_master_id?, discogs_release_id?, format, country, year, rating, is_official, ‚Ä¶)`
* Casos de uso:

  * Resolver un artista por nombre o MBID.
  * Cargar y filtrar √°lbumes de estudio desde MusicBrainz.
  * Asociar √°lbumes a masters / releases de Discogs.
* Endpoints (internos, normalmente):

  * `GET /catalog/artist/{id}`
  * `GET /catalog/artist/{id}/albums?studio_only=true`
  * `GET /catalog/album/{id}/vinyl-editions`

El cat√°logo es **compartido entre usuarios** y se cachea en base de datos para evitar llamar siempre a las APIs externas.

---

### 4.4. M√≥dulo `integrations` (APIs externas)

**Responsabilidad**: encapsular la l√≥gica de llamada a servicios externos.

Subm√≥dulos:

1. `lastfm_client`

   * M√©todos:

     * `get_artist_info(name or mbid)` ‚Üí info + similares.
     * `get_user_top_albums(username, period)` ‚Üí top √°lbumes del usuario.
   * Maneja:

     * API key y secret.
     * Retries, rate limiting, timeouts.
     * Normalizaci√≥n de errores.

2. `musicbrainz_client`

   * M√©todos:

     * `search_artist(name)`
     * `get_artist_albums(mbid, type="Album")`
   * Filtro de √°lbums de estudio.

3. `discogs_client`

   * M√©todos:

     * `search_master(artist, title)`
     * `get_master_details(master_id)` (incluye `main_release` y rating).
     * `get_release_details(release_id)`
     * `search_releases(artist, title, format="Vinyl")`
   * L√≥gica para no disparar 100 llamadas por master con 1.000 releases ‚Üí l√≠mite configurable (p.ej. primeras 10‚Äì20 releases, priorizando oficiales/europeas).

4. `price_providers`

   * Interfaz gen√©rica:

     * `search_prices(artist, album, country)` ‚Üí lista de `PriceQuote`.
   * Implementaciones:

     * `EbayProvider`
     * `AmazonProvider`
     * `IndieStoreProvider` (scraping o APIs privadas).
   * Maneja:

     * Ubicaci√≥n del usuario.
     * Filtros de env√≠o a pa√≠s.

Este m√≥dulo **no sabe de usuarios ni recomendaciones**, solo de c√≥mo hablar con otros servicios.

---

### 4.5. M√≥dulo `prices` (precios y disponibilidad)

**Responsabilidad**: almacenar y servir los **precios** para las ediciones de vinilo.

* Entidades:

  * `PriceQuote(id, vinyl_edition_id, provider, currency, amount, url, shipping_cost, country, valid_from, valid_to)`
* Casos de uso:

  * Actualizar precios para una `VinylEdition` o un conjunto (batch).
  * Seleccionar el **mejor precio** por pa√≠s / regi√≥n.
* Endpoints:

  * `GET /prices/vinyl/{vinyl_id}?country=ES` ‚Üí mejor oferta + alternativas.

---

### 4.6. M√≥dulo `collections` (wantlist, locks y dismissals)

**Responsabilidad**: preferencias por vinilo espec√≠fico.

* Entidades:

  * `WishlistItem(user_id, vinyl_edition_id, added_at, source)`
  * `LockedRecommendation(user_id, vinyl_edition_id, locked_at)`
  * `DismissedRecommendation(user_id, vinyl_edition_id, dismissed_at, reason?)`
* Casos de uso:

  * A√±adir a wantlist.
  * Marcar como ‚Äúlock‚Äù.
  * Marcar como ‚Äúdismissed‚Äù.
* Endpoints:

  * `GET /collections/wishlist`
  * `POST /collections/wishlist`
  * `POST /collections/lock`
  * `POST /collections/dismiss`

---

### 4.7. M√≥dulo `recommender` (motor de recomendaciones)

**Responsabilidad**: generar y servir la lista de vinilos recomendados.

* Entidades:

  * `RecommendationSet(id, user_id, generated_at, source_snapshot_hash, ttl_seconds)`
  * `RecommendationItem(recommendation_set_id, position, vinyl_edition_id, score, explanation, is_locked, is_dismissed)`

* L√≥gica principal:

  1. **Entrada**:

     * Seeds del usuario (`UserSeedArtist`).
     * Datos de escucha (`ListeningSnapshot`).
  2. **Construcci√≥n del ‚Äúcandidate pool‚Äù**:

     * Artistas m√°s escuchados + artistas semilla.
     * Para cada artista, recuperar √°lbumes de estudio (`catalog`).
  3. **Filtrado y enriquecimiento**:

     * Excluir: singles, compilaciones, directos (seg√∫n flags de `Album`).
     * Solo √°lbumes con **al menos una edici√≥n en vinilo** (v√≠a `catalog` + `discogs`).
  4. **Scoring** (simplificado, pero configurable):

     * Puntos por frecuencia de escucha (Last.fm).
     * Ponderaci√≥n suave por periodo (m√°s reciente pesa un poco m√°s).
     * Extra por n√∫mero de temas del √°lbum que escucha.
     * Penalizaci√≥n si ya est√° en wantlist.
  5. **Selecci√≥n**:

     * Ordenar por score.
     * Quitar los que est√°n en `DismissedRecommendation`.
     * Respetar los `LockedRecommendation` (se mantienen en la lista).
     * Limitar a N (ej. 20) resultados.
  6. **Persistencia**:

     * Guardar un `RecommendationSet` por usuario.
     * Reutilizar el √∫ltimo set si:

       * No ha cambiado el snapshot de escucha/semillas.
       * No ha expirado el TTL.
     * Si hay cambios ‚Üí generar un nuevo set.

* Endpoints:

  * `GET /recs` ‚Üí devuelve el √∫ltimo set (y, si est√° caducado, dispara rec√°lculo en background).
  * `POST /recs/refresh` ‚Üí fuerza rec√°lculo (para testing).

---

### 4.8. M√≥dulo `ops` (operaciones y observabilidad)

**Responsabilidad**: salud del sistema, jobs, trazabilidad.

* Entidades:

  * `JobRun(id, job_name, status, started_at, finished_at, error_message)`
* Casos de uso:

  * Cron jobs para refrescar cat√°logos, precios y recomendaciones.
  * Health checks de integraciones.
* Endpoints:

  * `GET /ops/health`
  * `GET /ops/jobs`

---

## 5. Flujos clave

### 5.1. Registro y primer acceso

1. Usuario se registra (`identity`).
2. Se crea un `UserProfile` vac√≠o (`profiles`).
3. Se muestra una pantalla de **onboarding**:

   * Opci√≥n A: conectar Last.fm.
   * Opci√≥n B: a√±adir artistas a mano.
4. Al terminar el onboarding, se dispara un proceso inicial:

   * Sincronizar datos de escucha (si hay Last.fm).
   * Obtener artistas seeds.
   * Construir primeras recomendaciones (`recommender`).

---

### 5.2. B√∫squeda y selecci√≥n de artistas (UI tipo ‚Äútypeahead‚Äù)

1. En el frontend, el usuario empieza a escribir ‚ÄúArctic Monkeys‚Äù.
2. Front llama a `GET /search/artists?q=arcti`.
3. Backend:

   * Usa el cach√© local (tabla `Artist`) para sugerencias r√°pidas.
   * Si no hay suficiente, llama a `lastfm_client.get_artist_info` o `search_artist`.
   * Normaliza y guarda nuevos artistas en `catalog`.
4. La respuesta incluye:

   * Artistas coincidentes directos.
   * Artistas similares (si se solicita).
5. Al seleccionar un artista, se crea `UserSeedArtist`.

---

### 5.3. Generaci√≥n de recomendaciones al entrar en ‚ÄúRecs‚Äù

1. Front llama a `GET /recs`.
2. Backend (`recommender`) hace:

   * Busca el √∫ltimo `RecommendationSet` del usuario.
   * Comprueba:

     * ¬øHan cambiado seeds o listening snapshots desde entonces?
     * ¬øEst√° expirado el TTL (ej. 24h)?
   * Si **NO** ‚Üí devuelve el set existente ‚Üí respuesta r√°pida.
   * Si **S√ç**:

     * Lanza recomputaci√≥n:

       * Puede ser **sincr√≥nica** (si quieres simplicidad) o:
       * **As√≠ncrona** con worker y devolver el set antiguo mientras se recalcula.
3. Resultado:

   * Lista de `RecommendationItem` con:

     * Datos del vinilo (v√≠a `catalog` + `prices`).
     * Bandera `is_locked`, `is_dismissed` (para front).
     * Explicaci√≥n simple (‚Äútop album para ti en los √∫ltimos 12 meses‚Äù, etc.).

---

### 5.4. Lock y dismiss

* **Lock**:

  * `POST /collections/lock` con `vinyl_edition_id`.
  * `recommender` siempre asegura que ese √≠tem:

    * Aparece en el top de la lista mientras haya hueco.
    * No se borra en nuevas versiones de `RecommendationSet`.

* **Dismiss**:

  * `POST /collections/dismiss` con `vinyl_edition_id`.
  * `recommender` excluye permanentemente ese vinilo para el usuario (salvo que se limpie manualmente).

---

### 5.5. Wantlist

* `POST /collections/wishlist` a√±ade un vinilo.
* Aparece en:

  * Vista de wantlist.
  * Posibles integraciones futuras (exportar a Discogs, etc.).

---

## 6. Corner cases a tener en cuenta

1. **Usuario sin datos externos ni artistas**:

   * Mostrar una pantalla neutra: ‚ÄúA√±ade al menos 3 artistas para empezar‚Äù.
   * No llamar a APIs externas hasta que haya input.

2. **Artista sin √°lbumes de estudio en MB**:

   * Fallback:

     * Buscar por nombre en vez de MBID.
     * Permitir algunos releases marcados como ‚ÄúAlbum‚Äù pero sin primary type.
   * Si a√∫n as√≠ no hay ‚Üí explicar ‚ÄúNo encontramos √°lbumes de estudio‚Äù y sugerir otros.

3. **√Ålbum sin edici√≥n en vinilo**:

   * Se excluye del candidate pool.
   * Opcional: guardar un flag para evitar reconsultarlo durante un tiempo.

4. **Masters con cientos de releases en Discogs**:

   * Limitar el n¬∫ de releases consultados (ej. 15‚Äì20).
   * Priorizar:

     * Oficiales.
     * Regi√≥n del usuario (ES/UE).
     * A√±o original o reissue relevante.
   * Evitar loops y saturar la API.

5. **Errores de API / rate limits**:

   * Devolver recomendaciones basadas en datos ya cacheados.
   * Loggear el error con detalle (m√≥dulo `ops`).
   * Mostrar mensaje suave al usuario si no se pueden actualizar precios.

6. **Precios no disponibles**:

   * Mostrar el vinilo igualmente pero sin precio (‚Äúprecio no disponible ahora mismo‚Äù).
   * No bloquear la recomendaci√≥n por no tener precio.

---

## 7. Requisitos no funcionales (alto nivel)

* **Persistencia**:

  * Postgres (u otra relacional).
  * Migraciones versionadas.
* **Observabilidad**:

  * Logs estructurados por m√≥dulo.
  * M√©tricas b√°sicas: tiempo medio de rec√°lculo, errores de integraciones, etc.
* **Configuraci√≥n**:

  * Variables de entorno para API keys y secrets.
  * Config por entorno (dev, staging, prod).
* **Multi-idioma**:

  * Backend neutro, frontend con i18n (ES/EN).
* **Seguridad**:

  * JWT o cookies seguras.
  * Rate limiting por IP/usuario para endpoints sensibles.
* **Escalabilidad**:

  * Escalado vertical/ horizontal del monolito.
  * Workers separados para tareas pesadas (recs masivos, scrapers de precios).

---

## 8. Resumen r√°pido

* **Monolito modular** ‚Üí un solo servicio, muchos m√≥dulos con responsabilidades claras.
* M√≥dulos clave: `identity`, `profiles`, `catalog`, `integrations`, `prices`, `collections`, `recommender`, `ops`.
* Recomendaciones:

  * Se basan en datos de escucha + artistas semilla.
  * Solo consideran √°lbumes de estudio con edici√≥n en vinilo.
  * Se recalculan cuando cambia la entrada o expira el TTL.
  * Respetan locks, dismiss y wantlist.
* Integraciones externas est√°n completamente encapsuladas en un m√≥dulo espec√≠fico para no contaminar el dominio.

Si quieres, en el siguiente paso puedo bajar un poco m√°s al detalle en **modelos de datos** (tablas principales) y en un **diagrama de flujo** concreto para el endpoint `/recs`.
