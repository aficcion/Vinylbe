You are a senior Python backend engineer helping me design and implement the data layer and ingestion jobs for my project **Vinilogy**.

Context:
- Tech stack: Python, PostgreSQL, httpx/requests for external APIs. I’m using Replit.
- Architecture: “modular monolith” – one codebase, several logical modules (/modules/artists, /modules/albums, /modules/releases, /modules/prices, /modules/integrations, etc.).
- Main goal: build and populate a database with ~10k artists and their data, so later I can use this for vinyl recommendations.

I need you to create a concrete, step-by-step implementation plan AND the initial code skeleton to support this.

### Business requirements (very important)

For each **artist** I want to store:

- Internal id
- `mbid` (MusicBrainz artist id)
- `discogs_id` (Discogs artist id)
- `spotify_id` (Spotify artist id)
- `name`, `normalized_name`
- `image_url`
- Source (where this artist came from: seed CSV, Last.fm tags, similar artists, etc.)

For each **artist**, I also need **at least 20 related artists** stored, with a similarity score.

For each **artist** I also want:

- All **studio albums** (from MusicBrainz).
- For each studio album:
  - Its **vinyl releases** on Discogs.
  - Among all vinyl releases, the **cheapest option** (based on external price providers like eBay/Amazon/etc.).

For each **album** I want to store:

- Internal id
- `mbid` (MusicBrainz release-group id)
- `discogs_id` (Discogs master id)
- `spotify_id` (Spotify album id)
- `artist_id` (internal FK)
- `title`, `normalized_title`
- `first_release_year`
- `is_studio` (boolean, true by default)
- Source (e.g. “musicbrainz”)

For each **release** (a specific vinyl edition) I want:

- Internal id
- `mbid` (MusicBrainz release id, if available)
- `discogs_id` (Discogs release id – this is the primary one here)
- `spotify_id` (only if I decide to map at this level later)
- `album_id` (FK)
- `title`
- `country`
- `year`
- `format` (e.g. “Vinyl”, “2xVinyl”)
- `is_vinyl` (boolean)
- `is_official` (boolean)
- `label`
- `discogs_rating` (average rating of that release, if available)

For **prices** I want:

- Internal id
- `release_id` (FK)
- `provider` (e.g. “ebay”, “amazon”, “indie_store”)
- `country`
- `currency`
- `amount`
- `shipping_amount`
- `total_amount` (amount + shipping, stored or computed)
- `url`
- `fetched_at`

I also want a table/materialization `album_best_price`:

- One row per `(album_id, country)`
- Fields: `album_id`, `release_id`, `provider`, `country`, `currency`, `total_amount`, `url`, `computed_at`
- It should always represent the cheapest total price for that album in that country (based on all vinyl releases and all providers).

For **artist relations** I want a table like `artist_similars`:

- `artist_id`, `similar_artist_id`, `score`, `source`
- At least 20 similar artists per artist, using Last.fm `artist.getInfo` and/or similar endpoints.

### External APIs and data sources

I will be using:

- **Last.fm**:
  - For artist info + similar artists.
  - For seeding artists by tag and later for listening data.
- **MusicBrainz**:
  - For studio albums:
    - Use release-groups for primary type “Album” (not live, not compilations).
- **Discogs**:
  - For vinyl releases:
    - Search by artist + album title.
    - Filter by vinyl format and official releases.
    - Possibly use master → main release logic.
- **Price providers** (eBay, Amazon, etc.):
  - For now, it’s OK to stub these or just design the interface and leave implementations as TODOs.

### Important issue to investigate (artist images from Last.fm)

Right now I have a problem: **I’m not able to use the artist images from Last.fm in my app**. The URLs come in the Last.fm response, but when I try to display them in the UI, they fail or don’t load correctly.

I need you to:

- Explicitly plan a debugging step for this.
- In the code, log a sample Last.fm `artist.getInfo` response (especially the `image` array).
- Choose a robust way to pick a valid `image_url` (e.g. “mega” or “extralarge” size).
- Make sure the chosen URL is HTTPS and actually works in a browser.
- Consider potential causes:
  - Wrong field from the API,
  - HTTP vs HTTPS,
  - URL encoding,
  - CORS or mixed-content issues.
- Propose a small test script that:
  - Calls Last.fm for a known artist (e.g. “Arctic Monkeys”),
  - Stores the chosen `image_url` in the DB,
  - And prints the URL so I can test it manually in the browser.

### What I want you to produce

1. A **high-level implementation plan** (step-by-step) covering:
   - Database schema design (tables + indexes).
   - Folder/module structure for a modular monolith in Python.
   - Migration strategy (I’m OK with raw SQL or Alembic – pick one and be consistent).
   - Data ingestion pipeline:
     - Seed artists via Last.fm (tags or initial list).
     - Enrich artists with MBID, Discogs id, Spotify id.
     - Fetch studio albums from MusicBrainz.
     - Map albums to Discogs vinyl releases.
     - Prepare interfaces for price providers and compute `album_best_price`.
   - Strategy for rate limiting and retries for the three APIs (Last.fm, MusicBrainz, Discogs).

2. The **initial PostgreSQL schema** (SQL or Alembic migrations) for:
   - `artists`
   - `artist_similars`
   - `albums`
   - `releases`
   - `prices`
   - `album_best_price`

3. A **Python package structure** like:
   - `app/core` (config, db session, base models)
   - `app/modules/artists`
   - `app/modules/albums`
   - `app/modules/releases`
   - `app/modules/prices`
   - `app/modules/integrations` (with submodules `lastfm`, `musicbrainz`, `discogs`)
   Each module should have:
   - Models (SQLAlchemy or similar),
   - Simple repository/query functions,
   - Simple CLI/utility scripts for ingestion (e.g. `python -m app.modules.artists.seed_lastfm`).

4. Example ingestion scripts:
   - Script 1: Seed artists from Last.fm tags into `artists`, including `mbid` when available.
   - Script 2: For artists with `mbid`, fetch studio albums from MusicBrainz into `albums`.
   - Script 3: For each album, search Discogs for vinyl releases and store them into `releases`.
   - Script 4: For a subset of releases, call a dummy price provider and populate `prices`, then compute/update `album_best_price`.

5. A small **debug script for the Last.fm image issue**:
   - Call `artist.getInfo` for a known artist.
   - Log the raw JSON (or at least the `image` array).
   - Show how you select the `image_url`.
   - Update the `artists.image_url` field.
   - Print the final URL so I can test it in the browser.

Assumptions and constraints:
- Use PostgreSQL.
- Use Python 3.11+.
- Use `httpx` for HTTP calls.
- Keep everything as simple and explicit as possible – I’m not a strong programmer, so clarity is more important than cleverness.
- I will store API keys in environment variables (e.g. `LASTFM_API_KEY`, etc.). Please assume they exist and show how to read them.

Please start by summarizing your understanding, then propose the plan, then generate the actual code structure and example files/migrations.
