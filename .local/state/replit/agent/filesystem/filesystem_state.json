{"file_contents":{"replit.md":{"content":"# Vinyl Recommendation System (Vinilogy)\n\n## Overview\nThis project is a comprehensive vinyl recommendation system that leverages **Spotify and Last.fm listening data** combined with **manual artist selection** and Discogs marketplace information to provide personalized vinyl recommendations. Its main purpose is to help music enthusiasts discover vinyl records based on their digital listening habits, including pricing and local store availability. The business vision is to evolve into a robust, data-rich platform for collectors.\n\n**Key Features:**\n- **3 Recommendation Sources**: Spotify, Last.fm, and manual artist-based recommendations\n- **Intelligent Merging**: Deduplication across all sources for unique recommendations\n- **Dual Scoring Algorithms**: Position-based (Spotify) and playcount-based (Last.fm)\n\n## User Preferences\nI want to prioritize a clear, concise, and professional communication style. For development, I prefer an iterative approach, focusing on delivering core functionality first and then enhancing it. I value detailed explanations, especially for complex architectural decisions. Please ask for my approval before making any major changes to the system architecture or core functionalities.\n\n## System Architecture\n\n### UI/UX Decisions\nThe user interface features a clean, minimalist landing page with dark/light theme support, a \"Conectar con Spotify\" button, and an OAuth flow. Recommendations are displayed in a responsive grid. Album detail pages are 1400px wide, two-column layouts showing cover art, basic info, Spotify playback, Discogs tracklist, eBay pricing, Discogs marketplace links, and local store links. On-demand pricing and tracklist loading optimize user experience. A fixed progress banner provides non-blocking feedback during recommendation generation. An Admin Interface is available for monitoring, debugging, and real-time request logs, including a real-time CSV import progress panel.\n\n### Technical Implementations\nThe system uses a microservices architecture built with FastAPI and Python 3.11, employing asynchronous communication with `httpx` and `asyncio.gather`. Shared models ensure data consistency, and structured logging is implemented.\n\n-   **Spotify Integration**: Handles OAuth, retrieves user's top tracks and artists (short/medium/long term), refreshes tokens, and provides album streaming links. Uses position-based scoring algorithm.\n-   **Last.fm Integration**: Handles authentication flow (token ‚Üí user authorization ‚Üí session key), retrieves user's **top albums directly** via `user.gettopalbums` (simplified approach), with period mapping (7day/3month/12month). Uses cache-first strategy: checks PostgreSQL for existing album data, creates basic DB entries for new albums, and fetches covers from Discogs on-demand only when needed. This approach minimizes API calls and avoids rate limiting.\n-   **Discogs Integration**: Normalizes album titles, implements master/release fallback, retrieves tracklists with durations, provides marketplace statistics (prices in EUR), generates sales links, and includes robust rate limiting. It also fetches artist images.\n-   **Recommendation Engine**: Dual scoring algorithms (position-based for Spotify, playcount-based for Last.fm), aggregates albums, filters by track count, and boosts scores for favorite artists. It supports background recommendation generation per artist, caching, and intelligent fallbacks, merging Spotify, Last.fm, and artist-based recommendations with advanced deduplication.\n-   **Pricing Service**: Finds best prices on eBay (filtered by EU location, converted to EUR, with shipping to Spain) and provides links to specific local vinyl stores.\n-   **API Gateway**: Acts as a single entry point, orchestrates workflows, proxies Spotify authentication, and performs microservice health checks.\n-   **Optimized Detail Page Flow**: Achieves complete information load (Discogs links, eBay pricing, local stores, tracklists) in 1-2 seconds through parallel fetching.\n-   **Last.fm Artist Explorer**: Uses a Discogs-first search for artist images and simplified similar artist retrieval via `artist.getInfo`.\n-   **PostgreSQL Caching**: Implements a structured database (artists, albums, similar_artists) with a 7-day expiration for cached data, dramatically improving response times for existing artists. It supports bulk artist import from CSV with persistence of ratings and images.\n\n### System Design Choices\nThe architecture comprises **six independent microservices**: `Spotify Service` (port 3000), `Discogs Service` (port 3001), `Recommender Service` (port 3002), `Pricing Service` (port 3003), `Last.fm Service` (port 3004), and `API Gateway` (port 5000). This design promotes scalability, maintainability, and clear separation of concerns.\n\n**Time Range Mapping:**\n- Spotify: `short_term` (4 weeks), `medium_term` (6 months), `long_term` (1 year)\n- Last.fm: `short_term` ‚Üí `7day`, `medium_term` ‚Üí `3month`, `long_term` ‚Üí `12month`\n\n**Scoring Mechanisms:**\n- **Spotify**: Position-based with time range boosts (short_term: 3.0x, medium_term: 2.0x, long_term: 1.0x)\n- **Last.fm**: Simplified playcount-based system using `user.gettopalbums` directly. Cache-first: checks DB for album data first, only calls Discogs for cover art when creating new album entries.\n\n**Last.fm Optimization (Nov 2025):**\n- Uses `user.gettopalbums` endpoint directly instead of `top-artists` ‚Üí `get albums per artist`\n- Cache-first strategy: queries PostgreSQL before external APIs\n- Creates basic artist/album DB entries for new discoveries\n- Fetches covers from Discogs on-demand (only for cache misses)\n- Allows future background jobs to enrich basic entries with full metadata\n\n## External Dependencies\n\n-   **Spotify API**: User authentication (OAuth 2.0), top tracks, top artists with time ranges.\n-   **Last.fm API**: User authentication (token-based flow), **top albums** (`user.gettopalbums`) with period filters, playcount data.\n-   **Discogs API**: Vinyl release search, marketplace statistics, sales link generation, artist images.\n-   **MusicBrainz API**: Artist discographies, studio albums, metadata.\n-   **eBay Browse API**: Vinyl record pricing, filtering, currency conversion.\n-   **Local Store Integrations**: Direct website links for specific Madrid vinyl shops (Marilians, Bajo el Volc√°n, Bora Bora, Revolver).\n-   **FastAPI**: Python web framework.\n-   **httpx**: Asynchronous HTTP client.\n-   **PostgreSQL**: Database for caching and persistence.","size_bytes":6506},"libs/shared/models.py":{"content":"from pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom datetime import datetime\n\n\nclass Track(BaseModel):\n    id: str\n    name: str\n    artists: List[str]\n    album_id: str\n    album_name: str\n    album_artists: List[str]\n    popularity: int = 0\n    preview_url: Optional[str] = None\n\n\nclass Artist(BaseModel):\n    id: str\n    name: str\n    genres: List[str] = []\n    popularity: int = 0\n    followers: int = 0\n\n\nclass Album(BaseModel):\n    id: str\n    name: str\n    artists: List[str]\n    release_date: Optional[str] = None\n    total_tracks: int = 0\n    upc: Optional[str] = None\n    image_url: Optional[str] = None\n\n\nclass DiscogsRelease(BaseModel):\n    release_id: int\n    title: str\n    artist: str\n    year: Optional[int] = None\n    format: str = \"Vinyl\"\n    country: Optional[str] = None\n    label: Optional[str] = None\n    catno: Optional[str] = None\n    thumb: Optional[str] = None\n\n\nclass DiscogsStats(BaseModel):\n    release_id: int\n    lowest_price: Optional[float] = None\n    currency: str = \"EUR\"\n    num_for_sale: int = 0\n    sell_list_url: str\n\n\nclass ScoredTrack(BaseModel):\n    track: Track\n    position: int\n    time_range: str\n    score: float\n\n\nclass ScoredArtist(BaseModel):\n    artist: Artist\n    position: int\n    score: float\n\n\nclass AlbumRecommendation(BaseModel):\n    album: Album\n    score: float\n    track_count: int\n    artist_boost: bool = False\n    discogs_release: Optional[DiscogsRelease] = None\n    discogs_stats: Optional[DiscogsStats] = None\n\n\nclass ServiceHealth(BaseModel):\n    service_name: str\n    status: str\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    response_time_ms: Optional[float] = None\n    error: Optional[str] = None\n\n\nclass LogEvent(BaseModel):\n    service: str\n    level: str\n    message: str\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n    data: Optional[dict] = None\n","size_bytes":1889},"tests/__init__.py":{"content":"","size_bytes":0},"tests/top_artist.py":{"content":"import csv\nimport requests\nimport os\n\nAPI_KEY = os.getenv(\"LASTFM_API_KEY\")\nif not API_KEY:\n    raise RuntimeError(\"‚ùå No se encontr√≥ LASTFM_API_KEY en los secrets.\")\n\nURL = \"https://ws.audioscrobbler.com/2.0/\"\n\nparams = {\n    \"method\": \"chart.gettopartists\",\n    \"api_key\": API_KEY,\n    \"format\": \"json\",\n    \"limit\": 1000,\n    \"page\": 1,\n}\n\nprint(\"üì° Descargando top 1000 artistas de Last.fm...\")\nresp = requests.get(URL, params=params, timeout=20)\nresp.raise_for_status()\ndata = resp.json()\n\nartists = data[\"artists\"][\"artist\"]\nprint(f\"‚úî Recibidos {len(artists)} artistas\")\n\nCSV_FILE = \"top_artists_1000.csv\"\n\ndef extract_best_image(image_list):\n    priority = [\"mega\", \"extralarge\", \"large\", \"medium\", \"small\"]\n    for size in priority:\n        for img in image_list:\n            if img.get(\"size\") == size and img.get(\"#text\"):\n                return img[\"#text\"]\n    return \"\"\n\nwith open(CSV_FILE, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n    writer = csv.writer(f)\n    writer.writerow([\"rank\", \"name\", \"mbid\", \"listeners\", \"playcount\", \"url\", \"image_url\"])\n\n    for i, a in enumerate(artists, start=1):\n        image_url = extract_best_image(a.get(\"image\", []))\n\n        writer.writerow([\n            i,\n            a.get(\"name\", \"\"),\n            a.get(\"mbid\", \"\"),\n            a.get(\"listeners\", \"\"),\n            a.get(\"playcount\", \"\"),\n            a.get(\"url\", \"\"),\n            image_url\n        ])\n\nprint(f\"üíæ Archivo CSV generado: {CSV_FILE}\")\n","size_bytes":1463},"gateway/static/app.js":{"content":"// Request Log\nconst requestLog = [];\n\nfunction addRequestLog(method, endpoint, params, status, time, summary, discogsRequest = null) {\n    const timestamp = new Date().toLocaleTimeString();\n    requestLog.push({ timestamp, method, endpoint, params, status, time, summary, discogsRequest });\n    updateRequestLogDisplay();\n}\n\nfunction updateRequestLogDisplay() {\n    const logDiv = document.getElementById('request-log');\n    if (!logDiv) return;\n    \n    const html = requestLog.map(log => {\n        const statusColor = log.status >= 200 && log.status < 300 ? 'text-green-600' : 'text-red-600';\n        \n        let discogsHtml = '';\n        if (log.discogsRequest && log.discogsRequest.request_url) {\n            const url = log.discogsRequest.request_url;\n            const params = log.discogsRequest.params_sent || {};\n            const paramsHtml = Object.entries(params)\n                .map(([k, v]) => `<div class=\"ml-4 text-purple-600\">&${k}=${v}</div>`)\n                .join('');\n            \n            discogsHtml = `\n                <div class=\"mt-1 ml-4 text-xs bg-gray-100 p-2 rounded border border-gray-300\">\n                    <div class=\"font-semibold text-blue-700\">‚Üí ${url.split('?')[0]}</div>\n                    ${paramsHtml}\n                    ${log.discogsRequest.params_sent && log.discogsRequest.params_sent.key !== undefined ? '<div class=\"ml-4 text-gray-500\">&key=[HIDDEN]</div>' : ''}\n                    ${log.discogsRequest.params_sent && log.discogsRequest.params_sent.secret !== undefined ? '<div class=\"ml-4 text-gray-500\">&secret=[HIDDEN]</div>' : ''}\n                </div>\n            `;\n        }\n        \n        return `\n            <div class=\"text-xs p-2 border-b border-gray-200 font-mono\">\n                <div>\n                    <span class=\"text-gray-500\">[${log.timestamp}]</span>\n                    <span class=\"font-semibold\">${log.method}</span>\n                    <span class=\"text-blue-600\">${log.endpoint}</span>\n                    ${log.params ? `<span class=\"text-purple-600\">${log.params}</span>` : ''}\n                    ‚Üí <span class=\"${statusColor}\">${log.status}</span>\n                    <span class=\"text-gray-600\">(${log.time}s)</span>\n                    ${log.summary ? `<span class=\"text-gray-700 ml-2\">‚Üí ${log.summary}</span>` : ''}\n                </div>\n                ${discogsHtml}\n            </div>\n        `;\n    }).reverse().join('');\n    \n    logDiv.innerHTML = html || '<div class=\"text-sm text-gray-500 p-4\">No hay peticiones registradas</div>';\n}\n\n// Service Status Check\nasync function checkServiceHealth() {\n    try {\n        const response = await fetch('/health');\n        const data = await response.json();\n        \n        updateServiceStatus('gateway', data.gateway);\n        \n        for (const [serviceName, serviceData] of Object.entries(data.services)) {\n            updateServiceStatus(serviceName, serviceData.status);\n        }\n    } catch (error) {\n        console.error('Health check failed:', error);\n        updateServiceStatus('gateway', 'error');\n    }\n}\n\nfunction updateServiceStatus(service, status) {\n    const element = document.getElementById(`status-${service}`);\n    if (!element) return;\n    \n    const isHealthy = status === 'healthy';\n    const color = isHealthy ? 'bg-green-500' : 'bg-red-500';\n    const text = isHealthy ? 'Healthy' : 'Unhealthy';\n    \n    element.innerHTML = `\n        <span class=\"inline-block w-3 h-3 rounded-full ${color}\"></span>\n        <span class=\"ml-2 text-sm\">${text}</span>\n    `;\n}\n\n// Test Spotify Login\nasync function testSpotifyLogin() {\n    const resultElement = document.getElementById('spotify-login-result');\n    resultElement.textContent = 'Loading...';\n    resultElement.className = 'ml-4 text-sm text-blue-600';\n    \n    try {\n        const response = await fetch('/auth/login');\n        const data = await response.json();\n        \n        if (data.authorize_url) {\n            resultElement.textContent = 'Opening Spotify login...';\n            resultElement.className = 'ml-4 text-sm text-green-600';\n            window.open(data.authorize_url, '_blank');\n        } else {\n            resultElement.textContent = 'Failed to get login URL';\n            resultElement.className = 'ml-4 text-sm text-red-600';\n        }\n    } catch (error) {\n        resultElement.textContent = `Error: ${error.message}`;\n        resultElement.className = 'ml-4 text-sm text-red-600';\n    }\n}\n\n// Test Recommendation\nasync function testRecommendation() {\n    const resultElement = document.getElementById('recommend-result');\n    const progressTracker = document.getElementById('progress-tracker');\n    const resultsContainer = document.getElementById('results-container');\n    const resultsDiv = document.getElementById('results');\n    \n    resultElement.textContent = 'Starting...';\n    resultElement.className = 'ml-4 text-sm text-blue-600';\n    progressTracker.classList.remove('hidden');\n    resultsContainer.classList.add('hidden');\n    resultsDiv.innerHTML = '';\n    \n    // Simulate progress (since we don't have SSE yet)\n    const steps = [\n        { id: 'step-1', delay: 1000 },\n        { id: 'step-2', delay: 2000 },\n        { id: 'step-3', delay: 1000 },\n        { id: 'step-4', delay: 1000 },\n        { id: 'step-5', delay: 2000 },\n    ];\n    \n    let currentStep = 0;\n    const progressInterval = setInterval(() => {\n        if (currentStep < steps.length) {\n            updateStepStatus(steps[currentStep].id, 'in-progress');\n            if (currentStep > 0) {\n                updateStepStatus(steps[currentStep - 1].id, 'completed');\n            }\n            currentStep++;\n        }\n    }, 2000);\n    \n    try {\n        const response = await fetch('/recommend-vinyl');\n        const data = await response.json();\n        \n        clearInterval(progressInterval);\n        steps.forEach(step => updateStepStatus(step.id, 'completed'));\n        \n        resultElement.textContent = `Success! Found ${data.total} albums in ${data.total_time_seconds}s`;\n        resultElement.className = 'ml-4 text-sm text-green-600';\n        \n        displayResults(data.albums, data.stats, data.total_time_seconds);\n    } catch (error) {\n        clearInterval(progressInterval);\n        resultElement.textContent = `Error: ${error.message}`;\n        resultElement.className = 'ml-4 text-sm text-red-600';\n        \n        steps.forEach(step => {\n            const stepElement = document.getElementById(step.id);\n            if (stepElement.querySelector('.bg-blue-500')) {\n                stepElement.querySelector('span').className = 'inline-block w-6 h-6 rounded-full bg-red-500 mr-3';\n            }\n        });\n    }\n}\n\nfunction updateStepStatus(stepId, status) {\n    const stepElement = document.getElementById(stepId);\n    if (!stepElement) return;\n    \n    const circle = stepElement.querySelector('span');\n    const colorMap = {\n        'pending': 'bg-gray-300',\n        'in-progress': 'bg-blue-500',\n        'completed': 'bg-green-500',\n        'error': 'bg-red-500'\n    };\n    \n    circle.className = `inline-block w-6 h-6 rounded-full ${colorMap[status]} mr-3`;\n}\n\n\nasync function getPricing(artist, album, buttonElement) {\n    const albumCard = buttonElement.closest('.album-card');\n    const pricingDiv = albumCard.querySelector('.pricing-info');\n    \n    buttonElement.disabled = true;\n    buttonElement.textContent = 'Loading prices...';\n    \n    try {\n        const startTime = performance.now();\n        const response = await fetch(`/album-pricing/${encodeURIComponent(artist)}/${encodeURIComponent(album)}`);\n        const data = await response.json();\n        const endTime = performance.now();\n        const elapsed = ((endTime - startTime) / 1000).toFixed(2);\n        \n        const ebayOffer = data.ebay_offer;\n        const discogsSellUrl = data.discogs_sell_url;\n        const localStores = data.local_stores || {};\n        \n        let summary = `${elapsed}s - Discogs: ${discogsSellUrl ? 'found' : 'not found'}, eBay: ${ebayOffer ? 'found' : 'not found'}`;\n        addRequestLog('GET', `/album-pricing/${artist}/${album}`, '', response.status, elapsed, summary, data.debug_info?.discogs);\n        \n        buttonElement.textContent = '‚úì Prices Loaded';\n        buttonElement.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');\n        buttonElement.classList.add('bg-green-600');\n        \n        let html = '<div class=\"space-y-3\">';\n        \n        if (discogsSellUrl) {\n            html += `\n                <div class=\"bg-blue-50 border border-blue-200 rounded p-3\">\n                    <div class=\"text-sm font-semibold text-blue-900 mb-2\">üéµ Discogs Vinyl</div>\n                    <a href=\"${discogsSellUrl}\" target=\"_blank\" class=\"block text-center bg-blue-600 hover:bg-blue-700 text-white text-sm px-3 py-2 rounded\">\n                        Ver en Discogs\n                    </a>\n                </div>\n            `;\n        }\n        \n        if (ebayOffer) {\n            const price = ebayOffer.total_price;\n            const itemPrice = ebayOffer.item_price;\n            const shipping = ebayOffer.shipping_cost;\n            const currency = ebayOffer.currency;\n            const url = ebayOffer.url;\n            \n            html += `\n                <div class=\"bg-green-50 border border-green-200 rounded p-3\">\n                    <div class=\"text-sm font-semibold text-green-900 mb-2\">üí≥ Best eBay Offer</div>\n                    <div class=\"text-xs text-gray-700 mb-2\">\n                        <div>Item: ${itemPrice} ${currency}</div>\n                        <div>Shipping: ${shipping} ${currency}</div>\n                        <div class=\"font-bold mt-1 text-lg text-green-700\">Total: ${price} ${currency}</div>\n                    </div>\n                    <a href=\"${url}\" target=\"_blank\" class=\"block text-center bg-green-600 hover:bg-green-700 text-white text-sm px-3 py-2 rounded\">\n                        Buy on eBay\n                    </a>\n                </div>\n            `;\n        } else {\n            html += `\n                <div class=\"bg-yellow-50 border border-yellow-200 rounded p-3\">\n                    <div class=\"text-sm font-semibold text-yellow-900 mb-1\">üí≥ eBay</div>\n                    <div class=\"text-xs text-yellow-800\">No suitable vinyl offer found on eBay</div>\n                </div>\n            `;\n        }\n        \n        if (Object.keys(localStores).length > 0) {\n            html += `\n                <div class=\"bg-purple-50 border border-purple-200 rounded p-3\">\n                    <div class=\"text-sm font-semibold text-purple-900 mb-2\">üè™ Tiendas Locales</div>\n                    <div class=\"grid grid-cols-2 gap-2\">\n            `;\n            \n            const storeNames = {\n                'marilians': 'Marilians',\n                'bajo_el_volcan': 'Bajo el Volc√°n',\n                'bora_bora': 'Bora Bora',\n                'revolver': 'Revolver'\n            };\n            \n            for (const [key, url] of Object.entries(localStores)) {\n                const name = storeNames[key] || key;\n                html += `\n                    <a href=\"${url}\" target=\"_blank\" class=\"text-xs bg-purple-600 hover:bg-purple-700 text-white px-2 py-1 rounded text-center\">\n                        ${name}\n                    </a>\n                `;\n            }\n            \n            html += `\n                    </div>\n                </div>\n            `;\n        }\n        \n        html += '</div>';\n        \n        pricingDiv.innerHTML = html;\n        pricingDiv.classList.remove('hidden');\n        \n    } catch (error) {\n        buttonElement.textContent = 'Error - Try Again';\n        buttonElement.disabled = false;\n        buttonElement.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');\n        buttonElement.classList.add('bg-red-600');\n        addRequestLog('GET', `/album-pricing/${artist}/${album}`, '', 500, '0', `Error: ${error.message}`);\n        \n        pricingDiv.innerHTML = `\n            <div class=\"bg-red-50 border border-red-200 rounded p-3 text-sm text-red-800\">\n                Error loading prices: ${error.message}\n            </div>\n        `;\n        pricingDiv.classList.remove('hidden');\n    }\n}\n\nfunction displayResults(albums, stats, totalTime) {\n    const resultsContainer = document.getElementById('results-container');\n    const resultsDiv = document.getElementById('results');\n    \n    resultsContainer.classList.remove('hidden');\n    \n    if (!albums || albums.length === 0) {\n        resultsDiv.innerHTML = '<p class=\"text-gray-600\">No albums found</p>';\n        return;\n    }\n    \n    resultsDiv.innerHTML = albums.map(album => {\n        const albumInfo = album.album_info || {};\n        const albumName = albumInfo.name || 'Unknown Album';\n        const artistName = albumInfo.artists?.[0]?.name || 'Unknown Artist';\n        const imageUrl = albumInfo.images?.[0]?.url || 'https://via.placeholder.com/300';\n        const score = album.score ? album.score.toFixed(0) : '0';\n        const trackCount = album.track_count || 0;\n        \n        const breakdown = album.score_breakdown || {};\n        const baseScore = breakdown.base_score || 0;\n        const artistBoostApplied = breakdown.artist_boost_applied || false;\n        const boostMultiplier = breakdown.artist_boost_multiplier || 1;\n        const scoreByPeriod = breakdown.score_by_period || {};\n        const tracksByPeriod = breakdown.tracks_by_period || {};\n        \n        return `\n            <div class=\"bg-white rounded-lg shadow-md overflow-hidden album-card\">\n                <img src=\"${imageUrl}\" alt=\"${albumName}\" class=\"w-full h-48 object-cover\">\n                <div class=\"p-4\">\n                    <h3 class=\"font-bold text-lg mb-1\">${albumName}</h3>\n                    <p class=\"text-gray-600 text-sm mb-2\">${artistName}</p>\n                    <div class=\"flex justify-between text-sm mb-2\">\n                        <span class=\"text-gray-700\">${trackCount} tracks</span>\n                        <span class=\"text-purple-600 font-semibold\">Score: ${score}</span>\n                    </div>\n                    ${artistBoostApplied ? `<span class=\"inline-block bg-yellow-100 text-yellow-800 text-xs px-2 py-1 rounded mb-2\">‚≠ê Favorite Artist (${boostMultiplier}x boost)</span>` : ''}\n                    <details class=\"text-xs text-gray-600 mb-3\">\n                        <summary class=\"cursor-pointer hover:text-purple-600 font-medium\">Score Breakdown</summary>\n                        <div class=\"mt-2 p-2 bg-gray-50 rounded\">\n                            <div>Base Score: ${baseScore}</div>\n                            ${artistBoostApplied ? `<div>Artist Boost: ${boostMultiplier}x</div>` : ''}\n                            <div class=\"mt-1 border-t pt-1\">\n                                <div>Short term: ${scoreByPeriod.short_term || 0} (${tracksByPeriod.short_term || 0} tracks, 3x boost)</div>\n                                <div>Medium term: ${scoreByPeriod.medium_term || 0} (${tracksByPeriod.medium_term || 0} tracks, 2x boost)</div>\n                                <div>Long term: ${scoreByPeriod.long_term || 0} (${tracksByPeriod.long_term || 0} tracks, 1x boost)</div>\n                            </div>\n                        </div>\n                    </details>\n                    \n                    <div class=\"border-t pt-3 mt-3\">\n                        <button \n                            onclick=\"getPricing('${artistName.replace(/'/g, \"\\\\'\")}', '${albumName.replace(/'/g, \"\\\\'\")}', this)\"\n                            class=\"w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded\"\n                        >\n                            üí∞ Get Prices\n                        </button>\n                        <div class=\"pricing-info hidden mt-3\"></div>\n                    </div>\n                </div>\n            </div>\n        `;\n    }).join('');\n    \n    // Show stats with total time\n    if (stats) {\n        const statsHtml = `\n            <div class=\"col-span-full bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4\">\n                <h3 class=\"font-bold text-lg mb-2\">Statistics</h3>\n                <div class=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n                    <div><span class=\"text-gray-600\">Total Time:</span> <span class=\"font-semibold text-green-600\">${totalTime}s</span></div>\n                    <div><span class=\"text-gray-600\">Tracks Analyzed:</span> <span class=\"font-semibold\">${stats.tracks_analyzed || 0}</span></div>\n                    <div><span class=\"text-gray-600\">Artists Analyzed:</span> <span class=\"font-semibold\">${stats.artists_analyzed || 0}</span></div>\n                    <div><span class=\"text-gray-600\">Albums Found:</span> <span class=\"font-semibold\">${stats.albums_found || 0}</span></div>\n                </div>\n            </div>\n        `;\n        resultsDiv.insertAdjacentHTML('afterbegin', statsHtml);\n    }\n}\n\n// CSV Import Functions\nfunction uploadCSV() {\n    const fileInput = document.getElementById('csv-file');\n    const file = fileInput.files[0];\n    \n    if (!file) {\n        alert('Por favor selecciona un archivo CSV');\n        return;\n    }\n    \n    const uploadBtn = document.getElementById('upload-btn');\n    const importSummary = document.getElementById('import-summary');\n    const importLogContainer = document.getElementById('import-log-container');\n    const importLog = document.getElementById('import-log');\n    \n    uploadBtn.disabled = true;\n    uploadBtn.textContent = '‚è≥ Importando...';\n    uploadBtn.classList.add('opacity-50', 'cursor-not-allowed');\n    \n    importSummary.classList.remove('hidden');\n    importLogContainer.classList.remove('hidden');\n    importLog.innerHTML = '';\n    \n    let totalCount = 0;\n    let successCount = 0;\n    let cachedCount = 0;\n    let failedCount = 0;\n    let currentCount = 0;\n    \n    const formData = new FormData();\n    formData.append('file', file);\n    \n    fetch('/api/admin/import-csv', {\n        method: 'POST',\n        body: formData\n    })\n    .then(response => {\n        const reader = response.body.getReader();\n        const decoder = new TextDecoder();\n        \n        function processStream() {\n            return reader.read().then(({ done, value }) => {\n                if (done) {\n                    uploadBtn.disabled = false;\n                    uploadBtn.textContent = '‚úÖ Completado';\n                    uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');\n                    setTimeout(() => {\n                        uploadBtn.textContent = 'üì§ Importar';\n                    }, 3000);\n                    return;\n                }\n                \n                const chunk = decoder.decode(value);\n                const lines = chunk.split('\\n');\n                \n                for (const line of lines) {\n                    if (!line.trim() || !line.startsWith('data: ')) continue;\n                    \n                    const jsonStr = line.substring(6);\n                    try {\n                        const data = JSON.parse(jsonStr);\n                        \n                        if (data.type === 'start') {\n                            totalCount = data.total;\n                            document.getElementById('total-count').textContent = totalCount;\n                        }\n                        \n                        else if (data.type === 'progress') {\n                            currentCount = data.current;\n                            const percent = Math.round((currentCount / totalCount) * 100);\n                            document.getElementById('progress-bar').style.width = percent + '%';\n                            document.getElementById('progress-text').textContent = `${currentCount} / ${totalCount}`;\n                            \n                            if (data.status === 'success') {\n                                successCount++;\n                                document.getElementById('success-count').textContent = successCount;\n                            } else if (data.status === 'cached') {\n                                cachedCount++;\n                                document.getElementById('cached-count').textContent = cachedCount;\n                            } else {\n                                failedCount++;\n                                document.getElementById('failed-count').textContent = failedCount;\n                            }\n                            \n                            const statusBadge = getStatusBadge(data.status);\n                            const row = `\n                                <tr class=\"hover:bg-gray-50\">\n                                    <td class=\"px-4 py-2 text-sm text-gray-500\">${data.current}</td>\n                                    <td class=\"px-4 py-2 text-sm font-medium\">${data.artist}</td>\n                                    <td class=\"px-4 py-2\">${statusBadge}</td>\n                                    <td class=\"px-4 py-2 text-sm\">${data.albums || '-'}</td>\n                                    <td class=\"px-4 py-2 text-sm text-gray-600\">${data.top_album || '-'}</td>\n                                    <td class=\"px-4 py-2 text-sm\">${data.rating ? `‚≠ê ${data.rating}/5` : '-'}</td>\n                                    <td class=\"px-4 py-2 text-sm text-gray-500\">${data.time ? data.time + 's' : '-'}</td>\n                                </tr>\n                            `;\n                            importLog.insertAdjacentHTML('beforeend', row);\n                            \n                            const logTable = importLogContainer.querySelector('.overflow-y-auto');\n                            logTable.scrollTop = logTable.scrollHeight;\n                        }\n                        \n                        else if (data.type === 'complete') {\n                            console.log('Import complete:', data);\n                        }\n                        \n                        else if (data.type === 'error') {\n                            alert('Error: ' + data.message);\n                            uploadBtn.disabled = false;\n                            uploadBtn.textContent = 'üì§ Importar';\n                            uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');\n                        }\n                    } catch (e) {\n                        console.error('Failed to parse SSE data:', e);\n                    }\n                }\n                \n                return processStream();\n            });\n        }\n        \n        return processStream();\n    })\n    .catch(error => {\n        console.error('Import failed:', error);\n        alert('Error durante la importaci√≥n: ' + error.message);\n        uploadBtn.disabled = false;\n        uploadBtn.textContent = 'üì§ Importar';\n        uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');\n    });\n}\n\nfunction getStatusBadge(status) {\n    const badges = {\n        'success': '<span class=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800\">‚úì Nuevo</span>',\n        'cached': '<span class=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-purple-100 text-purple-800\">‚ö° Cach√©</span>',\n        'not_found': '<span class=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800\">‚ö† Sin √°lbumes</span>',\n        'timeout': '<span class=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800\">‚è± Timeout</span>',\n        'error': '<span class=\"inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800\">‚úó Error</span>'\n    };\n    return badges[status] || badges.error;\n}\n\n// Initialize\ncheckServiceHealth();\nsetInterval(checkServiceHealth, 10000);\n","size_bytes":23842},"services/discogs/main.py":{"content":"from fastapi import FastAPI, Query, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\nimport os\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom libs.shared.models import DiscogsRelease, DiscogsStats, ServiceHealth\nfrom libs.shared.utils import create_http_client, log_event\nfrom .discogs_client import DiscogsClient\n\ndiscogs_client = None\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    global discogs_client\n    discogs_key = os.getenv(\"DISCOGS_KEY\", \"\")\n    discogs_secret = os.getenv(\"DISCOGS_SECRET\", \"\")\n    discogs_client = DiscogsClient(discogs_key, discogs_secret)\n    await discogs_client.start()\n    log_event(\"discogs-service\", \"INFO\", \"Discogs Service started\")\n    yield\n    await discogs_client.stop()\n    log_event(\"discogs-service\", \"INFO\", \"Discogs Service stopped\")\n\n\napp = FastAPI(lifespan=lifespan, title=\"Discogs Service\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    return ServiceHealth(\n        service_name=\"discogs-service\",\n        status=\"healthy\" if discogs_client and discogs_client.is_ready() else \"unhealthy\"\n    ).dict()\n\n\n@app.get(\"/search\")\nasync def search_release(artist: str = Query(...), title: str = Query(...)):\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Searching for: {artist} - {title}\")\n    \n    response = await discogs_client.search_release(artist, title)\n    results = response.get(\"results\", [])\n    debug_info = response.get(\"debug_info\", {})\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Found {len(results)} results for {artist} - {title}\")\n    return {\"releases\": results, \"total\": len(results), \"debug_info\": debug_info}\n\n\n@app.get(\"/stats/{release_id}\")\nasync def get_marketplace_stats(release_id: int, currency: str = \"EUR\"):\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Getting stats for release {release_id}\")\n    \n    stats = await discogs_client.get_marketplace_stats(release_id, currency)\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Stats retrieved for release {release_id}: {stats.get('num_for_sale', 0)} items for sale\")\n    return stats\n\n\n@app.get(\"/sell-list-url/{release_id}\")\nasync def get_sell_list_url(release_id: int):\n    if not discogs_client or not discogs_client.is_ready():\n        raise HTTPException(status_code=503, detail=\"Discogs client not ready\")\n    \n    # Get master_id from release_id\n    master_id = await discogs_client._get_master_id_from_release(release_id)\n    \n    # Use master_id if available, otherwise fallback to release_id\n    if master_id:\n        url = f\"https://www.discogs.com/sell/list?master_id={master_id}&currency=EUR&format=Vinyl\"\n        log_event(\"discogs-service\", \"INFO\", f\"Generated sell list URL for release {release_id} (master_id: {master_id})\")\n    else:\n        url = f\"https://www.discogs.com/sell/list?release_id={release_id}&currency=EUR&format=Vinyl\"\n        log_event(\"discogs-service\", \"WARNING\", f\"Generated sell list URL for release {release_id} (master_id not found)\")\n    \n    return {\"release_id\": release_id, \"url\": url}\n\n\n@app.get(\"/master-link/{artist}/{album}\")\nasync def get_master_link(artist: str, album: str):\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Fetching master link for: {artist} - {album}\")\n    \n    result = await discogs_client.get_master_link(artist, album)\n    \n    if result.get(\"master_id\"):\n        log_event(\"discogs-service\", \"INFO\", f\"Master found for {artist} - {album}: {result['master_id']}\")\n    else:\n        log_event(\"discogs-service\", \"INFO\", f\"No master found for {artist} - {album}\")\n    \n    return result\n\n\n@app.get(\"/search-album\")\nasync def search_album_cover(artist: str = Query(...), album: str = Query(...)):\n    \"\"\"\n    Simplified search that returns only the cover URL for an album\n    Used by Last.fm recommendations to populate basic album entries\n    \"\"\"\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Searching cover for: {artist} - {album}\")\n    \n    try:\n        response = await discogs_client.search_release(artist, album)\n        results = response.get(\"results\", [])\n        \n        if results:\n            cover_url = results[0].get(\"cover_image\") or results[0].get(\"thumb\")\n            log_event(\"discogs-service\", \"INFO\", f\"Cover found for {artist} - {album}\")\n            return {\"cover_url\": cover_url, \"found\": True}\n        else:\n            log_event(\"discogs-service\", \"INFO\", f\"No cover found for {artist} - {album}\")\n            return {\"cover_url\": None, \"found\": False}\n    except Exception as e:\n        log_event(\"discogs-service\", \"ERROR\", f\"Error searching cover: {str(e)}\")\n        return {\"cover_url\": None, \"found\": False, \"error\": str(e)}\n\n\n@app.get(\"/master-tracklist/{master_id}\")\nasync def get_master_tracklist(master_id: int):\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Fetching tracklist for master: {master_id}\")\n    \n    result = await discogs_client.get_master_tracklist(master_id)\n    \n    if result.get(\"tracklist\"):\n        log_event(\"discogs-service\", \"INFO\", f\"Tracklist found for master {master_id}: {len(result['tracklist'])} tracks\")\n    else:\n        log_event(\"discogs-service\", \"INFO\", f\"No tracklist found for master {master_id}\")\n    \n    return result\n\n\n@app.get(\"/release-tracklist/{release_id}\")\nasync def get_release_tracklist(release_id: int):\n    if not discogs_client:\n        raise HTTPException(status_code=500, detail=\"Discogs client not initialized\")\n    \n    log_event(\"discogs-service\", \"INFO\", f\"Fetching tracklist for release: {release_id}\")\n    \n    result = await discogs_client.get_release_tracklist(release_id)\n    \n    if result.get(\"tracklist\"):\n        log_event(\"discogs-service\", \"INFO\", f\"Tracklist found for release {release_id}: {len(result['tracklist'])} tracks\")\n    else:\n        log_event(\"discogs-service\", \"INFO\", f\"No tracklist found for release {release_id}\")\n    \n    return result\n","size_bytes":6613},"services/recommender/__init__.py":{"content":"# Recommendation Service\n","size_bytes":25},"services/spotify/spotify_client.py":{"content":"import httpx\nfrom typing import List, Dict, Optional\nfrom libs.shared.utils import log_event\n\n\nclass SpotifyClient:\n    def __init__(self, auth_manager):\n        self.auth_manager = auth_manager\n        self.client: Optional[httpx.AsyncClient] = None\n        self.api_base = \"https://api.spotify.com/v1\"\n    \n    async def start(self):\n        self.client = httpx.AsyncClient(timeout=30.0)\n    \n    async def stop(self):\n        if self.client:\n            await self.client.aclose()\n    \n    def is_ready(self) -> bool:\n        return self.client is not None and self.auth_manager.is_authenticated()\n    \n    def _get_auth_header(self) -> dict:\n        token = self.auth_manager.get_access_token()\n        if not token:\n            return {}\n        return {\"Authorization\": f\"Bearer {token}\"}\n    \n    async def _request(self, method: str, path: str, **kwargs):\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        url = f\"{self.api_base}{path}\"\n        headers = self._get_auth_header()\n        \n        resp = await self.client.request(method, url, headers=headers, **kwargs)\n        \n        if resp.status_code == 401:\n            log_event(\"spotify-client\", \"INFO\", \"Token expired, refreshing...\")\n            await self.auth_manager.refresh_access_token()\n            headers = self._get_auth_header()\n            resp = await self.client.request(method, url, headers=headers, **kwargs)\n        \n        resp.raise_for_status()\n        return resp.json()\n    \n    async def get_user_profile(self) -> dict:\n        return await self._request(\"GET\", \"/me\")\n    \n    async def get_top_tracks(self, time_range: str = \"medium_term\", limit: int = 300) -> List[dict]:\n        all_tracks = []\n        offset = 0\n        batch_size = 50\n        \n        while len(all_tracks) < limit:\n            log_event(\"spotify-client\", \"INFO\", f\"Fetching tracks batch: offset={offset}, time_range={time_range}\")\n            \n            params = {\n                \"time_range\": time_range,\n                \"limit\": batch_size,\n                \"offset\": offset\n            }\n            \n            data = await self._request(\"GET\", \"/me/top/tracks\", params=params)\n            items = data.get(\"items\", [])\n            \n            if not items:\n                break\n            \n            all_tracks.extend(items)\n            offset += batch_size\n            \n            if len(items) < batch_size:\n                break\n        \n        return all_tracks[:limit]\n    \n    async def get_top_artists(self, time_range: str = \"medium_term\", limit: int = 300) -> List[dict]:\n        all_artists = []\n        offset = 0\n        batch_size = 50\n        \n        while len(all_artists) < limit:\n            log_event(\"spotify-client\", \"INFO\", f\"Fetching artists batch: offset={offset}, time_range={time_range}\")\n            \n            params = {\n                \"time_range\": time_range,\n                \"limit\": batch_size,\n                \"offset\": offset\n            }\n            \n            data = await self._request(\"GET\", \"/me/top/artists\", params=params)\n            items = data.get(\"items\", [])\n            \n            if not items:\n                break\n            \n            all_artists.extend(items)\n            offset += batch_size\n            \n            if len(items) < batch_size:\n                break\n        \n        return all_artists[:limit]\n    \n    async def get_album(self, album_id: str) -> dict:\n        return await self._request(\"GET\", f\"/albums/{album_id}\")\n","size_bytes":3527},"tests/app.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport streamlit as st\nimport pandas as pd\n\n# === IMPORTA TU L√ìGICA SIN DUPLICAR ===\nfrom discogs_studio_masters import (\n    search_master,\n    collect_releases_from_master,\n    search_releases,\n    discogs_dataframe,\n)\nfrom mb_studio_vinyl import mb_dataframe\n\n# =========================\n# Config\n# =========================\nDEFAULT_DISCOGS_KEY = \"QiaraVlzXNSUJOpkdKdK\"\nDEFAULT_DISCOGS_SECRET = \"BssuhxnAECuSXYoFYPzIuSUixhVXRedG\"\n\nst.set_page_config(page_title=\"Vinilogy ‚Äì Discogs & MusicBrainz\", page_icon=\"üíø\", layout=\"wide\")\n\nwith st.sidebar:\n    st.markdown(\"## ‚öôÔ∏è Configuraci√≥n\")\n    discogs_key = st.text_input(\"Discogs Consumer Key\", value=DEFAULT_DISCOGS_KEY, type=\"password\")\n    discogs_secret = st.text_input(\"Discogs Consumer Secret\", value=DEFAULT_DISCOGS_SECRET, type=\"password\")\n    st.caption(\"Usa tus claves de Discogs. (Guardadas solo en esta sesi√≥n)\")\n\nst.title(\"üíø Vinilogy ‚Äì B√∫squeda de ediciones en vinilo\")\ntab1, tab2 = st.tabs([\"Discogs Releases\", \"MusicBrainz Studio Albums\"])\n\n# =========================\n# Discogs UI\n# =========================\nwith tab1:\n    st.subheader(\"Discogs ‚Äì Releases (por Master ID o por Artista + √Ålbum)\")\n\n    modo = st.radio(\n        \"¬øC√≥mo quieres buscar?\",\n        [\"Master ID\", \"Artista + √Ålbum\"],\n        index=0,\n        horizontal=True\n    )\n\n    with st.form(\"discogs_form\", clear_on_submit=False):\n        if modo == \"Master ID\":\n            master_id_input = st.text_input(\"Master ID\", placeholder=\"Ejemplo: 123456\")\n        else:\n            colA, colB = st.columns(2)\n            with colA:\n                artist = st.text_input(\"Artista\", placeholder=\"JW Francis\")\n            with colB:\n                title = st.text_input(\"√Ålbum (t√≠tulo)\", placeholder=\"Sunshine\")\n            usar_master_si_existe = st.checkbox(\"Usar master si existe (recomendado)\", value=True)\n\n        colf1, colf2 = st.columns(2)\n        with colf1:\n            official_only = st.checkbox(\"Solo ediciones oficiales (excluir Unofficial)\", value=True)\n        with colf2:\n            es_europe_only = st.checkbox(\"Solo Spain o 'Europe'\", value=False)\n\n        submitted = st.form_submit_button(\"üîé Buscar\")\n        st.divider()\n\n        if submitted:\n            try:\n                rows = []\n\n                if modo == \"Master ID\":\n                    mid = (master_id_input or \"\").strip()\n                    if not mid:\n                        st.warning(\"Introduce un Master ID.\")\n                        st.stop()\n                    if not mid.isdigit():\n                        st.error(\"El Master ID debe ser num√©rico (p. ej. 123456).\")\n                        st.stop()\n\n                    # releases (versions) del master\n                    rows = collect_releases_from_master(int(mid), discogs_key, discogs_secret)\n\n                else:  # Artista + √Ålbum\n                    if not (artist and title):\n                        st.warning(\"Indica Artista y √Ålbum.\")\n                        st.stop()\n\n                    m = None\n                    if usar_master_si_existe:\n                        m = search_master(artist, title, discogs_key, discogs_secret)\n\n                    if m:\n                        rows = collect_releases_from_master(int(m.get(\"id\")), discogs_key, discogs_secret)\n                    else:\n                        rows = search_releases(artist, title, discogs_key, discogs_secret)\n\n                # dataframe + filtros (lo hace tu m√≥dulo)\n                df = discogs_dataframe(rows, official_only=official_only, es_europe_only=es_europe_only)\n\n                if df.empty:\n                    # Fallback para no dejar vac√≠o: muestra sin filtrar por vinilo\n                    df_all = pd.DataFrame(rows, columns=[\"release_id\",\"year\",\"format\",\"country\",\"label\",\"catno\",\"title\",\"source\"])\n                    if df_all.empty:\n                        st.info(\"Sin resultados.\")\n                    else:\n                        st.warning(\"No he encontrado ediciones de vinilo tras filtrar. Muestro todas las releases encontradas.\")\n                        st.dataframe(df_all, use_container_width=True)\n                        csv = df_all.to_csv(index=False).encode(\"utf-8\")\n                        st.download_button(\"‚¨áÔ∏è Descargar CSV\", data=csv, file_name=\"discogs_releases_all.csv\", mime=\"text/csv\")\n                else:\n                    st.success(f\"{len(df)} release(s) encontradas.\")\n                    st.dataframe(df, use_container_width=True)\n                    csv = df.to_csv(index=False).encode(\"utf-8\")\n                    fname = \"discogs_releases.csv\" if modo == \"Artista + √Ålbum\" else f\"discogs_master_{(master_id_input or '').strip()}.csv\"\n                    st.download_button(\"‚¨áÔ∏è Descargar CSV\", data=csv, file_name=fname, mime=\"text/csv\")\n\n            except Exception as e:\n                st.error(f\"Error: {e}\")\n\n# =========================\n# MusicBrainz UI\n# =========================\nwith tab2:\n    st.subheader(\"MusicBrainz ‚Äì √Ålbumes de estudio (RG)\")\n    col1, col2 = st.columns([2,1])\n    with col1:\n        mb_artist = st.text_input(\"Artista (MB)\", placeholder=\"The Rolling Stones\")\n    with col2:\n        mb_limit = st.number_input(\"L√≠mite (1‚Äì100)\", min_value=1, max_value=100, value=100, step=1)\n\n    run_mb = st.button(\"üéº Buscar en MusicBrainz\")\n    st.caption(\"Trae release-groups de tipo Album, sin secondary-types y con √∫nico artista. Si MB enlaza un master de Discogs, lo muestra.\")\n    st.divider()\n\n    if run_mb:\n        try:\n            df_mb = mb_dataframe(mb_artist, limit=int(mb_limit))\n            if df_mb.empty:\n                st.info(\"Sin resultados.\")\n            else:\n                st.dataframe(df_mb, use_container_width=True)\n                csv = df_mb.to_csv(index=False).encode(\"utf-8\")\n                st.download_button(\"‚¨áÔ∏è Descargar CSV\", data=csv, file_name=\"musicbrainz_albums.csv\", mime=\"text/csv\")\n        except Exception as e:\n            st.error(f\"Error: {e}\")\n","size_bytes":6033},"tests/lastfm_artist_explorer.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nlastfm_artist_explorer.py\n\nApp TODO-en-uno (frontend + l√≥gica) para:\n\n- Buscar artistas en Last.fm mientras escribes (artist.search).\n- A√±adir artistas seleccionados.\n- Mostrar siempre hasta 10 artistas sugeridos, combinando los similares\n  de todos los artistas seleccionados.\n- Para cada artista seleccionado, ver sus discos de estudio\n  (MusicBrainz) y rating de vinilo (Discogs) en paralelo.\n\nEjecutar con:\n\n    streamlit run lastfm_artist_explorer.py --server.port 8000 --server.address 0.0.0.0\n\"\"\"\n\nimport os\nimport re\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Tuple, Any\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\nimport httpx\nimport pandas as pd\nimport streamlit as st\n\n# =========================\n# Configuraci√≥n APIs\n# =========================\n\nLASTFM_API_KEY = os.getenv(\"LASTFM_API_KEY\")\nLASTFM_BASE_URL = \"https://ws.audioscrobbler.com/2.0/\"\n\nMB_BASE = \"https://musicbrainz.org/ws/2\"\nDISCOGS_BASE = \"https://api.discogs.com\"\n\nDISCOGS_KEY = os.getenv(\"DISCOGS_KEY\")\nDISCOGS_SECRET = os.getenv(\"DISCOGS_SECRET\")\n\nHEADERS = {\n    \"User-Agent\": \"Vinilogy/1.0 (+https://vinilogy.com; contact@vinilogy.com)\"\n}\n\n_RE_DISCOGS_MASTER = re.compile(\n    r\"https?://(?:www\\.)?discogs\\.com/(?:[a-z]{2}/)?master/(\\d+)\", re.I\n)\n\n\n# =========================\n# Cliente HTTP reutilizable (MB + Discogs)\n# =========================\n\nCLIENT = httpx.Client(\n    headers=HEADERS,\n    http2=False,\n    timeout=httpx.Timeout(30.0),\n    limits=httpx.Limits(max_connections=10, max_keepalive_connections=10),\n    follow_redirects=True,\n)\n\n# =========================\n# Modelos internos\n# =========================\n\n@dataclass\nclass Artist:\n    name: str\n    mbid: Optional[str] = None\n    image_url: Optional[str] = None\n\n\n# =========================\n# Cliente Last.fm\n# =========================\n\nclass LastFMClient:\n    def __init__(self, api_key: str, base_url: str = LASTFM_BASE_URL, \n                 discogs_key: Optional[str] = None, discogs_secret: Optional[str] = None) -> None:\n        self.api_key = api_key\n        self.base_url = base_url\n        self.discogs_key = discogs_key\n        self.discogs_secret = discogs_secret\n\n    def _build_params(self, method: str, extra: Optional[Dict[str, str]] = None) -> Dict[str, str]:\n        params = {\n            \"method\": method,\n            \"api_key\": self.api_key,\n            \"format\": \"json\",\n        }\n        if extra:\n            params.update(extra)\n        return params\n\n    def search_artists_discogs(self, query: str, limit: int = 5) -> Tuple[List[Artist], float]:\n        \"\"\"\n        Busca artistas en Discogs si hay credenciales (trae im√°genes thumb).\n        Fallback a Last.fm si no hay credenciales de Discogs.\n        Devuelve (lista de artistas, tiempo en segundos).\n        \"\"\"\n        start_time = time.time()\n        \n        if not query.strip():\n            return [], 0.0\n\n        if self.discogs_key and self.discogs_secret:\n            try:\n                params = {\n                    \"q\": query.strip(),\n                    \"type\": \"artist\",\n                    \"key\": self.discogs_key,\n                    \"secret\": self.discogs_secret,\n                    \"per_page\": str(limit),\n                }\n                \n                with httpx.Client(timeout=10.0) as client:\n                    resp = client.get(f\"{DISCOGS_BASE}/database/search\", params=params)\n                resp.raise_for_status()\n                data = resp.json()\n                \n                results = data.get(\"results\", [])\n                artists: List[Artist] = []\n                \n                for item in results[:limit]:\n                    name = item.get(\"title\")\n                    if not name:\n                        continue\n                        \n                    thumb_url = item.get(\"thumb\")\n                    if thumb_url and thumb_url.startswith(\"http\"):\n                        image_url = thumb_url\n                    else:\n                        image_url = None\n                    \n                    artists.append(Artist(name=name, mbid=None, image_url=image_url))\n                \n                elapsed = time.time() - start_time\n                return artists, elapsed\n                \n            except httpx.HTTPError as e:\n                st.warning(f\"Error al consultar Discogs, usando Last.fm como fallback: {e}\")\n        \n        params = self._build_params(\n            \"artist.search\",\n            {\n                \"artist\": query,\n                \"limit\": str(limit),\n            },\n        )\n\n        try:\n            with httpx.Client(timeout=10.0) as client:\n                resp = client.get(self.base_url, params=params)\n            resp.raise_for_status()\n        except httpx.HTTPError as e:\n            st.error(f\"Error al consultar Last.fm: {e}\")\n            return [], time.time() - start_time\n\n        data = resp.json()\n        results = data.get(\"results\", {}).get(\"artistmatches\", {}).get(\"artist\", [])\n\n        if isinstance(results, dict):\n            results = [results]\n\n        artists: List[Artist] = []\n        for item in results:\n            name = item.get(\"name\")\n            if not name:\n                continue\n            mbid = item.get(\"mbid\") or None\n            artists.append(Artist(name=name, mbid=mbid, image_url=None))\n        \n        elapsed = time.time() - start_time\n        return artists, elapsed\n\n    def get_artist_info(self, *, name: Optional[str] = None, mbid: Optional[str] = None) -> Optional[Dict[str, Any]]:\n        \"\"\"Obtiene informaci√≥n detallada del artista usando artist.getInfo (incluye 5 similares).\"\"\"\n        extra: Dict[str, str] = {}\n        if mbid:\n            extra[\"mbid\"] = mbid\n        elif name:\n            extra[\"artist\"] = name\n        else:\n            return None\n\n        params = self._build_params(\"artist.getInfo\", extra)\n\n        try:\n            with httpx.Client(timeout=10.0) as client:\n                resp = client.get(self.base_url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            return data.get(\"artist\")\n        except httpx.HTTPError:\n            return None\n\n    def get_similar_artist_images_discogs(self, artist_names: List[str]) -> Dict[str, Optional[str]]:\n        \"\"\"\n        Busca im√°genes en Discogs para una lista de nombres de artistas.\n        Devuelve diccionario {nombre_artista: url_imagen}\n        \"\"\"\n        result = {}\n        for name in artist_names:\n            if not name or not self.discogs_key or not self.discogs_secret:\n                result[name] = None\n                continue\n                \n            try:\n                params = {\n                    \"q\": name,\n                    \"type\": \"artist\",\n                    \"key\": self.discogs_key,\n                    \"secret\": self.discogs_secret,\n                    \"per_page\": \"1\",\n                }\n                \n                with httpx.Client(timeout=5.0) as client:\n                    resp = client.get(f\"{DISCOGS_BASE}/database/search\", params=params)\n                resp.raise_for_status()\n                data = resp.json()\n                \n                results = data.get(\"results\", [])\n                if results and results[0].get(\"thumb\"):\n                    result[name] = results[0][\"thumb\"]\n                else:\n                    result[name] = None\n                    \n            except httpx.HTTPError:\n                result[name] = None\n                \n        return result\n\n\n# =========================\n# Helpers MusicBrainz\n# =========================\n\ndef _mb_get(path: str, params: Dict[str, Any], tries: int = 5,\n            sleep_after_ok: float = 1.0, debug: bool = False) -> Dict[str, Any]:\n    url = f\"{MB_BASE}{path}\"\n    params = {**params, \"fmt\": \"json\"}\n    last_exc = None\n    backoff = 0.6\n\n    for attempt in range(1, tries + 1):\n        try:\n            if debug:\n                st.write(f\"[MB] GET {url} params={params} (attempt {attempt})\")\n            r = CLIENT.get(url, params=params)\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError(\"Transient\", r.request, r)\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            if debug:\n                st.write(f\"[MB] error {e}; retrying in {backoff:.1f}s\")\n            time.sleep(backoff)\n            backoff = min(backoff * 1.7, 5.0)\n\n    raise RuntimeError(f\"MB failed: {last_exc}\")\n\n\ndef _find_artist_mbid(name: str, debug: bool = False) -> Optional[str]:\n    data = _mb_get(\"/artist\", {\"query\": f'artist:\"{name}\"', \"limit\": 10}, debug=debug)\n    artists = data.get(\"artists\", []) or []\n    if not artists:\n        return None\n    exact = [a for a in artists if a.get(\"name\", \"\").lower() == name.lower()]\n    chosen = exact[0] if exact else artists[0]\n    return chosen.get(\"id\")\n\n\ndef _fetch_release_groups(artist_mbid: str, limit: int = 100, debug: bool = False):\n    data = _mb_get(\n        \"/release-group\",\n        {\n            \"artist\": artist_mbid,\n            \"primary-type\": \"Album\",\n            \"inc\": \"artist-credits+url-rels\",\n            \"limit\": min(limit, 100),\n        },\n        debug=debug,\n    )\n    return data.get(\"release-groups\", []) or []\n\n\ndef _is_studio_album(rg: Dict[str, Any], artist_mbid: str) -> bool:\n    if rg.get(\"primary-type\") != \"Album\":\n        return False\n    if rg.get(\"secondary-types\"):\n        return False\n    ac = rg.get(\"artist-credit\") or []\n    if len(ac) != 1:\n        return False\n    return (ac[0].get(\"artist\") or {}).get(\"id\") == artist_mbid\n\n\ndef _year_from_date(item: Dict[str, Any]) -> str:\n    d = item.get(\"first-release-date\") or \"\"\n    return d.split(\"-\")[0] if d else \"\"\n\n\ndef _discogs_master_from_rels(relations: Any) -> str:\n    if not relations:\n        return \"\"\n    for rel in relations:\n        if rel.get(\"type\") == \"discogs\":\n            url = (rel.get(\"url\") or {}).get(\"resource\", \"\")\n            m = _RE_DISCOGS_MASTER.search(url)\n            if m:\n                return m.group(1)\n    return \"\"\n\n\n# =========================\n# Helpers Discogs\n# =========================\n\ndef _discogs_get(path: str, params: Dict[str, Any],\n                 key: str, secret: str,\n                 sleep_after_ok: float = 0.25,\n                 debug: bool = False):\n\n    url = f\"{DISCOGS_BASE}{path}\"\n    params = {**params, \"key\": key, \"secret\": secret}\n\n    if debug:\n        st.write(f\"[Discogs] GET {url} {params}\")\n\n    r = CLIENT.get(url, params=params)\n    r.raise_for_status()\n    time.sleep(sleep_after_ok)\n    return r.json()\n\n\ndef _discogs_master_rating(master_id: str, key: str, secret: str, debug: bool = False):\n    \"\"\"\n    Devuelve (rating, votes) usando master o main_release.\n    \"\"\"\n    if not master_id:\n        return None, None\n\n    data = _discogs_get(f\"/masters/{master_id}\", {}, key, secret, debug=debug)\n    r = (data.get(\"community\") or {}).get(\"rating\") or {}\n    if r.get(\"average\") is not None:\n        return float(r[\"average\"]), int(r.get(\"count\", 0))\n\n    main_rel = data.get(\"main_release\")\n    if not main_rel:\n        return None, None\n\n    rel = _discogs_get(f\"/releases/{main_rel}\", {}, key, secret, debug=debug)\n    rr = (rel.get(\"community\") or {}).get(\"rating\") or {}\n    if rr.get(\"average\") is None:\n        return None, None\n    return float(rr[\"average\"]), int(rr.get(\"count\", 0))\n\n\n# =========================\n# Parallel rating fetcher\n# =========================\n\ndef attach_discogs_ratings(df: pd.DataFrame, key: str, secret: str, debug: bool = False) -> pd.DataFrame:\n    if df.empty:\n        return df\n\n    df = df.copy()\n    master_ids = df[\"discogs_master_id\"].tolist()\n\n    def process_one(mid: str):\n        if not mid:\n            return (None, None)\n        try:\n            return _discogs_master_rating(mid, key, secret, debug)\n        except Exception:\n            return (None, None)\n\n    batch_size = 5\n    results: List[Tuple[Optional[float], Optional[int]]] = []\n\n    for i in range(0, len(master_ids), batch_size):\n        chunk = master_ids[i:i + batch_size]\n        with ThreadPoolExecutor(max_workers=batch_size) as exe:\n            future_map = {exe.submit(process_one, mid): mid for mid in chunk}\n            for fut in as_completed(future_map):\n                results.append(fut.result())\n\n        time.sleep(0.25)\n\n    df[\"discogs_rating\"] = [r[0] for r in results]\n    df[\"discogs_votes\"] = [r[1] for r in results]\n    return df\n\n\n# =========================\n# API p√∫blica: MB + Discogs\n# =========================\n\ndef mb_dataframe(\n    artist: Optional[str] = None,\n    artist_mbid: Optional[str] = None,\n    discogs_key: Optional[str] = None,\n    discogs_secret: Optional[str] = None,\n    debug: bool = False,\n) -> pd.DataFrame:\n    \"\"\"\n    Devuelve los √°lbumes de estudio de un artista:\n    - year, title, discogs_master_id, rg_mbid\n    Y si hay Discogs key/secret:\n    - discogs_rating, discogs_votes\n    \"\"\"\n    if not artist_mbid:\n        if not artist:\n            return pd.DataFrame()\n        artist_mbid = _find_artist_mbid(artist, debug=debug)\n\n    if not artist_mbid:\n        return pd.DataFrame()\n\n    rgs = _fetch_release_groups(artist_mbid, debug=debug)\n    filtered = [rg for rg in rgs if _is_studio_album(rg, artist_mbid)]\n\n    rows: List[Dict[str, Any]] = []\n    for rg in filtered:\n        rows.append({\n            \"year\": _year_from_date(rg),\n            \"title\": rg.get(\"title\", \"\").strip(),\n            \"discogs_master_id\": _discogs_master_from_rels(rg.get(\"relations\")),\n            \"rg_mbid\": rg.get(\"id\", \"\")\n        })\n\n    df = pd.DataFrame(rows)\n    if df.empty:\n        return df\n\n    df.sort_values(\"year\", inplace=True, ignore_index=True)\n\n    if discogs_key and discogs_secret:\n        df = attach_discogs_ratings(df, discogs_key, discogs_secret, debug)\n\n    return df\n\n\n# =========================\n# L√≥gica de sugerencias (Last.fm)\n# =========================\n\ndef build_suggestions(\n    client: LastFMClient,\n    selected: List[Artist],\n    limit: int = 5,\n) -> Tuple[List[Artist], float]:\n    \"\"\"\n    Genera sugerencias h√≠bridas:\n    - 2 del √∫ltimo artista a√±adido (garantizados)\n    - 3 de los m√°s votados globalmente\n    \n    Busca im√°genes en Discogs solo para los artistas sugeridos.\n    Devuelve (lista de artistas sugeridos, tiempo total en segundos).\n    \"\"\"\n    start_time = time.time()\n    \n    if not selected or limit <= 0:\n        return [], 0.0\n\n    last_artist_count = min(2, limit)\n    global_count = limit - last_artist_count\n    \n    last_artist = selected[-1]\n    last_artist_similars: List[str] = []\n    \n    last_info = client.get_artist_info(name=last_artist.name, mbid=last_artist.mbid)\n    if last_info:\n        similars = last_info.get(\"similar\", {}).get(\"artist\", [])\n        if isinstance(similars, dict):\n            similars = [similars]\n        \n        for sim in similars[:last_artist_count]:\n            sim_name = sim.get(\"name\")\n            if sim_name and sim_name.lower() != last_artist.name.lower():\n                last_artist_similars.append(sim_name)\n\n    candidate_counts: Dict[str, int] = {}\n    candidate_names: Dict[str, str] = {}\n\n    for seed in selected:\n        artist_info = client.get_artist_info(name=seed.name, mbid=seed.mbid)\n        if not artist_info:\n            continue\n        \n        similars = artist_info.get(\"similar\", {}).get(\"artist\", [])\n        if isinstance(similars, dict):\n            similars = [similars]\n        \n        for sim in similars:\n            sim_name = sim.get(\"name\")\n            if not sim_name:\n                continue\n            \n            sim_name_lower = sim_name.lower()\n            \n            if sim_name_lower == seed.name.lower():\n                continue\n            \n            candidate_counts[sim_name_lower] = candidate_counts.get(sim_name_lower, 0) + 1\n            if sim_name_lower not in candidate_names:\n                candidate_names[sim_name_lower] = sim_name\n    \n    selected_keys_lower = {s.name.lower() for s in selected}\n    for sel_key in selected_keys_lower:\n        candidate_counts.pop(sel_key, None)\n        candidate_names.pop(sel_key, None)\n    \n    last_artist_similars_lower = {name.lower() for name in last_artist_similars}\n    for name_lower in last_artist_similars_lower:\n        candidate_counts.pop(name_lower, None)\n        candidate_names.pop(name_lower, None)\n    \n    sorted_candidates = sorted(\n        candidate_counts.items(),\n        key=lambda kv: kv[1],\n        reverse=True,\n    )\n    \n    global_artist_names = [candidate_names[name_lower] for name_lower, _ in sorted_candidates[:global_count]]\n    \n    final_artist_names = last_artist_similars + global_artist_names\n    \n    images_map = client.get_similar_artist_images_discogs(final_artist_names)\n    \n    suggestions: List[Artist] = []\n    for name in final_artist_names:\n        image_url = images_map.get(name)\n        suggestions.append(Artist(name=name, mbid=None, image_url=image_url))\n    \n    elapsed = time.time() - start_time\n    return suggestions, elapsed\n\n\n# =========================\n# Helpers de estado (Streamlit)\n# =========================\n\ndef init_state():\n    if \"selected_artists\" not in st.session_state:\n        st.session_state.selected_artists: List[Artist] = []\n    if \"suggested_artists\" not in st.session_state:\n        st.session_state.suggested_artists: List[Artist] = []\n    if \"last_search_time\" not in st.session_state:\n        st.session_state.last_search_time: float = 0.0\n    if \"last_suggestions_time\" not in st.session_state:\n        st.session_state.last_suggestions_time: float = 0.0\n\n\ndef add_selected(artist: Artist, client: LastFMClient, limit: int = 5):\n    for a in st.session_state.selected_artists:\n        if a.name.lower() == artist.name.lower() and (\n            (not a.mbid and not artist.mbid) or (a.mbid == artist.mbid)\n        ):\n            return\n    st.session_state.selected_artists.append(artist)\n    suggestions, elapsed = build_suggestions(\n        client, st.session_state.selected_artists, limit=limit\n    )\n    st.session_state.suggested_artists = suggestions\n    st.session_state.last_suggestions_time = elapsed\n\n\ndef remove_selected(index: int, client: LastFMClient, limit: int = 5):\n    if 0 <= index < len(st.session_state.selected_artists):\n        st.session_state.selected_artists.pop(index)\n        suggestions, elapsed = build_suggestions(\n            client, st.session_state.selected_artists, limit=limit\n        )\n        st.session_state.suggested_artists = suggestions\n        st.session_state.last_suggestions_time = elapsed\n\n\n# =========================\n# App Streamlit\n# =========================\n\ndef main():\n    st.set_page_config(page_title=\"Explorador de artistas (Last.fm)\", layout=\"wide\")\n    st.title(\"üéß Explorador de artistas basado en Last.fm + discos de estudio (MB/Discogs)\")\n\n    if not LASTFM_API_KEY:\n        st.error(\n            \"No se ha encontrado `LASTFM_API_KEY`. \"\n            \"A√±√°delo como variable de entorno/Secret.\"\n        )\n        st.stop()\n\n    client = LastFMClient(\n        api_key=LASTFM_API_KEY,\n        discogs_key=DISCOGS_KEY,\n        discogs_secret=DISCOGS_SECRET\n    )\n    init_state()\n\n    if not DISCOGS_KEY or not DISCOGS_SECRET:\n        st.warning(\n            \"‚ö†Ô∏è No se han encontrado `DISCOGS_KEY` y/o `DISCOGS_SECRET`. \"\n            \"Se mostrar√°n los discos de estudio pero sin rating ni im√°genes de Discogs.\"\n        )\n\n    st.markdown(\n        \"Escribe un nombre de artista, a√±√°delo a la selecci√≥n y el sistema \"\n        \"te propondr√° hasta **5 artistas similares** con im√°genes reales de Discogs. \"\n        \"Para cada artista seleccionado puedes ver sus **discos de estudio** con el rating de vinilo.\"\n    )\n    \n    if st.session_state.last_search_time > 0 or st.session_state.last_suggestions_time > 0:\n        metrics_cols = st.columns(3)\n        if st.session_state.last_search_time > 0:\n            with metrics_cols[0]:\n                st.metric(\"‚è±Ô∏è √öltima b√∫squeda\", f\"{st.session_state.last_search_time:.2f}s\")\n        if st.session_state.last_suggestions_time > 0:\n            with metrics_cols[1]:\n                st.metric(\"‚è±Ô∏è Generaci√≥n sugerencias\", f\"{st.session_state.last_suggestions_time:.2f}s\")\n\n    col_search, col_selected, col_suggestions = st.columns([2, 2, 3])\n\n    # -------- B√öSQUEDA --------\n    with col_search:\n        st.subheader(\"üîç Buscar artista\")\n        query = st.text_input(\n            \"Nombre del artista\",\n            placeholder=\"Arctic Monkeys, Metallica...\",\n            key=\"search_box\",\n        )\n\n        search_results: List[Artist] = []\n        if st.session_state.search_box and len(st.session_state.search_box.strip()) >= 2:\n            search_results, search_time = client.search_artists_discogs(st.session_state.search_box.strip(), limit=5)\n            st.session_state.last_search_time = search_time\n\n        if query and not search_results:\n            st.info(\"No se han encontrado artistas para esa b√∫squeda.\")\n\n        for i, artist in enumerate(search_results):\n            with st.container():\n                cols = st.columns([1, 3])\n                with cols[0]:\n                    if artist.image_url:\n                        st.image(artist.image_url, use_container_width=True)\n                    else:\n                        st.write(\"üéµ\")\n                with cols[1]:\n                    st.markdown(f\"**{artist.name}**\")\n                    if artist.mbid:\n                        st.caption(f\"mbid: {artist.mbid}\")\n\n                    if st.button(\"‚ûï A√±adir\", key=f\"add_search_{artist.name}_{i}\"):\n                        add_selected(artist, client, limit=5)\n                        st.rerun()\n\n    # -------- SELECCIONADOS --------\n    with col_selected:\n        st.subheader(\"‚úÖ Artistas seleccionados\")\n        if not st.session_state.selected_artists:\n            st.caption(\"Todav√≠a no has seleccionado ning√∫n artista.\")\n        else:\n            for idx, artist in enumerate(st.session_state.selected_artists):\n                with st.container():\n                    cols = st.columns([3, 2])\n                    with cols[0]:\n                        st.markdown(f\"**{artist.name}**\")\n                        if artist.mbid:\n                            st.caption(f\"mbid: {artist.mbid}\")\n                    with cols[1]:\n                        if st.button(\"‚ùå Quitar\", key=f\"remove_sel_{idx}\"):\n                            remove_selected(idx, client, limit=5)\n                            st.rerun()\n\n                    # Bot√≥n para ver discos de estudio\n                    if st.button(\"üìÄ Ver discos de estudio\", key=f\"albums_{idx}\"):\n                        with st.spinner(\"Buscando discos de estudio...\"):\n                            df_albums = mb_dataframe(\n                                artist=artist.name,\n                                artist_mbid=artist.mbid,\n                                discogs_key=DISCOGS_KEY,\n                                discogs_secret=DISCOGS_SECRET,\n                                debug=False,\n                            )\n                        if df_albums.empty:\n                            st.info(\"No se han encontrado √°lbumes de estudio.\")\n                        else:\n                            st.dataframe(df_albums, use_container_width=True)\n\n    # -------- SUGERENCIAS --------\n    with col_suggestions:\n        st.subheader(\"‚ú® Sugerencias (hasta 5)\")\n        suggestions = st.session_state.suggested_artists\n\n        if not st.session_state.selected_artists:\n            st.caption(\"A√±ade al menos un artista para ver sugerencias.\")\n        elif not suggestions:\n            st.caption(\"No hay sugerencias disponibles ahora mismo.\")\n        else:\n            for i, artist in enumerate(suggestions):\n                with st.container():\n                    cols = st.columns([1, 3, 1])\n                    with cols[0]:\n                        if artist.image_url:\n                            st.image(artist.image_url, use_container_width=True)\n                        else:\n                            st.write(\"üéµ\")\n                    with cols[1]:\n                        st.markdown(f\"**{artist.name}**\")\n                        if artist.mbid:\n                            st.caption(f\"mbid: {artist.mbid}\")\n                    with cols[2]:\n                        if st.button(\"‚ûï A√±adir\", key=f\"add_sugg_{artist.name}_{i}\"):\n                            add_selected(artist, client, limit=5)\n                            st.rerun()\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":24710},"services/discogs/discogs_client.py":{"content":"import httpx\nimport asyncio\nimport time\nfrom typing import List, Dict, Optional\nfrom libs.shared.utils import log_event\n\n\nclass DiscogsClient:\n    def __init__(self, key: str, secret: str):\n        self.key = key\n        self.secret = secret\n        self.client: Optional[httpx.AsyncClient] = None\n        self.api_base = \"https://api.discogs.com\"\n        self.last_request_time = 0.0\n        self.min_request_interval = 2.0\n    \n    async def start(self):\n        headers = {\"User-Agent\": \"VinylRecommender/1.0\"}\n        self.client = httpx.AsyncClient(timeout=30.0, headers=headers)\n    \n    async def stop(self):\n        if self.client:\n            await self.client.aclose()\n    \n    def is_ready(self) -> bool:\n        return self.client is not None and bool(self.key) and bool(self.secret)\n    \n    async def _rate_limit(self):\n        \"\"\"Rate limiter: ensure we don't exceed 60 requests per minute\"\"\"\n        current_time = time.time()\n        time_since_last_request = current_time - self.last_request_time\n        \n        if time_since_last_request < self.min_request_interval:\n            wait_time = self.min_request_interval - time_since_last_request\n            await asyncio.sleep(wait_time)\n        \n        self.last_request_time = time.time()\n    \n    def _get_auth_params(self, **params) -> dict:\n        return {\n            **params,\n            \"key\": self.key,\n            \"secret\": self.secret,\n        }\n    \n    def _build_debug_url(self, url: str, params: dict) -> str:\n        \"\"\"Build URL for debugging with credentials hidden\"\"\"\n        debug_params = params.copy()\n        if \"key\" in debug_params:\n            debug_params[\"key\"] = \"[HIDDEN]\"\n        if \"secret\" in debug_params:\n            debug_params[\"secret\"] = \"[HIDDEN]\"\n        \n        query_string = \"&\".join(f\"{k}={v}\" for k, v in debug_params.items())\n        return f\"{url}?{query_string}\"\n    \n    def _normalize_album_title(self, title: str) -> str:\n        \"\"\"\n        Normalize album title by removing common suffixes added by streaming platforms.\n        This improves matching with Discogs database.\n        \n        Examples:\n        - \"Remain in Light (Deluxe Version)\" -> \"Remain in Light\"\n        - \"Dark Side of the Moon (Remastered)\" -> \"Dark Side of the Moon\"\n        \"\"\"\n        import re\n        \n        # Common suffixes to remove (case-insensitive)\n        suffixes = [\n            r'\\s*\\(Deluxe(?:\\s+(?:Edition|Version))?\\)',\n            r'\\s*\\(Remastered(?:\\s+\\d{4})?\\)',\n            r'\\s*\\(Anniversary(?:\\s+Edition)?\\)',\n            r'\\s*\\(Expanded(?:\\s+Edition)?\\)',\n            r'\\s*\\(Special(?:\\s+Edition)?\\)',\n            r'\\s*\\(Limited(?:\\s+Edition)?\\)',\n            r'\\s*\\(\\d+(?:th|st|nd|rd)?\\s+Anniversary(?:\\s+Edition)?\\)',\n            r'\\s*\\(Bonus\\s+Track(?:s)?(?:\\s+Edition)?\\)',\n            r'\\s*\\(Platinum\\s+Edition\\)',\n            r'\\s*\\(Standard\\s+Edition\\)',\n            r'\\s*\\(Explicit\\)',\n            r'\\s*\\[Remastered\\]',\n            r'\\s*-\\s*Remastered(?:\\s+\\d{4})?',\n        ]\n        \n        normalized = title\n        for suffix_pattern in suffixes:\n            normalized = re.sub(suffix_pattern, '', normalized, flags=re.IGNORECASE)\n        \n        # Clean up extra whitespace\n        normalized = ' '.join(normalized.split())\n        \n        return normalized.strip()\n    \n    async def search_release(self, artist: str, title: str) -> List[dict]:\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        await self._rate_limit()\n        \n        params = self._get_auth_params(\n            artist=artist,\n            release_title=title,\n            format=\"Vinyl\",\n            type=\"release\",\n        )\n        \n        url = f\"{self.api_base}/database/search\"\n        \n        debug_url = self._build_debug_url(url, params)\n        \n        try:\n            resp = await self.client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            results = data.get(\"results\", [])\n            \n            # Return both results and debug info\n            return {\n                \"results\": results,\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"params_sent\": {k: v for k, v in params.items() if k not in [\"key\", \"secret\"]}\n                }\n            }\n        except Exception as e:\n            log_event(\"discogs-client\", \"ERROR\", f\"Search failed: {str(e)}\")\n            return {\n                \"results\": [],\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"error\": str(e)\n                }\n            }\n    \n    async def get_marketplace_stats(self, release_id: int, currency: str = \"EUR\") -> dict:\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        await self._rate_limit()\n        \n        # First, get the release details to extract master_id\n        master_id = await self._get_master_id_from_release(release_id)\n        \n        params = self._get_auth_params(currency=currency)\n        url = f\"{self.api_base}/marketplace/stats/{release_id}\"\n        debug_url = self._build_debug_url(url, params)\n        \n        try:\n            resp = await self.client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            \n            # Use master_id in the sell list URL as per user's specification\n            if master_id:\n                sell_list_url = f\"https://www.discogs.com/sell/list?master_id={master_id}&currency=EUR&format=Vinyl\"\n            else:\n                # Fallback to release_id if master_id not found\n                sell_list_url = f\"https://www.discogs.com/sell/list?release_id={release_id}&currency=EUR&format=Vinyl\"\n            \n            lowest_price_data = data.get(\"lowest_price\")\n            \n            if lowest_price_data is None or not isinstance(lowest_price_data, dict):\n                source_price = None\n                source_currency = \"EUR\"\n                price_in_eur = None\n            else:\n                source_price = lowest_price_data.get(\"value\")\n                source_currency = lowest_price_data.get(\"currency\", \"EUR\")\n                \n                if source_price is not None and source_currency != \"EUR\":\n                    price_in_eur = await self.convert_to_eur(source_price, source_currency)\n                    log_event(\"discogs-client\", \"INFO\", f\"Converted {source_price} {source_currency} to {price_in_eur:.2f} EUR\")\n                else:\n                    price_in_eur = source_price\n            \n            return {\n                \"release_id\": release_id,\n                \"lowest_price_eur\": price_in_eur,\n                \"lowest_price\": price_in_eur,\n                \"currency\": \"EUR\",\n                \"original_price\": source_price,\n                \"original_currency\": source_currency,\n                \"num_for_sale\": data.get(\"num_for_sale\", 0),\n                \"sell_list_url\": sell_list_url,\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"params_sent\": {k: v for k, v in params.items() if k not in [\"key\", \"secret\"]}\n                }\n            }\n        except Exception as e:\n            log_event(\"discogs-client\", \"ERROR\", f\"Stats fetch failed for release {release_id}: {str(e)}\")\n            \n            # Use master_id in error case too if available\n            if master_id:\n                sell_list_url = f\"https://www.discogs.com/sell/list?master_id={master_id}&currency=EUR&format=Vinyl\"\n            else:\n                sell_list_url = f\"https://www.discogs.com/sell/list?release_id={release_id}&currency=EUR&format=Vinyl\"\n            \n            return {\n                \"release_id\": release_id,\n                \"lowest_price_eur\": None,\n                \"lowest_price\": None,\n                \"currency\": \"EUR\",\n                \"original_price\": None,\n                \"original_currency\": None,\n                \"num_for_sale\": 0,\n                \"sell_list_url\": sell_list_url,\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"error\": str(e)\n                }\n            }\n    \n    async def _get_master_id_from_release(self, release_id: int) -> Optional[int]:\n        \"\"\"Get the master_id from a release_id by fetching release details\"\"\"\n        if not self.client:\n            return None\n        \n        try:\n            await self._rate_limit()\n            params = self._get_auth_params()\n            url = f\"{self.api_base}/releases/{release_id}\"\n            \n            resp = await self.client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            \n            master_id = data.get(\"master_id\")\n            if master_id:\n                log_event(\"discogs-client\", \"INFO\", f\"Found master_id {master_id} for release {release_id}\")\n            return master_id\n        except Exception as e:\n            log_event(\"discogs-client\", \"WARNING\", f\"Could not get master_id for release {release_id}: {str(e)}\")\n            return None\n    \n    async def convert_to_eur(self, price: float, from_currency: str) -> float:\n        \"\"\"Convert price from source currency to EUR using current exchange rates (Nov 2025)\"\"\"\n        if from_currency == \"EUR\":\n            return price\n        \n        conversion_rates = {\n            \"USD\": 0.865,\n            \"GBP\": 1.140,\n            \"JPY\": 0.00573,\n            \"CAD\": 0.617,\n            \"AUD\": 0.562,\n        }\n        \n        rate = conversion_rates.get(from_currency, 1.0)\n        return price * rate\n    \n    async def get_master_link(self, artist: str, album: str) -> Optional[Dict]:\n        \"\"\"\n        Busca un √°lbum en Discogs con fallback inteligente.\n        \n        Estrategia:\n        1. Normaliza el t√≠tulo (elimina sufijos como \"Deluxe\", \"Remastered\", etc.)\n        2. Busca primero tipo \"master\"\n        3. Si no hay resultados, busca tipo \"release\"\n        4. Retorna el primero que encuentre con su tipo correcto\n        \n        Returns dict con:\n        - type: \"master\" o \"release\"\n        - master_id o release_id\n        - master_url o release_url  \n        \"\"\"\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        # Normalizar el t√≠tulo del √°lbum\n        normalized_album = self._normalize_album_title(album)\n        log_event(\"discogs-client\", \"INFO\", f\"Normalized album title: '{album}' -> '{normalized_album}'\")\n        \n        # Intentar buscar master primero\n        await self._rate_limit()\n        \n        params_master = self._get_auth_params(\n            artist=artist,\n            release_title=normalized_album,\n            type=\"master\",\n        )\n        \n        url = f\"{self.api_base}/database/search\"\n        debug_url_master = self._build_debug_url(url, params_master)\n        \n        try:\n            resp = await self.client.get(url, params=params_master)\n            resp.raise_for_status()\n            data = resp.json()\n            results = data.get(\"results\", [])\n            \n            if results:\n                first_result = results[0]\n                master_id = first_result.get(\"master_id\") or first_result.get(\"id\")\n                \n                if master_id:\n                    master_url = f\"https://www.discogs.com/master/{master_id}\"\n                    log_event(\"discogs-client\", \"INFO\", f\"Found master {master_id} for '{album}'\")\n                    \n                    return {\n                        \"type\": \"master\",\n                        \"id\": master_id,\n                        \"master_id\": master_id,  # backward compatibility\n                        \"url\": master_url,\n                        \"master_url\": master_url,  # backward compatibility\n                        \"title\": first_result.get(\"title\", \"\"),\n                        \"debug_info\": {\n                            \"request_url\": debug_url_master,\n                            \"normalized_title\": normalized_album,\n                            \"search_type\": \"master\"\n                        }\n                    }\n            \n            # No master found, try release as fallback\n            log_event(\"discogs-client\", \"INFO\", f\"No master found for '{album}', trying release fallback\")\n            \n            await self._rate_limit()\n            \n            params_release = self._get_auth_params(\n                artist=artist,\n                release_title=normalized_album,\n                format=\"Vinyl\",\n                type=\"release\",\n            )\n            \n            debug_url_release = self._build_debug_url(url, params_release)\n            \n            resp = await self.client.get(url, params=params_release)\n            resp.raise_for_status()\n            data = resp.json()\n            results = data.get(\"results\", [])\n            \n            if results:\n                first_result = results[0]\n                release_id = first_result.get(\"id\")\n                \n                if release_id:\n                    release_url = f\"https://www.discogs.com/release/{release_id}\"\n                    log_event(\"discogs-client\", \"INFO\", f\"Found release {release_id} for '{album}'\")\n                    \n                    return {\n                        \"type\": \"release\",\n                        \"id\": release_id,\n                        \"release_id\": release_id,\n                        \"url\": release_url,\n                        \"release_url\": release_url,\n                        \"title\": first_result.get(\"title\", \"\"),\n                        \"debug_info\": {\n                            \"request_url\": debug_url_release,\n                            \"normalized_title\": normalized_album,\n                            \"search_type\": \"release (fallback)\"\n                        }\n                    }\n            \n            # Neither master nor release found\n            log_event(\"discogs-client\", \"WARNING\", f\"No master or release found for '{album}'\")\n            return {\n                \"type\": None,\n                \"id\": None,\n                \"url\": None,\n                \"message\": \"No master or release found\",\n                \"debug_info\": {\n                    \"original_title\": album,\n                    \"normalized_title\": normalized_album,\n                    \"searches_attempted\": [\"master\", \"release\"]\n                }\n            }\n            \n        except Exception as e:\n            log_event(\"discogs-client\", \"ERROR\", f\"Master/release link fetch failed: {str(e)}\")\n            return {\n                \"type\": None,\n                \"id\": None,\n                \"url\": None,\n                \"message\": f\"Error: {str(e)}\",\n                \"debug_info\": {\n                    \"original_title\": album,\n                    \"normalized_title\": normalized_album,\n                    \"error\": str(e)\n                }\n            }\n    \n    async def get_master_tracklist(self, master_id: int) -> Optional[Dict]:\n        \"\"\"\n        Obtiene el tracklist de un master ID desde Discogs.\n        \"\"\"\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        await self._rate_limit()\n        \n        params = self._get_auth_params()\n        url = f\"{self.api_base}/masters/{master_id}\"\n        debug_url = self._build_debug_url(url, params)\n        \n        try:\n            resp = await self.client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            \n            tracklist = data.get(\"tracklist\", [])\n            \n            # Formatear el tracklist para devolver solo info relevante\n            formatted_tracklist = []\n            for track in tracklist:\n                formatted_tracklist.append({\n                    \"position\": track.get(\"position\", \"\"),\n                    \"title\": track.get(\"title\", \"\"),\n                    \"duration\": track.get(\"duration\", \"\")\n                })\n            \n            return {\n                \"master_id\": master_id,\n                \"tracklist\": formatted_tracklist,\n                \"title\": data.get(\"title\", \"\"),\n                \"year\": data.get(\"year\"),\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"params_sent\": {k: v for k, v in params.items() if k not in [\"key\", \"secret\"]}\n                }\n            }\n        except Exception as e:\n            log_event(\"discogs-client\", \"ERROR\", f\"Tracklist fetch failed for master {master_id}: {str(e)}\")\n            return {\n                \"master_id\": master_id,\n                \"tracklist\": [],\n                \"message\": f\"Error: {str(e)}\",\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"error\": str(e)\n                }\n            }\n    \n    async def get_release_tracklist(self, release_id: int) -> Optional[Dict]:\n        \"\"\"\n        Obtiene el tracklist de un release ID desde Discogs.\n        Usado como fallback cuando no hay master disponible.\n        \"\"\"\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        await self._rate_limit()\n        \n        params = self._get_auth_params()\n        url = f\"{self.api_base}/releases/{release_id}\"\n        debug_url = self._build_debug_url(url, params)\n        \n        try:\n            resp = await self.client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n            \n            tracklist = data.get(\"tracklist\", [])\n            \n            # Formatear el tracklist igual que en master\n            formatted_tracklist = []\n            for track in tracklist:\n                formatted_tracklist.append({\n                    \"position\": track.get(\"position\", \"\"),\n                    \"title\": track.get(\"title\", \"\"),\n                    \"duration\": track.get(\"duration\", \"\")\n                })\n            \n            return {\n                \"release_id\": release_id,\n                \"tracklist\": formatted_tracklist,\n                \"title\": data.get(\"title\", \"\"),\n                \"year\": data.get(\"year\"),\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"params_sent\": {k: v for k, v in params.items() if k not in [\"key\", \"secret\"]}\n                }\n            }\n        except Exception as e:\n            log_event(\"discogs-client\", \"ERROR\", f\"Tracklist fetch failed for release {release_id}: {str(e)}\")\n            return {\n                \"release_id\": release_id,\n                \"tracklist\": [],\n                \"message\": f\"Error: {str(e)}\",\n                \"debug_info\": {\n                    \"request_url\": debug_url,\n                    \"error\": str(e)\n                }\n            }\n","size_bytes":18758},"services/spotify/main.py":{"content":"from fastapi import FastAPI, Query, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom contextlib import asynccontextmanager\nimport os\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom libs.shared.models import Track, Artist, ServiceHealth, LogEvent\nfrom libs.shared.utils import create_http_client, log_event\nfrom .auth import SpotifyAuthManager\nfrom .spotify_client import SpotifyClient\n\nauth_manager = SpotifyAuthManager()\nspotify_client = None\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    global spotify_client\n    spotify_client = SpotifyClient(auth_manager)\n    await spotify_client.start()\n    log_event(\"spotify-service\", \"INFO\", \"Spotify Service started\")\n    yield\n    await spotify_client.stop()\n    log_event(\"spotify-service\", \"INFO\", \"Spotify Service stopped\")\n\n\napp = FastAPI(lifespan=lifespan, title=\"Spotify Service\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    return ServiceHealth(\n        service_name=\"spotify-service\",\n        status=\"healthy\" if spotify_client and spotify_client.is_ready() else \"unhealthy\"\n    ).dict()\n\n\n@app.get(\"/auth/login\")\nasync def spotify_login():\n    log_event(\"spotify-service\", \"INFO\", \"Login request received\")\n    auth_url = auth_manager.get_auth_url()\n    return {\"authorize_url\": auth_url}\n\n\n@app.get(\"/auth/callback\")\nasync def spotify_callback(code: str = Query(...)):\n    log_event(\"spotify-service\", \"INFO\", \"Callback received\", {\"code_length\": len(code)})\n    success = await auth_manager.exchange_code_for_token(code)\n    if not success:\n        raise HTTPException(status_code=400, detail=\"Failed to exchange code for token\")\n    log_event(\"spotify-service\", \"INFO\", \"Authentication successful\")\n    return {\"status\": \"ok\", \"message\": \"Authenticated successfully\"}\n\n\n@app.get(\"/me\")\nasync def get_user_profile():\n    if not spotify_client:\n        raise HTTPException(status_code=500, detail=\"Spotify client not initialized\")\n    \n    profile = await spotify_client.get_user_profile()\n    log_event(\"spotify-service\", \"INFO\", \"User profile retrieved\", {\"user_id\": profile.get(\"id\")})\n    return profile\n\n\n@app.get(\"/top-tracks\")\nasync def get_all_top_tracks():\n    if not spotify_client:\n        raise HTTPException(status_code=500, detail=\"Spotify client not initialized\")\n    \n    log_event(\"spotify-service\", \"INFO\", \"Starting to fetch 300 top tracks across all time ranges\")\n    \n    all_tracks = []\n    time_ranges = [\"short_term\", \"medium_term\", \"long_term\"]\n    \n    for time_range in time_ranges:\n        log_event(\"spotify-service\", \"INFO\", f\"Fetching tracks for {time_range}\")\n        tracks = await spotify_client.get_top_tracks(time_range=time_range, limit=300)\n        all_tracks.extend([{**track, \"time_range\": time_range} for track in tracks])\n        log_event(\"spotify-service\", \"INFO\", f\"Fetched {len(tracks)} tracks for {time_range}\")\n    \n    log_event(\"spotify-service\", \"INFO\", f\"Total tracks fetched: {len(all_tracks)}\")\n    return {\"tracks\": all_tracks, \"total\": len(all_tracks)}\n\n\n@app.get(\"/top-artists\")\nasync def get_all_top_artists():\n    if not spotify_client:\n        raise HTTPException(status_code=500, detail=\"Spotify client not initialized\")\n    \n    log_event(\"spotify-service\", \"INFO\", \"Starting to fetch 300 top artists (long_term)\")\n    \n    artists = await spotify_client.get_top_artists(time_range=\"long_term\", limit=300)\n    \n    log_event(\"spotify-service\", \"INFO\", f\"Total artists fetched: {len(artists)}\")\n    return {\"artists\": artists, \"total\": len(artists)}\n\n\n@app.get(\"/album/{album_id}\")\nasync def get_album(album_id: str):\n    if not spotify_client:\n        raise HTTPException(status_code=500, detail=\"Spotify client not initialized\")\n    \n    album = await spotify_client.get_album(album_id)\n    log_event(\"spotify-service\", \"INFO\", f\"Album retrieved: {album.get('name')}\")\n    return album\n","size_bytes":4093},"services/pricing/__init__.py":{"content":"","size_bytes":0},"services/pricing/main.py":{"content":"from fastapi import FastAPI, HTTPException, Path\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\nimport os\nimport sys\nfrom pathlib import Path as PathLib\n\nsys.path.insert(0, str(PathLib(__file__).parent.parent.parent))\n\nfrom libs.shared.models import ServiceHealth\nfrom libs.shared.utils import log_event\nfrom .pricing_client import PricingClient\n\npricing_client = None\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    global pricing_client\n    pricing_client = PricingClient()\n    await pricing_client.start()\n    log_event(\"pricing-service\", \"INFO\", \"Pricing Service started\")\n    yield\n    await pricing_client.stop()\n    log_event(\"pricing-service\", \"INFO\", \"Pricing Service stopped\")\n\n\napp = FastAPI(lifespan=lifespan, title=\"Pricing Service\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    return ServiceHealth(\n        service_name=\"pricing-service\",\n        status=\"healthy\" if pricing_client and pricing_client.is_ready() else \"unhealthy\"\n    ).dict()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"service\": \"pricing-service\", \"status\": \"running\"}\n\n\n@app.get(\"/ebay-price/{artist}/{album}\")\nasync def get_ebay_price(\n    artist: str = Path(..., description=\"Artist name\"),\n    album: str = Path(..., description=\"Album name\")\n):\n    \"\"\"\n    Obtiene el mejor precio de eBay para un vinilo espec√≠fico.\n    \"\"\"\n    if not pricing_client:\n        raise HTTPException(status_code=500, detail=\"Pricing client not initialized\")\n    \n    log_event(\"pricing-service\", \"INFO\", f\"Fetching eBay price for {artist} - {album}\")\n    \n    try:\n        result = await pricing_client.fetch_best_ebay_offer(artist, album)\n        \n        if not result:\n            log_event(\"pricing-service\", \"INFO\", f\"No eBay offer found for {artist} - {album}\")\n            return {\n                \"artist\": artist,\n                \"album\": album,\n                \"offer\": None,\n                \"message\": \"No suitable offer found on eBay\"\n            }\n        \n        log_event(\n            \"pricing-service\",\n            \"INFO\",\n            f\"eBay offer found for {artist} - {album}\",\n            {\"price\": result[\"total_price\"]}\n        )\n        \n        return {\n            \"artist\": artist,\n            \"album\": album,\n            \"offer\": result\n        }\n    except Exception as e:\n        log_event(\"pricing-service\", \"ERROR\", f\"Error fetching eBay price: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Error fetching eBay price: {str(e)}\")\n\n\n@app.get(\"/local-stores/{artist}/{album}\")\nasync def get_local_stores(\n    artist: str = Path(..., description=\"Artist name\"),\n    album: str = Path(..., description=\"Album name\")\n):\n    \"\"\"\n    Devuelve enlaces a tiendas locales de vinilos en Espa√±a.\n    \"\"\"\n    if not pricing_client:\n        raise HTTPException(status_code=500, detail=\"Pricing client not initialized\")\n    \n    log_event(\"pricing-service\", \"INFO\", f\"Generating local store links for {artist} - {album}\")\n    \n    links = pricing_client.get_local_store_links(artist, album)\n    \n    return {\n        \"artist\": artist,\n        \"album\": album,\n        \"stores\": links\n    }\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    port = int(os.getenv(\"PRICING_SERVICE_PORT\", 3003))\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\n","size_bytes":3458},"services/recommender/album_aggregator.py":{"content":"from typing import List, Dict, Set, Any\nfrom collections import defaultdict\nfrom libs.shared.utils import log_event\n\n\nclass AlbumData:\n    def __init__(self):\n        self.tracks: List[dict] = []\n        self.total_score: float = 0\n        self.artists: Set[str] = set()\n        self.album_info: dict | None = None\n        self.score_by_period: Dict[str, float] = {\"short_term\": 0, \"medium_term\": 0, \"long_term\": 0}\n        self.tracks_by_period: Dict[str, int] = {\"short_term\": 0, \"medium_term\": 0, \"long_term\": 0}\n\n\nclass AlbumAggregator:\n    def __init__(self):\n        self.favorite_artist_boost = 5.0\n    \n    def aggregate_albums(self, scored_tracks: List[dict], scored_artists: List[dict]) -> List[dict]:\n        log_event(\"album-aggregator\", \"INFO\", \"Starting album aggregation\")\n        \n        artist_scores = {artist.get(\"id\") or artist.get(\"name\"): artist[\"score\"] for artist in scored_artists}\n        \n        album_data: Dict[str, AlbumData] = {}\n        \n        for track in scored_tracks:\n            album_id = track.get(\"album\", {}).get(\"id\")\n            if not album_id:\n                continue\n            \n            if album_id not in album_data:\n                album_data[album_id] = AlbumData()\n            \n            track_score = track.get(\"score\", 0)\n            time_range = track.get(\"time_range\", \"unknown\")\n            \n            album_data[album_id].tracks.append(track)\n            album_data[album_id].total_score += track_score\n            \n            if time_range in album_data[album_id].score_by_period:\n                album_data[album_id].score_by_period[time_range] += track_score\n                album_data[album_id].tracks_by_period[time_range] += 1\n            \n            album_artists = track.get(\"album\", {}).get(\"artists\", [])\n            for artist in album_artists:\n                artist_id = artist.get(\"id\") or artist.get(\"name\")\n                if artist_id:\n                    album_data[album_id].artists.add(artist_id)\n            \n            if album_data[album_id].album_info is None:\n                album_data[album_id].album_info = track.get(\"album\", {})\n        \n        log_event(\"album-aggregator\", \"INFO\", f\"Found {len(album_data)} unique albums\")\n        \n        filtered_albums = []\n        for album_id, data in album_data.items():\n            track_count = len(data.tracks)\n            \n            if track_count < 5:\n                continue\n            \n            artist_boost = any(artist_id in artist_scores for artist_id in data.artists)\n            \n            base_score = data.total_score\n            final_score = base_score\n            if artist_boost:\n                final_score *= self.favorite_artist_boost\n                log_event(\"album-aggregator\", \"INFO\", f\"Applied artist boost to album {album_id}\")\n            \n            album_recommendation = {\n                \"album_id\": album_id,\n                \"album_info\": data.album_info,\n                \"track_count\": track_count,\n                \"score\": final_score,\n                \"artist_boost\": artist_boost,\n                \"score_breakdown\": {\n                    \"base_score\": round(base_score, 2),\n                    \"artist_boost_applied\": artist_boost,\n                    \"artist_boost_multiplier\": self.favorite_artist_boost if artist_boost else 1.0,\n                    \"final_score\": round(final_score, 2),\n                    \"score_by_period\": {\n                        \"short_term\": round(data.score_by_period[\"short_term\"], 2),\n                        \"medium_term\": round(data.score_by_period[\"medium_term\"], 2),\n                        \"long_term\": round(data.score_by_period[\"long_term\"], 2),\n                    },\n                    \"tracks_by_period\": data.tracks_by_period,\n                },\n            }\n            filtered_albums.append(album_recommendation)\n        \n        log_event(\"album-aggregator\", \"INFO\", f\"Filtered to {len(filtered_albums)} albums (>= 5 tracks)\")\n        \n        filtered_albums.sort(key=lambda x: x[\"score\"], reverse=True)\n        \n        log_event(\"album-aggregator\", \"INFO\", \"Albums sorted by score\")\n        \n        return filtered_albums\n","size_bytes":4164},"services/recommender/main.py":{"content":"from fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\nimport sys\nimport os\nfrom pathlib import Path\nfrom typing import List\nfrom pydantic import BaseModel\n\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom libs.shared.models import ServiceHealth\nfrom libs.shared.utils import log_event\nfrom .scoring_engine import ScoringEngine\nfrom .album_aggregator import AlbumAggregator\nfrom .artist_recommendations import get_artist_based_recommendations, get_artist_studio_albums\n\nscoring_engine = None\nalbum_aggregator = None\n\nprogress_state = {\n    \"current\": 0,\n    \"total\": 0,\n    \"status\": \"idle\",\n    \"current_artist\": \"\"\n}\n\n\nclass ArtistRecommendationRequest(BaseModel):\n    artist_names: List[str]\n    top_per_artist: int = 3\n\n\nclass MergeRecommendationsRequest(BaseModel):\n    spotify_recommendations: List[dict]\n    artist_recommendations: List[dict]\n    lastfm_recommendations: List[dict] = []\n\n\nclass SingleArtistRequest(BaseModel):\n    artist_name: str\n    top_albums: int = 3\n    csv_mode: bool = False\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    global scoring_engine, album_aggregator\n    scoring_engine = ScoringEngine()\n    album_aggregator = AlbumAggregator()\n    log_event(\"recommender-service\", \"INFO\", \"Recommendation Service started\")\n    yield\n    log_event(\"recommender-service\", \"INFO\", \"Recommendation Service stopped\")\n\n\napp = FastAPI(lifespan=lifespan, title=\"Recommendation Service\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    return ServiceHealth(\n        service_name=\"recommender-service\",\n        status=\"healthy\"\n    ).dict()\n\n\n@app.post(\"/lastfm-albums-recommendations\")\nasync def lastfm_albums_recommendations(albums: List[dict]):\n    \"\"\"Simplified: user.gettopalbums ‚Üí cache-first ‚Üí fetch covers on-demand\"\"\"\n    import time\n    import asyncio\n    import httpx\n    from concurrent.futures import ThreadPoolExecutor\n    from . import db_utils\n    \n    start_time = time.time()\n    log_event(\"recommender-service\", \"INFO\", f\"Processing {len(albums)} Last.fm albums\")\n    \n    all_recommendations = []\n    cache_hits = 0\n    cache_misses = 0\n    covers_fetched = 0\n    \n    def fetch_from_db(artist_name, album_name):\n        \"\"\"Run DB lookup in thread pool to avoid blocking\"\"\"\n        return db_utils.get_cached_album(artist_name, album_name)\n    \n    async with httpx.AsyncClient(timeout=5.0) as client:\n        with ThreadPoolExecutor(max_workers=3) as executor:\n            loop = asyncio.get_event_loop()\n            \n            for album_data in albums[:50]:\n                try:\n                    album_name = album_data.get(\"name\", \"\").strip()\n                    artist_data = album_data.get(\"artist\", {})\n                    \n                    if isinstance(artist_data, str):\n                        artist_name = artist_data.strip()\n                    else:\n                        artist_name = artist_data.get(\"name\", \"\").strip()\n                    \n                    playcount = int(album_data.get(\"playcount\", 0))\n                    \n                    if not album_name or not artist_name:\n                        continue\n                    \n                    cached_album = await loop.run_in_executor(\n                        executor, fetch_from_db, artist_name, album_name\n                    )\n                    \n                    if cached_album:\n                        cache_hits += 1\n                        all_recommendations.append({\n                            \"artist_name\": artist_name,\n                            \"album_name\": cached_album[\"title\"],\n                            \"year\": cached_album.get(\"year\"),\n                            \"discogs_master_id\": cached_album.get(\"discogs_master_id\"),\n                            \"discogs_release_id\": cached_album.get(\"discogs_release_id\"),\n                            \"rating\": cached_album.get(\"rating\"),\n                            \"votes\": cached_album.get(\"votes\"),\n                            \"cover_url\": cached_album.get(\"cover_url\"),\n                            \"lastfm_playcount\": playcount,\n                            \"source\": \"lastfm\"\n                        })\n                    else:\n                        cache_misses += 1\n                        \n                        cover_url = None\n                        try:\n                            resp = await client.get(\n                                f\"http://localhost:3001/search-album\",\n                                params={\"artist\": artist_name, \"album\": album_name}\n                            )\n                            if resp.status_code == 200:\n                                data = resp.json()\n                                cover_url = data.get(\"cover_url\")\n                                if cover_url:\n                                    covers_fetched += 1\n                                    log_event(\"recommender-service\", \"DEBUG\", \n                                             f\"‚úì Cover fetched: {artist_name} - {album_name}\")\n                        except Exception as e:\n                            log_event(\"recommender-service\", \"WARNING\", \n                                     f\"Cover fetch failed: {artist_name} - {album_name}: {str(e)}\")\n                        \n                        await loop.run_in_executor(\n                            executor, db_utils.create_basic_album_entry,\n                            artist_name, album_name, cover_url\n                        )\n                        \n                        all_recommendations.append({\n                            \"artist_name\": artist_name,\n                            \"album_name\": album_name,\n                            \"year\": None,\n                            \"discogs_master_id\": None,\n                            \"discogs_release_id\": None,\n                            \"rating\": None,\n                            \"votes\": None,\n                            \"cover_url\": cover_url,\n                            \"lastfm_playcount\": playcount,\n                            \"source\": \"lastfm\"\n                        })\n                        \n                except Exception as e:\n                    log_event(\"recommender-service\", \"ERROR\", \n                             f\"Album error: {str(e)}\")\n                    continue\n    \n    end_time = time.time()\n    total_time = end_time - start_time\n    \n    log_event(\"recommender-service\", \"INFO\", \n              f\"‚úì {len(all_recommendations)} albums processed in {total_time:.2f}s \"\n              f\"(hits: {cache_hits}, new: {cache_misses}, covers: {covers_fetched})\")\n    \n    return {\n        \"albums\": all_recommendations,\n        \"total\": len(all_recommendations),\n        \"stats\": {\n            \"cache_hits\": cache_hits,\n            \"cache_misses\": cache_misses,\n            \"covers_fetched\": covers_fetched,\n            \"albums_processed\": len(albums[:50]),\n            \"total_time_seconds\": round(total_time, 2)\n        }\n    }\n\n\n@app.post(\"/lastfm-recommendations\")\nasync def lastfm_recommendations(artists: List[dict]):\n    \"\"\"\n    LEGACY: Generate album recommendations from Last.fm artists using PostgreSQL cache\n    Input: [{\"name\": \"Artist Name\", \"score\": 250.5, \"playcount\": 1234}, ...]\n    \"\"\"\n    import time\n    from . import artist_recommendations\n    start_time = time.time()\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Generating Last.fm recommendations for {len(artists)} artists\")\n    \n    all_albums = []\n    cache_hits = 0\n    cache_misses = 0\n    \n    for artist in artists[:50]:\n        artist_name = artist.get(\"name\")\n        lastfm_score = artist.get(\"score\", 0)\n        lastfm_playcount = artist.get(\"playcount\", 0)\n        \n        if not artist_name:\n            continue\n        \n        cached_albums = artist_recommendations._get_cached_artist_albums(artist_name)\n        \n        if cached_albums:\n            cache_hits += 1\n            for album in cached_albums[:2]:\n                all_albums.append({\n                    \"artist_name\": artist_name,\n                    \"album_name\": album.get(\"title\"),\n                    \"year\": album.get(\"year\"),\n                    \"discogs_master_id\": album.get(\"discogs_master_id\"),\n                    \"discogs_release_id\": album.get(\"discogs_release_id\"),\n                    \"rating\": album.get(\"rating\"),\n                    \"votes\": album.get(\"votes\"),\n                    \"cover_url\": album.get(\"cover_url\"),\n                    \"lastfm_score\": lastfm_score,\n                    \"lastfm_playcount\": lastfm_playcount,\n                    \"source\": \"lastfm\"\n                })\n        else:\n            cache_misses += 1\n    \n    end_time = time.time()\n    total_time = end_time - start_time\n    \n    log_event(\"recommender-service\", \"INFO\", \n              f\"Generated {len(all_albums)} Last.fm recommendations in {total_time:.2f}s \"\n              f\"(cache hits: {cache_hits}, misses: {cache_misses})\")\n    \n    return {\n        \"albums\": all_albums,\n        \"total\": len(all_albums),\n        \"stats\": {\n            \"cache_hits\": cache_hits,\n            \"cache_misses\": cache_misses,\n            \"artists_processed\": len(artists[:50]),\n            \"total_time_seconds\": round(total_time, 2)\n        }\n    }\n\n\n@app.post(\"/score-tracks\")\nasync def score_tracks(tracks: List[dict]):\n    import time\n    start_time = time.time()\n    \n    if not scoring_engine:\n        raise HTTPException(status_code=500, detail=\"Scoring engine not initialized\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Scoring {len(tracks)} tracks\")\n    \n    scored_tracks = scoring_engine.score_tracks(tracks)\n    \n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", f\"Scored {len(scored_tracks)} tracks in {elapsed:.2f}s\")\n    return {\"scored_tracks\": scored_tracks, \"total\": len(scored_tracks)}\n\n\n@app.post(\"/score-artists\")\nasync def score_artists(artists: List[dict]):\n    import time\n    start_time = time.time()\n    \n    if not scoring_engine:\n        raise HTTPException(status_code=500, detail=\"Scoring engine not initialized\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Scoring {len(artists)} artists\")\n    \n    scored_artists = scoring_engine.score_artists(artists)\n    \n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", f\"Scored {len(scored_artists)} artists in {elapsed:.2f}s\")\n    return {\"scored_artists\": scored_artists, \"total\": len(scored_artists)}\n\n\n@app.post(\"/score-lastfm-tracks\")\nasync def score_lastfm_tracks(tracks: List[dict]):\n    import time\n    start_time = time.time()\n    \n    if not scoring_engine:\n        raise HTTPException(status_code=500, detail=\"Scoring engine not initialized\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Scoring {len(tracks)} Last.fm tracks\")\n    \n    scored_tracks = scoring_engine.score_lastfm_tracks(tracks)\n    \n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", f\"Scored {len(scored_tracks)} Last.fm tracks in {elapsed:.2f}s\")\n    return {\"scored_tracks\": scored_tracks, \"total\": len(scored_tracks)}\n\n\n@app.post(\"/score-lastfm-artists\")\nasync def score_lastfm_artists(artists: List[dict]):\n    import time\n    start_time = time.time()\n    \n    if not scoring_engine:\n        raise HTTPException(status_code=500, detail=\"Scoring engine not initialized\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Scoring {len(artists)} Last.fm artists\")\n    \n    scored_artists = scoring_engine.score_lastfm_artists(artists)\n    \n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", f\"Scored {len(scored_artists)} Last.fm artists in {elapsed:.2f}s\")\n    return {\"scored_artists\": scored_artists, \"total\": len(scored_artists)}\n\n\n@app.post(\"/aggregate-albums\")\nasync def aggregate_albums(scored_tracks: List[dict], scored_artists: List[dict]):\n    import time\n    start_time = time.time()\n    \n    if not album_aggregator:\n        raise HTTPException(status_code=500, detail=\"Album aggregator not initialized\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Aggregating albums from {len(scored_tracks)} tracks\")\n    \n    albums = album_aggregator.aggregate_albums(scored_tracks, scored_artists)\n    \n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", f\"Generated {len(albums)} album recommendations in {elapsed:.2f}s\")\n    return {\"albums\": albums, \"total\": len(albums)}\n\n\n@app.get(\"/progress\")\nasync def get_progress():\n    return progress_state\n\n\n@app.post(\"/artist-recommendations\")\nasync def artist_recommendations(request: ArtistRecommendationRequest):\n    import time\n    start_time = time.time()\n    global progress_state\n    \n    discogs_key = os.getenv(\"DISCOGS_KEY\")\n    discogs_secret = os.getenv(\"DISCOGS_SECRET\")\n    \n    if not discogs_key or not discogs_secret:\n        raise HTTPException(status_code=500, detail=\"Discogs credentials not configured\")\n    \n    if len(request.artist_names) < 3:\n        raise HTTPException(status_code=400, detail=\"Minimum 3 artists required\")\n    \n    if len(request.artist_names) > 10:\n        raise HTTPException(status_code=400, detail=\"Maximum 10 artists allowed\")\n    \n    progress_state = {\n        \"current\": 0,\n        \"total\": len(request.artist_names),\n        \"status\": \"processing\",\n        \"current_artist\": \"\"\n    }\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Generating recommendations for {len(request.artist_names)} artists\")\n    \n    def update_progress(current: int, artist_name: str):\n        global progress_state\n        progress_state[\"current\"] = current\n        progress_state[\"current_artist\"] = artist_name\n    \n    try:\n        recommendations = get_artist_based_recommendations(\n            request.artist_names,\n            discogs_key,\n            discogs_secret,\n            top_per_artist=request.top_per_artist,\n            progress_callback=update_progress\n        )\n        \n        progress_state[\"status\"] = \"completed\"\n        \n        elapsed = time.time() - start_time\n        log_event(\"recommender-service\", \"INFO\", f\"Generated {len(recommendations)} artist-based recommendations in {elapsed:.2f}s\")\n        return {\"recommendations\": recommendations, \"total\": len(recommendations)}\n    except Exception as e:\n        progress_state[\"status\"] = \"error\"\n        raise e\n\n\n@app.post(\"/merge-recommendations\")\nasync def merge_recommendations(request: MergeRecommendationsRequest):\n    import time\n    start_time = time.time()\n    \n    spotify_recs = request.spotify_recommendations\n    artist_recs = request.artist_recommendations\n    lastfm_recs = request.lastfm_recommendations\n    \n    log_event(\"recommender-service\", \"INFO\", \n              f\"Merging {len(spotify_recs)} Spotify + {len(artist_recs)} artist + {len(lastfm_recs)} Last.fm recommendations\")\n    \n    seen_albums = set()\n    merged: List[dict] = []\n    max_len = max(len(spotify_recs), len(artist_recs), len(lastfm_recs))\n    \n    def get_album_keys(rec: dict) -> list:\n        \"\"\"Returns all possible keys for this album to handle metadata variations\"\"\"\n        keys = []\n        \n        if \"album_info\" in rec:\n            album_info = rec.get(\"album_info\", {})\n            album = album_info.get(\"name\", \"\").lower().strip()\n            artists_list = album_info.get(\"artists\", [])\n            artist = artists_list[0].get(\"name\", \"\") if artists_list else \"\"\n            artist = artist.lower().strip()\n        else:\n            album = rec.get(\"album_name\", \"\").lower().strip()\n            artist = rec.get(\"artist_name\", \"\").lower().strip()\n        \n        fallback_key = f\"{artist}::{album}\"\n        keys.append(fallback_key)\n        \n        discogs_master = rec.get(\"discogs_master_id\")\n        if discogs_master:\n            keys.append(f\"master::{discogs_master}\")\n        \n        return keys\n    \n    def is_duplicate(rec: dict) -> bool:\n        \"\"\"Check if album is already seen using any of its keys\"\"\"\n        rec_keys = get_album_keys(rec)\n        return any(key in seen_albums for key in rec_keys)\n    \n    def mark_as_seen(rec: dict):\n        \"\"\"Mark all keys for this album as seen\"\"\"\n        rec_keys = get_album_keys(rec)\n        for key in rec_keys:\n            seen_albums.add(key)\n    \n    for i in range(max_len):\n        if i < len(spotify_recs):\n            if not is_duplicate(spotify_recs[i]):\n                mark_as_seen(spotify_recs[i])\n                merged.append(spotify_recs[i])\n        \n        if i < len(lastfm_recs):\n            if not is_duplicate(lastfm_recs[i]):\n                mark_as_seen(lastfm_recs[i])\n                merged.append(lastfm_recs[i])\n        \n        if i < len(artist_recs):\n            if not is_duplicate(artist_recs[i]):\n                mark_as_seen(artist_recs[i])\n                merged.append(artist_recs[i])\n    \n    duplicates_removed = (len(spotify_recs) + len(artist_recs) + len(lastfm_recs)) - len(merged)\n    elapsed = time.time() - start_time\n    log_event(\"recommender-service\", \"INFO\", \n              f\"Merged into {len(merged)} total recommendations ({duplicates_removed} duplicates removed) in {elapsed:.2f}s\")\n    return {\"recommendations\": merged, \"total\": len(merged)}\n\n\n@app.post(\"/artist-single-recommendation\")\nasync def artist_single_recommendation(request: SingleArtistRequest):\n    import time\n    start_time = time.time()\n    \n    discogs_key = os.getenv(\"DISCOGS_KEY\")\n    discogs_secret = os.getenv(\"DISCOGS_SECRET\")\n    \n    if not discogs_key or not discogs_secret:\n        raise HTTPException(status_code=500, detail=\"Discogs credentials not configured\")\n    \n    log_event(\"recommender-service\", \"INFO\", f\"Generating recommendations for artist: {request.artist_name}\")\n    \n    try:\n        albums = get_artist_studio_albums(\n            request.artist_name,\n            discogs_key,\n            discogs_secret,\n            top_n=request.top_albums,\n            csv_mode=request.csv_mode\n        )\n        \n        recommendations = []\n        for album in albums:\n            rec = {\n                \"album_name\": album.title,\n                \"artist_name\": album.artist_name,\n                \"year\": album.year,\n                \"rating\": album.rating,\n                \"votes\": album.votes,\n                \"discogs_master_id\": album.discogs_master_id or album.discogs_release_id,\n                \"discogs_type\": album.discogs_type,\n                \"image_url\": album.cover_image or \"https://via.placeholder.com/300x300?text=No+Cover\",\n                \"source\": \"artist_based\"\n            }\n            recommendations.append(rec)\n        \n        elapsed = time.time() - start_time\n        log_event(\"recommender-service\", \"INFO\", \n                 f\"Generated {len(recommendations)} recommendations for {request.artist_name} in {elapsed:.2f}s\")\n        return {\"recommendations\": recommendations, \"total\": len(recommendations), \"artist_name\": request.artist_name}\n    except Exception as e:\n        log_event(\"recommender-service\", \"ERROR\", f\"Failed to generate recommendations for {request.artist_name}: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Failed to generate recommendations: {str(e)}\")\n","size_bytes":19327},"services/recommender/scoring_engine.py":{"content":"from typing import List, Dict\nfrom libs.shared.utils import log_event\n\n\nclass ScoringEngine:\n    def __init__(self):\n        self.time_range_boosts = {\n            \"short_term\": 3.0,\n            \"medium_term\": 2.0,\n            \"long_term\": 1.0,\n        }\n    \n    def score_tracks(self, tracks: List[dict]) -> List[dict]:\n        scored_tracks = []\n        \n        for idx, track in enumerate(tracks):\n            time_range = track.get(\"time_range\", \"medium_term\")\n            boost = self.time_range_boosts.get(time_range, 1.0)\n            \n            position_score = 300 - (idx % 300)\n            \n            total_score = position_score * boost\n            \n            scored_track = {\n                **track,\n                \"position\": idx % 300,\n                \"score\": total_score,\n            }\n            scored_tracks.append(scored_track)\n        \n        return scored_tracks\n    \n    def score_artists(self, artists: List[dict]) -> List[dict]:\n        scored_artists = []\n        \n        for idx, artist in enumerate(artists):\n            position_score = 300 - idx\n            \n            scored_artist = {\n                **artist,\n                \"position\": idx,\n                \"score\": position_score,\n            }\n            scored_artists.append(scored_artist)\n        \n        return scored_artists\n    \n    def score_lastfm_tracks(self, tracks: List[dict]) -> List[dict]:\n        \"\"\"\n        Score Last.fm tracks using playcount instead of position\n        Last.fm tracks have: playcount, time_range (mapped from period)\n        \"\"\"\n        scored_tracks = []\n        \n        if not tracks:\n            return scored_tracks\n        \n        max_playcount = max((int(t.get(\"playcount\", 0)) for t in tracks), default=1)\n        \n        for idx, track in enumerate(tracks):\n            time_range = track.get(\"time_range\", \"medium_term\")\n            boost = self.time_range_boosts.get(time_range, 1.0)\n            \n            playcount = int(track.get(\"playcount\", 0))\n            playcount_score = (playcount / max_playcount) * 300 if max_playcount > 0 else 0\n            \n            total_score = playcount_score * boost\n            \n            scored_track = {\n                **track,\n                \"position\": idx,\n                \"score\": total_score,\n                \"playcount\": playcount,\n                \"source\": \"lastfm\"\n            }\n            scored_tracks.append(scored_track)\n        \n        return scored_tracks\n    \n    def score_lastfm_artists(self, artists: List[dict]) -> List[dict]:\n        \"\"\"\n        Score Last.fm artists using playcount\n        \"\"\"\n        scored_artists = []\n        \n        if not artists:\n            return scored_artists\n        \n        max_playcount = max((int(a.get(\"playcount\", 0)) for a in artists), default=1)\n        \n        for idx, artist in enumerate(artists):\n            playcount = int(artist.get(\"playcount\", 0))\n            playcount_score = (playcount / max_playcount) * 300 if max_playcount > 0 else 0\n            \n            scored_artist = {\n                **artist,\n                \"position\": idx,\n                \"score\": playcount_score,\n                \"playcount\": playcount,\n                \"source\": \"lastfm\"\n            }\n            scored_artists.append(scored_artist)\n        \n        return scored_artists\n","size_bytes":3332},"services/spotify/auth.py":{"content":"import os\nimport base64\nfrom urllib.parse import urlencode\nimport httpx\nfrom typing import Optional\n\n\nclass SpotifyAuthManager:\n    def __init__(self):\n        self.client_id = os.getenv(\"SPOTIFY_CLIENT_ID\")\n        self.client_secret = os.getenv(\"SPOTIFY_CLIENT_SECRET\")\n        self.redirect_uri = os.getenv(\"SPOTIFY_REDIRECT_URI\")\n        self.auth_url = \"https://accounts.spotify.com/authorize\"\n        self.token_url = \"https://accounts.spotify.com/api/token\"\n        self.tokens = {}\n    \n    def get_auth_url(self) -> str:\n        if not all([self.client_id, self.client_secret, self.redirect_uri]):\n            raise ValueError(\"Missing Spotify credentials\")\n        \n        scopes = [\"user-top-read\", \"user-read-email\"]\n        params = {\n            \"client_id\": self.client_id,\n            \"response_type\": \"code\",\n            \"redirect_uri\": self.redirect_uri,\n            \"scope\": \" \".join(scopes),\n            \"show_dialog\": \"true\"\n        }\n        return f\"{self.auth_url}?{urlencode(params)}\"\n    \n    def _get_basic_auth_header(self) -> dict:\n        creds = f\"{self.client_id}:{self.client_secret}\".encode()\n        encoded = base64.b64encode(creds).decode()\n        return {\"Authorization\": f\"Basic {encoded}\"}\n    \n    async def exchange_code_for_token(self, code: str) -> bool:\n        data = {\n            \"grant_type\": \"authorization_code\",\n            \"code\": code,\n            \"redirect_uri\": self.redirect_uri,\n        }\n        headers = self._get_basic_auth_header()\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        \n        async with httpx.AsyncClient() as client:\n            resp = await client.post(self.token_url, data=data, headers=headers)\n            if resp.status_code != 200:\n                return False\n            \n            tokens = resp.json()\n            self.tokens[\"access_token\"] = tokens.get(\"access_token\")\n            self.tokens[\"refresh_token\"] = tokens.get(\"refresh_token\")\n            return True\n    \n    async def refresh_access_token(self) -> bool:\n        if not self.tokens.get(\"refresh_token\"):\n            return False\n        \n        data = {\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": self.tokens[\"refresh_token\"],\n        }\n        headers = self._get_basic_auth_header()\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        \n        async with httpx.AsyncClient() as client:\n            resp = await client.post(self.token_url, data=data, headers=headers)\n            if resp.status_code != 200:\n                return False\n            \n            tokens = resp.json()\n            self.tokens[\"access_token\"] = tokens.get(\"access_token\")\n            if \"refresh_token\" in tokens:\n                self.tokens[\"refresh_token\"] = tokens[\"refresh_token\"]\n            return True\n    \n    def get_access_token(self) -> Optional[str]:\n        return self.tokens.get(\"access_token\")\n    \n    def is_authenticated(self) -> bool:\n        return bool(self.tokens.get(\"access_token\"))\n","size_bytes":3031},"services/spotify/__init__.py":{"content":"# Spotify Service\n","size_bytes":18},"gateway/main.py":{"content":"from fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse, RedirectResponse, StreamingResponse\nfrom contextlib import asynccontextmanager\nimport os\nimport sys\nfrom pathlib import Path\nimport httpx\nimport asyncio\nimport time\nimport csv\nimport json\nfrom typing import AsyncGenerator\n\nsys.path.insert(0, str(Path(__file__).parent.parent))\n\nfrom libs.shared.models import ServiceHealth\nfrom libs.shared.utils import log_event\n\nSPOTIFY_SERVICE_URL = os.getenv(\"SPOTIFY_SERVICE_URL\", \"http://localhost:3000\")\nDISCOGS_SERVICE_URL = os.getenv(\"DISCOGS_SERVICE_URL\", \"http://localhost:3001\")\nRECOMMENDER_SERVICE_URL = os.getenv(\"RECOMMENDER_SERVICE_URL\", \"http://localhost:3002\")\nPRICING_SERVICE_URL = os.getenv(\"PRICING_SERVICE_URL\", \"http://localhost:3003\")\nLASTFM_SERVICE_URL = os.getenv(\"LASTFM_SERVICE_URL\", \"http://localhost:3004\")\n\nhttp_client: httpx.AsyncClient | None = None\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    global http_client\n    http_client = httpx.AsyncClient(timeout=60.0)\n    log_event(\"gateway\", \"INFO\", \"API Gateway started\")\n    yield\n    await http_client.aclose()\n    log_event(\"gateway\", \"INFO\", \"API Gateway stopped\")\n\n\napp = FastAPI(lifespan=lifespan, title=\"Vinyl Recommendation API Gateway\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Mount static files\nstatic_path = Path(__file__).parent / \"static\"\napp.mount(\"/static\", StaticFiles(directory=static_path), name=\"static\")\n\n\n@app.get(\"/\")\nasync def root():\n    return FileResponse(static_path / \"index.html\")\n\n\n@app.get(\"/admin\")\nasync def admin():\n    return FileResponse(static_path / \"admin.html\")\n\n\n@app.get(\"/health\")\nasync def health_check():\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    services_health = {}\n    \n    for service_name, service_url in [\n        (\"spotify\", SPOTIFY_SERVICE_URL),\n        (\"discogs\", DISCOGS_SERVICE_URL),\n        (\"recommender\", RECOMMENDER_SERVICE_URL),\n        (\"pricing\", PRICING_SERVICE_URL),\n        (\"lastfm\", LASTFM_SERVICE_URL),\n    ]:\n        try:\n            resp = await http_client.get(f\"{service_url}/health\", timeout=5.0)\n            services_health[service_name] = resp.json()\n        except Exception as e:\n            services_health[service_name] = {\n                \"service_name\": service_name,\n                \"status\": \"unhealthy\",\n                \"error\": str(e)\n            }\n    \n    all_healthy = all(s.get(\"status\") == \"healthy\" for s in services_health.values())\n    \n    return {\n        \"gateway\": \"healthy\",\n        \"services\": services_health,\n        \"overall_status\": \"healthy\" if all_healthy else \"degraded\"\n    }\n\n\n@app.get(\"/auth/login\")\nasync def spotify_login():\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    try:\n        resp = await http_client.get(f\"{SPOTIFY_SERVICE_URL}/auth/login\")\n        return resp.json()\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to contact Spotify service: {str(e)}\")\n\n\n@app.get(\"/auth/callback\")\nasync def spotify_callback(code: str):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    try:\n        resp = await http_client.get(f\"{SPOTIFY_SERVICE_URL}/auth/callback?code={code}\")\n        data = resp.json()\n        \n        if data.get(\"status\") == \"ok\":\n            return RedirectResponse(url=\"/?auth=success\")\n        else:\n            return RedirectResponse(url=\"/?auth=error\")\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Auth callback failed: {str(e)}\")\n        return RedirectResponse(url=\"/?auth=error\")\n\n\n@app.get(\"/spotify/callback\")\nasync def spotify_callback_alias(code: str):\n    \"\"\"Alias for /auth/callback to maintain compatibility with configured redirect URIs\"\"\"\n    return await spotify_callback(code)\n\n\n@app.get(\"/auth/lastfm/login\")\nasync def lastfm_login():\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    try:\n        resp = await http_client.get(f\"{LASTFM_SERVICE_URL}/auth/url\")\n        data = resp.json()\n        log_event(\"gateway\", \"INFO\", f\"Generated Last.fm auth URL with token: {data.get('token', '')[:10]}...\")\n        return data\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Last.fm login failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Failed to contact Last.fm service: {str(e)}\")\n\n\n@app.get(\"/auth/lastfm/callback\")\nasync def lastfm_callback(token: str):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    try:\n        resp = await http_client.post(f\"{LASTFM_SERVICE_URL}/auth/callback?token={token}\")\n        data = resp.json()\n        \n        if data.get(\"status\") == \"success\":\n            log_event(\"gateway\", \"INFO\", f\"Last.fm authentication successful for user: {data.get('username')}\")\n            return {\"status\": \"ok\", \"username\": data.get(\"username\")}\n        else:\n            raise HTTPException(status_code=400, detail=\"Last.fm authentication failed\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Last.fm callback failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Callback failed: {str(e)}\")\n\n\n@app.get(\"/lastfm/callback\")\nasync def lastfm_callback_alias(token: str):\n    \"\"\"Alias for /auth/lastfm/callback to maintain compatibility with configured redirect URIs\"\"\"\n    return await lastfm_callback(token)\n\n\n@app.get(\"/album-pricing/{artist}/{album}\")\nasync def get_album_pricing(artist: str, album: str):\n    \"\"\"\n    Get complete pricing information for an album with maximum speed optimization.\n    Fetches in parallel:\n    - Discogs master link\n    - eBay best price\n    - Local store links\n    \n    Returns all data in 1-2 seconds thanks to asyncio.gather parallelization.\n    \"\"\"\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    start_time = time.time()\n    log_event(\"gateway\", \"INFO\", f\"Getting pricing for: {artist} - {album}\")\n    \n    try:\n        # Parallel execution of all 3 requests using asyncio.gather\n        discogs_task = http_client.get(f\"{DISCOGS_SERVICE_URL}/master-link/{artist}/{album}\")\n        ebay_task = http_client.get(f\"{PRICING_SERVICE_URL}/ebay-price/{artist}/{album}\")\n        stores_task = http_client.get(f\"{PRICING_SERVICE_URL}/local-stores/{artist}/{album}\")\n        \n        discogs_resp, ebay_resp, stores_resp = await asyncio.gather(\n            discogs_task, ebay_task, stores_task, return_exceptions=True\n        )\n        \n        # Parse Discogs response\n        if isinstance(discogs_resp, Exception):\n            log_event(\"gateway\", \"WARNING\", f\"Discogs master link failed: {str(discogs_resp)}\")\n            discogs_data = {\"master_id\": None, \"master_url\": None, \"message\": str(discogs_resp)}\n        else:\n            discogs_data = discogs_resp.json()\n        \n        # Parse eBay response\n        if isinstance(ebay_resp, Exception):\n            log_event(\"gateway\", \"WARNING\", f\"eBay pricing failed: {str(ebay_resp)}\")\n            ebay_data = {\"offer\": None, \"message\": str(ebay_resp)}\n        else:\n            ebay_data = ebay_resp.json()\n        \n        # Parse local stores response\n        if isinstance(stores_resp, Exception):\n            log_event(\"gateway\", \"WARNING\", f\"Local stores failed: {str(stores_resp)}\")\n            stores_data = {\"stores\": {}}\n        else:\n            stores_data = stores_resp.json()\n        \n        # Fetch tracklist based on type (master or release)\n        tracklist_data = {\"tracklist\": []}\n        discogs_sell_url = None\n        discogs_url = None\n        discogs_type = discogs_data.get(\"type\")\n        discogs_id = discogs_data.get(\"id\")\n        \n        if discogs_type == \"master\" and discogs_id:\n            try:\n                tracklist_resp = await http_client.get(f\"{DISCOGS_SERVICE_URL}/master-tracklist/{discogs_id}\")\n                tracklist_data = tracklist_resp.json()\n                log_event(\"gateway\", \"INFO\", f\"Tracklist fetched for master {discogs_id}: {len(tracklist_data.get('tracklist', []))} tracks\")\n            except Exception as e:\n                log_event(\"gateway\", \"WARNING\", f\"Tracklist fetch failed for master: {str(e)}\")\n            \n            discogs_sell_url = f\"https://www.discogs.com/sell/list?master_id={discogs_id}&currency=EUR&format=Vinyl\"\n            discogs_url = discogs_data.get(\"url\")\n            \n        elif discogs_type == \"release\" and discogs_id:\n            try:\n                tracklist_resp = await http_client.get(f\"{DISCOGS_SERVICE_URL}/release-tracklist/{discogs_id}\")\n                tracklist_data = tracklist_resp.json()\n                log_event(\"gateway\", \"INFO\", f\"Tracklist fetched for release {discogs_id}: {len(tracklist_data.get('tracklist', []))} tracks\")\n            except Exception as e:\n                log_event(\"gateway\", \"WARNING\", f\"Tracklist fetch failed for release: {str(e)}\")\n            \n            discogs_sell_url = f\"https://www.discogs.com/sell/list?release_id={discogs_id}&currency=EUR&format=Vinyl\"\n            discogs_url = discogs_data.get(\"url\")\n        else:\n            log_event(\"gateway\", \"INFO\", f\"No Discogs master or release found for {artist} - {album}\")\n        \n        elapsed = time.time() - start_time\n        log_event(\"gateway\", \"INFO\", f\"Album info fetched for {artist} - {album} in {elapsed:.2f}s (type: {discogs_type or 'none'})\")\n        \n        return {\n            \"artist\": artist,\n            \"album\": album,\n            \"discogs_type\": discogs_type,\n            \"discogs_id\": discogs_id,\n            \"discogs_url\": discogs_url,\n            \"discogs_sell_url\": discogs_sell_url,\n            \"discogs_title\": discogs_data.get(\"title\"),\n            \"tracklist\": tracklist_data.get(\"tracklist\", []),\n            \"ebay_offer\": ebay_data.get(\"offer\"),\n            \"local_stores\": stores_data.get(\"stores\", {}),\n            \"request_time_seconds\": round(elapsed, 2),\n            \"debug_info\": {\n                \"discogs\": discogs_data.get(\"debug_info\"),\n                \"search_type\": discogs_type,\n                \"parallelization\": \"3 concurrent requests (Discogs + eBay + Local Stores) + tracklist fetch\"\n            }\n        }\n    \n    except Exception as e:\n        elapsed = time.time() - start_time\n        log_event(\"gateway\", \"ERROR\", f\"Album pricing failed: {str(e)}\")\n        raise HTTPException(\n            status_code=500,\n            detail=f\"Failed to get album pricing: {str(e)}\"\n        )\n\n\ndef get_vinyl_releases(releases: list) -> tuple[list, dict]:\n    \"\"\"Get all vinyl releases ordered by preference (originals first, then reissues)\n    \n    Returns:\n        (list_of_releases, debug_info)\n    \"\"\"\n    debug_info = {\n        \"total_releases_found\": len(releases),\n        \"vinyl_releases_found\": 0,\n    }\n    \n    if not releases:\n        return [], debug_info\n    \n    preferred_formats = [\"LP\", \"Album\", \"Vinyl\"]\n    \n    vinyl_releases = []\n    for release in releases:\n        format_value = release.get(\"format\", \"\")\n        \n        if isinstance(format_value, list):\n            format_str = \" \".join(format_value).lower()\n        else:\n            format_str = str(format_value).lower()\n        \n        is_vinyl = any(pref.lower() in format_str for pref in preferred_formats)\n        if is_vinyl:\n            vinyl_releases.append(release)\n    \n    debug_info[\"vinyl_releases_found\"] = len(vinyl_releases)\n    \n    # Sort: originals first, then reissues/remasters\n    originals = []\n    reissues = []\n    \n    for release in vinyl_releases:\n        format_value = release.get(\"format\", \"\")\n        if isinstance(format_value, list):\n            format_str = \" \".join(format_value).lower()\n        else:\n            format_str = str(format_value).lower()\n            \n        if \"reissue\" in format_str or \"remaster\" in format_str:\n            reissues.append(release)\n        else:\n            originals.append(release)\n    \n    # Return originals first, then reissues\n    ordered_releases = originals + reissues\n    \n    return ordered_releases, debug_info\n\n\nasync def enrich_album_with_discogs(album: dict, idx: int, total: int, semaphore: asyncio.Semaphore) -> dict:\n    \"\"\"Enrich a single album with Discogs data by trying multiple releases until finding one with price\"\"\"\n    async with semaphore:\n        album_info = album.get(\"album_info\", {})\n        artist_name = album_info.get(\"artists\", [{}])[0].get(\"name\", \"Unknown\")\n        album_name = album_info.get(\"name\", \"Unknown\")\n        \n        log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] Processing: {artist_name} - {album_name}\")\n        \n        debug_info = {\n            \"status\": None,\n            \"message\": None,\n            \"details\": {}\n        }\n        \n        try:\n            search_resp = await http_client.get(\n                f\"{DISCOGS_SERVICE_URL}/search\",\n                params={\"artist\": artist_name, \"title\": album_name}\n            )\n            search_results = search_resp.json().get(\"results\", [])\n            \n            if not search_results:\n                album[\"discogs_release\"] = None\n                album[\"discogs_stats\"] = None\n                debug_info[\"status\"] = \"not_found\"\n                debug_info[\"message\"] = \"No se encontr√≥ en Discogs\"\n                debug_info[\"details\"] = {\"total_releases_found\": 0}\n                log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚óã Not found on Discogs: {album_name}\")\n                album[\"discogs_debug_info\"] = debug_info\n                return album\n            \n            # Get all vinyl releases ordered by preference\n            vinyl_releases, search_debug = get_vinyl_releases(search_results)\n            debug_info[\"details\"] = search_debug\n            \n            if not vinyl_releases:\n                album[\"discogs_release\"] = None\n                album[\"discogs_stats\"] = None\n                debug_info[\"status\"] = \"not_found\"\n                debug_info[\"message\"] = \"No se encontraron vinilos\"\n                log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚óã No vinyl: {album_name}\")\n                album[\"discogs_debug_info\"] = debug_info\n                return album\n            \n            # Try up to 5 releases to find one with price\n            max_attempts = min(5, len(vinyl_releases))\n            debug_info[\"details\"][\"releases_tried\"] = 0\n            debug_info[\"details\"][\"releases_with_price\"] = 0\n            \n            selected_release = None\n            selected_stats = None\n            \n            for attempt_idx, release in enumerate(vinyl_releases[:max_attempts], 1):\n                release_id = release.get(\"id\")\n                format_value = release.get(\"format\", \"\")\n                if isinstance(format_value, list):\n                    format_str = \" \".join(format_value)\n                else:\n                    format_str = str(format_value)\n                \n                log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] Trying release {attempt_idx}/{max_attempts}: ID {release_id} ({format_str})\")\n                \n                try:\n                    stats_resp = await http_client.get(\n                        f\"{DISCOGS_SERVICE_URL}/stats/{release_id}\"\n                    )\n                    stats = stats_resp.json()\n                    debug_info[\"details\"][\"releases_tried\"] = attempt_idx\n                    \n                    has_price = stats.get(\"lowest_price_eur\") is not None and stats.get(\"lowest_price_eur\") > 0\n                    \n                    if has_price:\n                        debug_info[\"details\"][\"releases_with_price\"] += 1\n                        selected_release = release\n                        selected_stats = stats\n                        debug_info[\"details\"][\"selected_release_index\"] = attempt_idx\n                        debug_info[\"details\"][\"selected_format\"] = format_str\n                        log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚úì Found price on attempt {attempt_idx}: ‚Ç¨{stats['lowest_price_eur']:.2f}\")\n                        break\n                    else:\n                        log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚óã Release {release_id} has no price, trying next...\")\n                        \n                except Exception as e:\n                    log_event(\"gateway\", \"WARNING\", f\"[{idx}/{total}] Failed to get stats for release {release_id}: {str(e)}\")\n                    continue\n            \n            # If we didn't find any with price, use the first release anyway\n            if not selected_release:\n                selected_release = vinyl_releases[0]\n                release_id = selected_release.get(\"id\")\n                \n                # Set debug info for fallback selection\n                debug_info[\"details\"][\"selected_release_index\"] = 1\n                format_value = selected_release.get(\"format\", \"\")\n                if isinstance(format_value, list):\n                    debug_info[\"details\"][\"selected_format\"] = \" \".join(format_value)\n                else:\n                    debug_info[\"details\"][\"selected_format\"] = str(format_value)\n                \n                try:\n                    stats_resp = await http_client.get(\n                        f\"{DISCOGS_SERVICE_URL}/stats/{release_id}\"\n                    )\n                    selected_stats = stats_resp.json()\n                except Exception as e:\n                    log_event(\"gateway\", \"WARNING\", f\"[{idx}/{total}] Failed to get stats for fallback release: {str(e)}\")\n                    \n                    # Get sell list URL with master_id from Discogs service\n                    sell_url = f\"https://www.discogs.com/sell/list?release_id={release_id}&currency=EUR&format=Vinyl\"\n                    try:\n                        url_resp = await http_client.get(f\"{DISCOGS_SERVICE_URL}/sell-list-url/{release_id}\")\n                        sell_url = url_resp.json().get(\"url\", sell_url)\n                    except:\n                        pass\n                    \n                    selected_stats = {\n                        \"release_id\": release_id,\n                        \"lowest_price_eur\": None,\n                        \"num_for_sale\": 0,\n                        \"sell_list_url\": sell_url\n                    }\n            \n            album[\"discogs_release\"] = selected_release\n            album[\"discogs_stats\"] = selected_stats\n            \n            has_price = selected_stats.get(\"lowest_price_eur\") is not None and selected_stats.get(\"lowest_price_eur\") > 0\n            \n            if has_price:\n                debug_info[\"status\"] = \"success\"\n                format_val = selected_release.get(\"format\", \"\")\n                if isinstance(format_val, list):\n                    fmt = \" \".join(format_val)\n                else:\n                    fmt = str(format_val)\n                debug_info[\"message\"] = f\"Vinilo disponible - {fmt}\"\n                log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚úì Enriched: {album_name}\")\n            else:\n                debug_info[\"status\"] = \"no_price\"\n                debug_info[\"message\"] = f\"Probados {debug_info['details']['releases_tried']} releases, ninguno con precio\"\n                log_event(\"gateway\", \"INFO\", f\"[{idx}/{total}] ‚ö† No price found after trying {debug_info['details']['releases_tried']} releases: {album_name}\")\n                \n        except Exception as e:\n            log_event(\"gateway\", \"WARNING\", f\"[{idx}/{total}] ‚úó Failed: {album_name} - {str(e)}\")\n            album[\"discogs_release\"] = None\n            album[\"discogs_stats\"] = None\n            debug_info[\"status\"] = \"error\"\n            debug_info[\"message\"] = f\"Error: {str(e)}\"\n            debug_info[\"details\"] = {}\n        \n        album[\"discogs_debug_info\"] = debug_info\n        return album\n\n\n@app.get(\"/recommend-vinyl\")\nasync def recommend_vinyl():\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    start_time = time.time()\n    log_event(\"gateway\", \"INFO\", \"Starting vinyl recommendation flow\")\n    \n    try:\n        log_event(\"gateway\", \"INFO\", \"Step 1: Fetching top tracks from Spotify\")\n        tracks_resp = await http_client.get(f\"{SPOTIFY_SERVICE_URL}/top-tracks\")\n        tracks_data = tracks_resp.json()\n        all_tracks = tracks_data.get(\"tracks\", [])\n        log_event(\"gateway\", \"INFO\", f\"Fetched {len(all_tracks)} tracks\")\n        \n        log_event(\"gateway\", \"INFO\", \"Step 2: Fetching top artists from Spotify\")\n        artists_resp = await http_client.get(f\"{SPOTIFY_SERVICE_URL}/top-artists\")\n        artists_data = artists_resp.json()\n        all_artists = artists_data.get(\"artists\", [])\n        log_event(\"gateway\", \"INFO\", f\"Fetched {len(all_artists)} artists\")\n        \n        log_event(\"gateway\", \"INFO\", \"Step 3: Scoring tracks\")\n        scored_tracks_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/score-tracks\",\n            json=all_tracks\n        )\n        scored_tracks = scored_tracks_resp.json().get(\"scored_tracks\", [])\n        log_event(\"gateway\", \"INFO\", f\"Scored {len(scored_tracks)} tracks\")\n        \n        log_event(\"gateway\", \"INFO\", \"Step 4: Scoring artists\")\n        scored_artists_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/score-artists\",\n            json=all_artists\n        )\n        scored_artists = scored_artists_resp.json().get(\"scored_artists\", [])\n        log_event(\"gateway\", \"INFO\", f\"Scored {len(scored_artists)} artists\")\n        \n        log_event(\"gateway\", \"INFO\", \"Step 5: Aggregating and filtering albums\")\n        albums_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/aggregate-albums\",\n            json={\"scored_tracks\": scored_tracks, \"scored_artists\": scored_artists}\n        )\n        albums = albums_resp.json().get(\"albums\", [])\n        log_event(\"gateway\", \"INFO\", f\"Generated {len(albums)} album recommendations\")\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        log_event(\"gateway\", \"INFO\", f\"Recommendation flow complete: {len(albums)} albums in {total_time:.2f}s\")\n        \n        return {\n            \"albums\": albums,\n            \"total\": len(albums),\n            \"total_time_seconds\": round(total_time, 2),\n            \"stats\": {\n                \"tracks_analyzed\": len(all_tracks),\n                \"artists_analyzed\": len(all_artists),\n                \"albums_found\": len(albums)\n            }\n        }\n    \n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Recommendation flow failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Recommendation failed: {str(e)}\")\n\n\n@app.get(\"/api/lastfm/search\")\nasync def search_artists(q: str):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    if len(q) < 4:\n        raise HTTPException(status_code=400, detail=\"Query must be at least 4 characters\")\n    \n    try:\n        log_event(\"gateway\", \"INFO\", f\"Searching artists: {q}\")\n        resp = await http_client.get(f\"{LASTFM_SERVICE_URL}/search?q={q}\")\n        data = resp.json()\n        log_event(\"gateway\", \"INFO\", f\"Found {len(data.get('artists', []))} artists\")\n        return data\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Artist search failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Search failed: {str(e)}\")\n\n\n@app.post(\"/api/lastfm/recommendations\")\nasync def get_lastfm_recommendations(request: dict):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    start_time = time.time()\n    time_range = request.get(\"time_range\", \"medium_term\")\n    username = request.get(\"username\")\n    \n    if not username:\n        raise HTTPException(status_code=400, detail=\"username is required\")\n    \n    log_event(\"gateway\", \"INFO\", f\"Starting Last.fm recommendation flow for {username} (time_range={time_range})\")\n    \n    try:\n        log_event(\"gateway\", \"INFO\", \"Step 1: Fetching top albums from Last.fm (simplified)\")\n        albums_resp = await http_client.post(\n            f\"{LASTFM_SERVICE_URL}/top-albums\",\n            json={\"time_range\": time_range, \"username\": username}\n        )\n        albums_data = albums_resp.json()\n        all_albums = albums_data.get(\"albums\", [])\n        log_event(\"gateway\", \"INFO\", f\"Fetched {len(all_albums)} Last.fm top albums\")\n        \n        log_event(\"gateway\", \"INFO\", \"Step 2: Processing albums (cache-first + cover fetch)\")\n        recommendations_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/lastfm-albums-recommendations\",\n            json=all_albums\n        )\n        recommendations_data = recommendations_resp.json()\n        albums = recommendations_data.get(\"albums\", [])\n        stats = recommendations_data.get(\"stats\", {})\n        \n        log_event(\"gateway\", \"INFO\", \n                 f\"Processed {len(albums)} Last.fm recommendations \"\n                 f\"(cache: {stats.get('cache_hits', 0)}, \"\n                 f\"new: {stats.get('cache_misses', 0)}, \"\n                 f\"covers fetched: {stats.get('covers_fetched', 0)})\")\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        log_event(\"gateway\", \"INFO\", f\"Last.fm recommendation flow complete: {len(albums)} albums in {total_time:.2f}s\")\n        \n        return {\n            \"albums\": albums,\n            \"total\": len(albums),\n            \"total_time_seconds\": round(total_time, 2),\n            \"stats\": {\n                \"albums_processed\": len(all_albums),\n                \"albums_found\": len(albums),\n                \"cache_hits\": stats.get(\"cache_hits\", 0),\n                \"cache_misses\": stats.get(\"cache_misses\", 0),\n                \"covers_fetched\": stats.get(\"covers_fetched\", 0)\n            }\n        }\n    \n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Last.fm recommendation flow failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Last.fm recommendation failed: {str(e)}\")\n\n\n@app.get(\"/api/recommendations/progress\")\nasync def get_recommendations_progress():\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    try:\n        resp = await http_client.get(f\"{RECOMMENDER_SERVICE_URL}/progress\")\n        return resp.json()\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Failed to fetch progress: {str(e)}\")\n        return {\"status\": \"idle\", \"current\": 0, \"total\": 0, \"current_artist\": \"\"}\n\n\n@app.post(\"/api/recommendations/artist-single\")\nasync def get_single_artist_recommendations(request: dict):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    artist_name = request.get(\"artist_name\")\n    top_albums = request.get(\"top_albums\", 3)\n    csv_mode = request.get(\"csv_mode\", False)\n    \n    if not artist_name:\n        raise HTTPException(status_code=400, detail=\"artist_name is required\")\n    \n    start_time = time.time()\n    mode_label = \" (CSV mode)\" if csv_mode else \"\"\n    log_event(\"gateway\", \"INFO\", f\"Getting recommendations for artist: {artist_name}{mode_label}\")\n    \n    try:\n        resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/artist-single-recommendation\",\n            json={\"artist_name\": artist_name, \"top_albums\": top_albums, \"csv_mode\": csv_mode}\n        )\n        resp.raise_for_status()\n        result = resp.json()\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        \n        recommendations = result.get(\"recommendations\", [])\n        \n        if not recommendations:\n            log_event(\"gateway\", \"WARNING\", f\"No recommendations found for {artist_name}\")\n            raise HTTPException(status_code=404, detail=f\"No albums found for artist: {artist_name}\")\n        \n        log_event(\"gateway\", \"INFO\", \n                 f\"Got {len(recommendations)} recommendations for {artist_name} in {total_time:.2f}s\")\n        \n        return {\n            \"recommendations\": recommendations,\n            \"total\": len(recommendations),\n            \"artist_name\": artist_name,\n            \"total_time_seconds\": round(total_time, 2),\n            \"status\": \"success\"\n        }\n    \n    except HTTPException:\n        raise\n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Single artist recommendations failed for {artist_name}: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Recommendations failed: {str(e)}\")\n\n\n@app.post(\"/api/recommendations/artists\")\nasync def get_artist_recommendations(request: dict):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    artist_names = request.get(\"artist_names\", [])\n    spotify_token = request.get(\"spotify_token\")\n    \n    if not artist_names:\n        raise HTTPException(status_code=400, detail=\"artist_names is required\")\n    \n    if len(artist_names) < 3:\n        raise HTTPException(status_code=400, detail=\"Minimum 3 artists required\")\n    \n    if len(artist_names) > 10:\n        raise HTTPException(status_code=400, detail=\"Maximum 10 artists allowed\")\n    \n    start_time = time.time()\n    log_event(\"gateway\", \"INFO\", f\"Getting recommendations for {len(artist_names)} artists\")\n    \n    try:\n        artist_recs_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/artist-recommendations\",\n            json={\"artist_names\": artist_names, \"top_per_artist\": 3}\n        )\n        artist_recs = artist_recs_resp.json().get(\"recommendations\", [])\n        log_event(\"gateway\", \"INFO\", f\"Got {len(artist_recs)} artist-based recommendations\")\n        \n        spotify_recs = []\n        if spotify_token:\n            try:\n                log_event(\"gateway\", \"INFO\", \"Fetching Spotify recommendations\")\n                \n                tracks_resp, artists_resp = await asyncio.gather(\n                    http_client.get(f\"{SPOTIFY_SERVICE_URL}/top-tracks\"),\n                    http_client.get(f\"{SPOTIFY_SERVICE_URL}/top-artists\")\n                )\n                \n                tracks_data = tracks_resp.json()\n                all_tracks = tracks_data.get(\"tracks\", [])\n                \n                artists_data = artists_resp.json()\n                all_artists = artists_data.get(\"artists\", [])\n                \n                scored_tracks_resp, scored_artists_resp = await asyncio.gather(\n                    http_client.post(f\"{RECOMMENDER_SERVICE_URL}/score-tracks\", json=all_tracks),\n                    http_client.post(f\"{RECOMMENDER_SERVICE_URL}/score-artists\", json=all_artists)\n                )\n                \n                scored_tracks = scored_tracks_resp.json().get(\"scored_tracks\", [])\n                scored_artists = scored_artists_resp.json().get(\"scored_artists\", [])\n                \n                albums_resp = await http_client.post(\n                    f\"{RECOMMENDER_SERVICE_URL}/aggregate-albums\",\n                    json={\"scored_tracks\": scored_tracks, \"scored_artists\": scored_artists}\n                )\n                spotify_recs = albums_resp.json().get(\"albums\", [])\n                log_event(\"gateway\", \"INFO\", f\"Got {len(spotify_recs)} Spotify recommendations\")\n            except Exception as e:\n                log_event(\"gateway\", \"WARNING\", f\"Failed to get Spotify recommendations: {str(e)}\")\n        \n        merge_resp = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/merge-recommendations\",\n            json={\n                \"spotify_recommendations\": spotify_recs,\n                \"artist_recommendations\": artist_recs\n            }\n        )\n        merged = merge_resp.json().get(\"recommendations\", [])\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        log_event(\"gateway\", \"INFO\", f\"Artist recommendations complete: {len(merged)} total in {total_time:.2f}s\")\n        \n        return {\n            \"recommendations\": merged,\n            \"total\": len(merged),\n            \"total_time_seconds\": round(total_time, 2),\n            \"stats\": {\n                \"artist_based\": len(artist_recs),\n                \"spotify_based\": len(spotify_recs),\n                \"total\": len(merged)\n            }\n        }\n    \n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Artist recommendations failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Recommendations failed: {str(e)}\")\n\n\n@app.post(\"/api/recommendations/merge\")\nasync def merge_recommendations(request: dict):\n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    try:\n        spotify_recs = request.get(\"spotify_recommendations\", [])\n        lastfm_recs = request.get(\"lastfm_recommendations\", [])\n        artist_recs = request.get(\"artist_recommendations\", [])\n        \n        log_event(\"gateway\", \"INFO\", \n                  f\"Merging {len(spotify_recs)} Spotify + {len(lastfm_recs)} Last.fm + {len(artist_recs)} artist recommendations\")\n        \n        response = await http_client.post(\n            f\"{RECOMMENDER_SERVICE_URL}/merge-recommendations\",\n            json={\n                \"spotify_recommendations\": spotify_recs,\n                \"lastfm_recommendations\": lastfm_recs,\n                \"artist_recommendations\": artist_recs\n            }\n        )\n        \n        data = response.json()\n        log_event(\"gateway\", \"INFO\", f\"Merged into {data.get('total', 0)} recommendations\")\n        return data\n    \n    except Exception as e:\n        log_event(\"gateway\", \"ERROR\", f\"Merge recommendations failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"Merge failed: {str(e)}\")\n\n\n@app.post(\"/api/admin/import-csv\")\nasync def import_artists_csv(file: UploadFile = File(...)):\n    \"\"\"Import artists from CSV file with real-time progress updates via SSE\"\"\"\n    \n    if not http_client:\n        raise HTTPException(status_code=500, detail=\"HTTP client not initialized\")\n    \n    if not file.filename or not file.filename.endswith('.csv'):\n        raise HTTPException(status_code=400, detail=\"File must be a CSV\")\n    \n    # Read file content before creating the stream\n    content = await file.read()\n    csv_text = content.decode('utf-8')\n    csv_reader = csv.DictReader(csv_text.splitlines())\n    \n    if not csv_reader.fieldnames or 'name' not in csv_reader.fieldnames:\n        raise HTTPException(status_code=400, detail=\"CSV must have a 'name' column\")\n    \n    artists = [row['name'].strip() for row in csv_reader if row.get('name', '').strip()]\n    \n    if not artists:\n        raise HTTPException(status_code=400, detail=\"No artists found in CSV\")\n    \n    async def event_stream() -> AsyncGenerator[str, None]:\n        \"\"\"Server-Sent Events stream for progress updates\"\"\"\n        try:\n            total = len(artists)\n            yield f\"data: {json.dumps({'type': 'start', 'total': total})}\\n\\n\"\n            \n            successful = 0\n            cached = 0\n            failed = 0\n            failed_artists = []\n            \n            for i, artist_name in enumerate(artists, 1):\n                try:\n                    start_time = time.time()\n                    \n                    response = await http_client.post(\n                        \"http://localhost:5000/api/recommendations/artist-single\",\n                        json={\"artist_name\": artist_name, \"top_albums\": 10, \"csv_mode\": True},\n                        timeout=180.0\n                    )\n                    \n                    elapsed = time.time() - start_time\n                    \n                    if response.status_code == 200:\n                        data = response.json()\n                        total_albums = data.get('total', 0)\n                        top_album = None\n                        rating = None\n                        \n                        if data.get('recommendations'):\n                            top_album = data['recommendations'][0].get('album_name')\n                            rating = data['recommendations'][0].get('rating')\n                        \n                        if elapsed < 1.0:\n                            cached += 1\n                            status = 'cached'\n                        else:\n                            successful += 1\n                            status = 'success'\n                        \n                        yield f\"data: {json.dumps({'type': 'progress', 'current': i, 'total': total, 'artist': artist_name, 'status': status, 'albums': total_albums, 'time': round(elapsed, 2), 'top_album': top_album, 'rating': rating})}\\n\\n\"\n                    \n                    elif response.status_code == 404:\n                        failed += 1\n                        failed_artists.append(artist_name)\n                        yield f\"data: {json.dumps({'type': 'progress', 'current': i, 'total': total, 'artist': artist_name, 'status': 'not_found', 'error': 'No albums found'})}\\n\\n\"\n                    \n                    else:\n                        failed += 1\n                        failed_artists.append(artist_name)\n                        error_msg = response.text[:100]\n                        yield f\"data: {json.dumps({'type': 'progress', 'current': i, 'total': total, 'artist': artist_name, 'status': 'error', 'error': error_msg})}\\n\\n\"\n                \n                except asyncio.TimeoutError:\n                    failed += 1\n                    failed_artists.append(artist_name)\n                    yield f\"data: {json.dumps({'type': 'progress', 'current': i, 'total': total, 'artist': artist_name, 'status': 'timeout', 'error': 'Request timeout'})}\\n\\n\"\n                \n                except Exception as e:\n                    failed += 1\n                    failed_artists.append(artist_name)\n                    yield f\"data: {json.dumps({'type': 'progress', 'current': i, 'total': total, 'artist': artist_name, 'status': 'error', 'error': str(e)})}\\n\\n\"\n                \n                await asyncio.sleep(0.1)\n            \n            if failed_artists:\n                yield f\"data: {json.dumps({'type': 'retry_start', 'failed_count': len(failed_artists), 'artists': failed_artists})}\\n\\n\"\n                \n                retry_successful = 0\n                retry_failed = 0\n                \n                for i, artist_name in enumerate(failed_artists, 1):\n                    try:\n                        start_time = time.time()\n                        \n                        response = await http_client.post(\n                            \"http://localhost:5000/api/recommendations/artist-single\",\n                            json={\"artist_name\": artist_name, \"top_albums\": 10, \"csv_mode\": True},\n                            timeout=180.0\n                        )\n                        \n                        elapsed = time.time() - start_time\n                        \n                        if response.status_code == 200:\n                            data = response.json()\n                            total_albums = data.get('total', 0)\n                            top_album = None\n                            rating = None\n                            \n                            if data.get('recommendations'):\n                                top_album = data['recommendations'][0].get('album_name')\n                                rating = data['recommendations'][0].get('rating')\n                            \n                            retry_successful += 1\n                            successful += 1\n                            failed -= 1\n                            \n                            yield f\"data: {json.dumps({'type': 'retry_progress', 'current': i, 'total': len(failed_artists), 'artist': artist_name, 'status': 'success', 'albums': total_albums, 'time': round(elapsed, 2), 'top_album': top_album, 'rating': rating})}\\n\\n\"\n                        else:\n                            retry_failed += 1\n                            error_msg = response.text[:100] if hasattr(response, 'text') else 'Unknown error'\n                            yield f\"data: {json.dumps({'type': 'retry_progress', 'current': i, 'total': len(failed_artists), 'artist': artist_name, 'status': 'error', 'error': error_msg})}\\n\\n\"\n                    \n                    except Exception as e:\n                        retry_failed += 1\n                        yield f\"data: {json.dumps({'type': 'retry_progress', 'current': i, 'total': len(failed_artists), 'artist': artist_name, 'status': 'error', 'error': str(e)})}\\n\\n\"\n                    \n                    await asyncio.sleep(0.1)\n                \n                yield f\"data: {json.dumps({'type': 'retry_complete', 'retry_successful': retry_successful, 'retry_failed': retry_failed})}\\n\\n\"\n            \n            yield f\"data: {json.dumps({'type': 'complete', 'successful': successful, 'cached': cached, 'failed': failed, 'total': total})}\\n\\n\"\n        \n        except Exception as e:\n            yield f\"data: {json.dumps({'type': 'error', 'message': str(e)})}\\n\\n\"\n    \n    return StreamingResponse(event_stream(), media_type=\"text/event-stream\")\n","size_bytes":41595},"services/__init__.py":{"content":"","size_bytes":0},"tests/discogs_rating.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\ndiscogs_rating_full.py\n\nUso desde terminal:\n\n1) Por master id:\n   python discogs_rating_full.py --master-id 606709\n\n2) Por artista + √°lbum:\n   python discogs_rating_full.py --artist \"Arctic Monkeys\" --album \"AM\"\n\nEl script:\n- Si usas master-id, intenta rating del main_release del master.\n- Si usas artista+√°lbum, busca en /database/search:\n    - Si el resultado tiene master_id ‚Üí usa master ‚Üí main_release para rating.\n    - Si no tiene master_id ‚Üí usa directamente el release para rating.\n\"\"\"\n\nimport argparse\nimport sys\nfrom typing import Any, Dict, Optional, List\n\nimport httpx\n\n# =========================\n# CONFIG\n# =========================\n\nDISCOGS_KEY = \"QiaraVlzXNSUJOpkdKdK\"      # <-- pon aqu√≠ tu key de Discogs\nDISCOGS_SECRET = \"BssuhxnAECuSXYoFYPzIuSUixhVXRedG\"   # <-- pon aqu√≠ tu secret de Discogs\n\nBASE_URL = \"https://api.discogs.com\"\nUSER_AGENT = \"Vinilogy/1.0 (+https://vinilogy.com)\"  # c√°mbialo si quieres\n\n\n# =========================\n# Helpers HTTP y rating\n# =========================\n\ndef discogs_get(path: str, params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Hace un GET a la API de Discogs a√±adiendo key/secret y User-Agent.\n    Sale con c√≥digo 1 si falta config o hay error HTTP.\n    \"\"\"\n    if not DISCOGS_KEY or not DISCOGS_SECRET:\n        print(\"ERROR: Configura DISCOGS_KEY y DISCOGS_SECRET en el script.\", file=sys.stderr)\n        sys.exit(1)\n\n    url = f\"{BASE_URL}{path}\"\n    full_params = dict(params)\n    full_params[\"key\"] = DISCOGS_KEY\n    full_params[\"secret\"] = DISCOGS_SECRET\n\n    headers = {\"User-Agent\": USER_AGENT}\n\n    with httpx.Client(timeout=20.0, headers=headers) as client:\n        r = client.get(url, params=full_params)\n        if r.status_code != 200:\n            print(f\"ERROR HTTP {r.status_code} para {url}: {r.text}\", file=sys.stderr)\n            sys.exit(1)\n        return r.json()\n\n\ndef extract_rating(obj: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Extrae el rating de community.rating.{average, count}.\n    Devuelve dict {average, count} o None si no hay rating.\n    \"\"\"\n    community = obj.get(\"community\") or {}\n    rating = community.get(\"rating\") or {}\n    average = rating.get(\"average\")\n    count = rating.get(\"count\")\n\n    if average is None or count is None:\n        return None\n\n    return {\n        \"average\": float(average),\n        \"count\": int(count),\n    }\n\n\n# =========================\n# Rating por release\n# =========================\n\ndef get_rating_by_release_id(release_id: int) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Dado un release_id, obtiene el rating de /releases/{id}.\n    \"\"\"\n    data = discogs_get(f\"/releases/{release_id}\", params={})\n    rating = extract_rating(data)\n    if rating:\n        rating[\"source\"] = \"release\"\n        rating[\"release_id\"] = int(release_id)\n    return rating\n\n\n# =========================\n# Rating por master (usa main_release)\n# =========================\n\ndef get_rating_by_master_id(master_id: int) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Dado un master_id:\n      1) Lee /masters/{id}\n      2) Intenta rating del main_release (main_release_url)\n      3) Si no hay, intenta rating directo del master\n      4) (Opcional) aqu√≠ podr√≠as hacer fallback a versiones si quisieras\n    \"\"\"\n    master = discogs_get(f\"/masters/{master_id}\", params={})\n\n    # 1) Intentar v√≠a main_release\n    main_release_id = master.get(\"main_release\")\n    if main_release_id:\n        rel = discogs_get(f\"/releases/{main_release_id}\", params={})\n        rating_rel = extract_rating(rel)\n        if rating_rel is not None:\n            rating_rel[\"source\"] = \"main_release\"\n            rating_rel[\"master_id\"] = int(master_id)\n            rating_rel[\"release_id\"] = int(main_release_id)\n            return rating_rel\n\n    # 2) Intentar rating directo del master (no siempre existe)\n    rating_master = extract_rating(master)\n    if rating_master is not None:\n        rating_master[\"source\"] = \"master\"\n        rating_master[\"master_id\"] = int(master_id)\n        return rating_master\n\n    # 3) Aqu√≠ podr√≠as llamar a aggregate_rating_from_master_versions(master_id)\n    return None\n\n\n# =========================\n# B√∫squeda por artista + √°lbum\n# =========================\n\ndef score_search_result(r: Dict[str, Any], album: str) -> int:\n    \"\"\"\n    Asigna un peque√±o score a cada resultado para elegir el mejor.\n    - Prioriza formato Vinyl\n    - Prioriza que el t√≠tulo contenga el nombre del √°lbum\n    \"\"\"\n    score = 0\n\n    formats = r.get(\"format\") or []\n    if any(\"Vinyl\" in f for f in formats):\n        score += 10\n\n    title = r.get(\"title\") or \"\"\n    if album.lower() in title.lower():\n        score += 5\n\n    # Si tiene master_id, sumamos un poco (suele estar bien agrupado)\n    if r.get(\"master_id\"):\n        score += 2\n\n    return score\n\n\ndef search_best_release_or_master(artist: str, album: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Busca en /database/search usando artist + release_title sin 'type',\n    para permitir que vengan tanto masters como releases.\n\n    Devuelve el mejor resultado (dict de la lista 'results') o None.\n    \"\"\"\n    params = {\n        \"artist\": artist,\n        \"release_title\": album,\n        \"per_page\": 10,\n        \"page\": 1,\n    }\n    data = discogs_get(\"/database/search\", params=params)\n    results: List[Dict[str, Any]] = data.get(\"results\") or []\n\n    if not results:\n        return None\n\n    # Elegimos el que tenga mayor score\n    scored = sorted(results, key=lambda r: score_search_result(r, album), reverse=True)\n    return scored[0]\n\n\ndef get_rating_by_artist_album(artist: str, album: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    1) Busca el mejor resultado en /database/search\n    2) Si el resultado tiene master_id:\n        - usa get_rating_by_master_id(master_id)\n    3) Si no tiene master_id, usa el id como release_id y saca rating de /releases/{id}\n    \"\"\"\n    best = search_best_release_or_master(artist, album)\n    if best is None:\n        print(f\"No se encontraron resultados para '{artist}' - '{album}'\", file=sys.stderr)\n        return None\n\n    master_id = best.get(\"master_id\")\n    release_id = best.get(\"id\")\n\n    if master_id:\n        rating = get_rating_by_master_id(int(master_id))\n        if rating is not None:\n            # a√±adimos algo de contexto del search\n            rating.setdefault(\"meta\", {})\n            rating[\"meta\"][\"search_title\"] = best.get(\"title\")\n            rating[\"meta\"][\"search_type\"] = best.get(\"type\")\n            rating[\"meta\"][\"search_formats\"] = best.get(\"format\")\n            return rating\n\n    if release_id:\n        rating = get_rating_by_release_id(int(release_id))\n        if rating is not None:\n            rating.setdefault(\"meta\", {})\n            rating[\"meta\"][\"search_title\"] = best.get(\"title\")\n            rating[\"meta\"][\"search_type\"] = best.get(\"type\")\n            rating[\"meta\"][\"search_formats\"] = best.get(\"format\")\n            return rating\n\n    print(f\"El mejor resultado para '{artist}' - '{album}' no tiene rating.\", file=sys.stderr)\n    return None\n\n\n# =========================\n# CLI\n# =========================\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(\n        description=\"Lee el rating de un release/master de Discogs por master-id o por artista+√°lbum.\"\n    )\n    parser.add_argument(\"--master-id\", type=int, help=\"ID del master de Discogs\")\n    parser.add_argument(\"--artist\", type=str, help=\"Nombre del artista\")\n    parser.add_argument(\"--album\", type=str, help=\"T√≠tulo del √°lbum\")\n    return parser.parse_args()\n\n\ndef main() -> None:\n    args = parse_args()\n\n    if args.master_id and (args.artist or args.album):\n        print(\"ERROR: Usa o bien --master-id o bien --artist + --album, pero no ambos.\", file=sys.stderr)\n        sys.exit(1)\n\n    if args.master_id:\n        rating = get_rating_by_master_id(args.master_id)\n        if rating is None:\n            print(f\"El master {args.master_id} no tiene rating.\")\n        else:\n            src = rating.get(\"source\", \"desconocido\")\n            avg = rating[\"average\"]\n            cnt = rating[\"count\"]\n            rel_id = rating.get(\"release_id\")\n            extra = f\" (release {rel_id})\" if rel_id else \"\"\n            print(f\"[{src}] Rating master {args.master_id}{extra}: {avg:.2f} ({cnt} votos)\")\n        return\n\n    if args.artist and args.album:\n        rating = get_rating_by_artist_album(args.artist, args.album)\n        if rating is None:\n            print(f\"No se obtuvo rating para '{args.artist}' - '{args.album}'.\")\n        else:\n            src = rating.get(\"source\", \"desconocido\")\n            avg = rating[\"average\"]\n            cnt = rating[\"count\"]\n            rid = rating.get(\"release_id\")\n            mid = rating.get(\"master_id\")\n            print(f\"[{src}] Rating para '{args.artist}' - '{args.album}': {avg:.2f} ({cnt} votos)\")\n            if mid:\n                print(f\"  master_id: {mid}\")\n            if rid:\n                print(f\"  release_id: {rid}\")\n        return\n\n    print(\"ERROR: Debes usar --master-id o bien --artist y --album.\", file=sys.stderr)\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":9152},"libs/shared/utils.py":{"content":"import httpx\nfrom typing import Optional\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_http_client(timeout: float = 15.0, headers: Optional[dict] = None) -> httpx.AsyncClient:\n    return httpx.AsyncClient(timeout=timeout, headers=headers or {})\n\n\ndef log_event(service: str, level: str, message: str, data: Optional[dict] = None):\n    timestamp = datetime.utcnow().isoformat()\n    log_msg = f\"[{timestamp}] [{service}] [{level}] {message}\"\n    \n    if level == \"ERROR\":\n        logger.error(log_msg, extra={\"data\": data})\n    elif level == \"WARNING\":\n        logger.warning(log_msg, extra={\"data\": data})\n    elif level == \"INFO\":\n        logger.info(log_msg, extra={\"data\": data})\n    else:\n        logger.debug(log_msg, extra={\"data\": data})\n    \n    return {\n        \"service\": service,\n        \"level\": level,\n        \"message\": message,\n        \"timestamp\": timestamp,\n        \"data\": data,\n    }\n","size_bytes":952},"gateway/static/app-user.js":{"content":"// Theme Management\nfunction initTheme() {\n    const savedTheme = localStorage.getItem('theme') || 'light';\n    document.documentElement.setAttribute('data-theme', savedTheme);\n}\n\nfunction toggleTheme() {\n    const currentTheme = document.documentElement.getAttribute('data-theme');\n    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n    document.documentElement.setAttribute('data-theme', newTheme);\n    localStorage.setItem('theme', newTheme);\n}\n\n// Spotify Authentication\nasync function loginSpotify() {\n    try {\n        const response = await fetch('/auth/login');\n        const data = await response.json();\n        \n        if (data.authorize_url) {\n            localStorage.setItem('vinilogy_auth_pending', 'true');\n            window.location.href = data.authorize_url;\n        }\n    } catch (error) {\n        console.error('Error initiating Spotify login:', error);\n        alert('Error al conectar con Spotify. Por favor, intenta de nuevo.');\n    }\n}\n\n// Last.fm Authentication\nasync function loginLastfm() {\n    try {\n        const response = await fetch('/auth/lastfm/login');\n        const data = await response.json();\n        \n        if (data.auth_url && data.token) {\n            localStorage.setItem('vinilogy_lastfm_token', data.token);\n            \n            const popupWindow = window.open(data.auth_url, 'Last.fm Auth', 'width=800,height=600');\n            \n            const confirmBtn = document.createElement('button');\n            confirmBtn.textContent = 'Ya autoric√© en Last.fm';\n            confirmBtn.className = 'lastfm-confirm-btn';\n            confirmBtn.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:10000;padding:20px 40px;background:#d51007;color:white;border:none;border-radius:12px;font-size:18px;font-weight:bold;cursor:pointer;box-shadow:0 8px 24px rgba(213,16,7,0.4);transition:all 0.3s;';\n            confirmBtn.onmouseover = () => {\n                confirmBtn.style.transform = 'translate(-50%,-50%) scale(1.05)';\n                confirmBtn.style.boxShadow = '0 12px 32px rgba(213,16,7,0.5)';\n            };\n            confirmBtn.onmouseout = () => {\n                confirmBtn.style.transform = 'translate(-50%,-50%) scale(1)';\n                confirmBtn.style.boxShadow = '0 8px 24px rgba(213,16,7,0.4)';\n            };\n            confirmBtn.onclick = async () => {\n                confirmBtn.disabled = true;\n                confirmBtn.textContent = 'Conectando...';\n                \n                const success = await completeLastfmAuth(data.token);\n                \n                if (success) {\n                    document.body.removeChild(confirmBtn);\n                    if (popupWindow && !popupWindow.closed) {\n                        popupWindow.close();\n                    }\n                } else {\n                    confirmBtn.disabled = false;\n                    confirmBtn.textContent = 'Reintentar';\n                }\n            };\n            \n            document.body.appendChild(confirmBtn);\n        }\n    } catch (error) {\n        console.error('Error initiating Last.fm login:', error);\n        alert('Error al conectar con Last.fm. Por favor, intenta de nuevo.');\n    }\n}\n\nasync function completeLastfmAuth(token) {\n    showLoading(true, 'Esperando confirmaci√≥n de Last.fm (5 segundos)...');\n    \n    try {\n        await new Promise(resolve => setTimeout(resolve, 5000));\n        \n        const response = await fetch(`/auth/lastfm/callback?token=${token}`);\n        const data = await response.json();\n        \n        if (response.ok && data.status === 'ok' && data.username) {\n            localStorage.setItem('lastfm_username', data.username);\n            localStorage.setItem('has_lastfm_connected', 'true');\n            localStorage.removeItem('vinilogy_lastfm_token');\n            \n            showLoading(true, 'Last.fm conectado! Cargando recomendaciones...');\n            setTimeout(async () => {\n                await loadAllRecommendations();\n            }, 1000);\n            \n            return true;\n        } else {\n            showLoading(false);\n            alert(`‚ùå Error: No se pudo conectar con Last.fm.\\n\\n‚úÖ Pasos a seguir:\\n1. Aseg√∫rate de hacer clic en \"YES, ALLOW ACCESS\" en la ventana de Last.fm\\n2. Espera a que veas \"Application authenticated\"\\n3. ESPERA 5-10 segundos m√°s\\n4. Luego haz clic en \"Ya autoric√© en Last.fm\"`);\n            return false;\n        }\n    } catch (error) {\n        showLoading(false);\n        console.error('Error completing Last.fm auth:', error);\n        alert('‚ùå Error de conexi√≥n. Por favor intenta de nuevo siguiendo estos pasos:\\n\\n1. Haz clic en \"YES, ALLOW ACCESS\" en Last.fm\\n2. ESPERA 5-10 segundos despu√©s de ver \"Application authenticated\"\\n3. Haz clic en \"Ya autoric√© en Last.fm\"');\n        return false;\n    }\n}\n\n// Handle Spotify callback\nasync function handleSpotifyCallback() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const auth = urlParams.get('auth');\n    \n    if (auth === 'success') {\n        window.history.replaceState({}, document.title, '/');\n        localStorage.removeItem('vinilogy_auth_pending');\n        localStorage.setItem('has_spotify_connected', 'true');\n        \n        const savedArtists = localStorage.getItem('selected_artist_names');\n        if (savedArtists) {\n            await loadMixedRecommendations(JSON.parse(savedArtists));\n        } else {\n            showLoading(true);\n            await loadAllRecommendations();\n        }\n    } else if (auth === 'error') {\n        window.history.replaceState({}, document.title, '/');\n        alert('Error al autenticar con Spotify. Por favor, intenta de nuevo.');\n    }\n}\n\n// Handle Last.fm callback (handled by backend, check status)\nasync function handleLastfmCallback() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const token = urlParams.get('token');\n    \n    if (token && localStorage.getItem('vinilogy_lastfm_auth_pending')) {\n        showLoading(true, 'Completando autenticaci√≥n con Last.fm...');\n        \n        try {\n            const response = await fetch(`/auth/lastfm/callback?token=${token}`);\n            const data = await response.json();\n            \n            if (data.status === 'ok' && data.username) {\n                localStorage.setItem('lastfm_username', data.username);\n                localStorage.setItem('has_lastfm_connected', 'true');\n                localStorage.removeItem('vinilogy_lastfm_auth_pending');\n                \n                window.history.replaceState({}, document.title, '/');\n                \n                setTimeout(async () => {\n                    await loadAllRecommendations();\n                }, 1000);\n            }\n        } catch (error) {\n            console.error('Error completing Last.fm auth:', error);\n            showLoading(false);\n            alert('Error al completar la autenticaci√≥n de Last.fm');\n        }\n    }\n}\n\n// Show/hide loading state (legacy, keep for simple loads)\nfunction showLoading(show, message = 'Cargando tus recomendaciones...') {\n    const loadingEl = document.getElementById('loading');\n    loadingEl.classList.toggle('active', show);\n    if (show) {\n        loadingEl.querySelector('p').textContent = message;\n    }\n}\n\n// Progress banner control\nlet progressStartTime = 0;\n\nfunction showProgressModal(title = 'Generando Recomendaciones') {\n    const banner = document.getElementById('progress-banner');\n    const titleEl = document.getElementById('progress-title');\n    \n    showLoading(false);\n    \n    titleEl.textContent = title;\n    banner.classList.add('active');\n    progressStartTime = Date.now();\n    \n    updateProgressUI(0, 0, 'Iniciando...', '');\n}\n\nfunction hideProgressModal() {\n    const banner = document.getElementById('progress-banner');\n    banner.classList.remove('active');\n    showLoading(false);\n}\n\nfunction updateProgressUI(current, total, status, currentArtist = '') {\n    const progressBar = document.getElementById('progress-bar');\n    const percentage = document.getElementById('progress-percentage');\n    const statusEl = document.getElementById('progress-status');\n    const artistEl = document.getElementById('progress-current-artist');\n    const timeEl = document.getElementById('progress-time-estimate');\n    \n    const percent = total > 0 ? Math.round((current / total) * 100) : 0;\n    \n    if (total === 0 || percent === 0) {\n        progressBar.classList.add('indeterminate');\n        progressBar.style.width = '';\n    } else {\n        progressBar.classList.remove('indeterminate');\n        progressBar.style.width = `${percent}%`;\n    }\n    \n    percentage.textContent = `${percent}%`;\n    statusEl.textContent = status;\n    \n    if (currentArtist) {\n        artistEl.textContent = ` | üîç ${currentArtist}`;\n    } else {\n        artistEl.textContent = '';\n    }\n    \n    if (current > 0 && total > 0 && current < total) {\n        const elapsed = (Date.now() - progressStartTime) / 1000;\n        const timePerItem = elapsed / current;\n        const remaining = Math.round(timePerItem * (total - current));\n        timeEl.textContent = ` | ‚è±Ô∏è ~${remaining}s`;\n    } else {\n        timeEl.textContent = '';\n    }\n}\n\n// Progress monitoring\nlet progressInterval = null;\nlet progressPollCount = 0;\nconst MAX_PROGRESS_POLLS = 120;\n\nasync function startProgressMonitoring(contextTitle = 'Generando Recomendaciones') {\n    if (progressInterval) {\n        clearInterval(progressInterval);\n    }\n    \n    showProgressModal(contextTitle);\n    progressPollCount = 0;\n    \n    progressInterval = setInterval(async () => {\n        try {\n            progressPollCount++;\n            \n            if (progressPollCount > MAX_PROGRESS_POLLS) {\n                console.warn('Progress monitoring timed out');\n                stopProgressMonitoring();\n                hideProgressModal();\n                alert('La operaci√≥n est√° tardando m√°s de lo esperado. Por favor, intenta de nuevo.');\n                return;\n            }\n            \n            const response = await fetch('/api/recommendations/progress');\n            if (!response.ok) {\n                console.error('Progress fetch failed:', response.status);\n                return;\n            }\n            \n            const progress = await response.json();\n            \n            if (progress.status === 'processing' && progress.total > 0) {\n                const statusMsg = `Procesando artista ${progress.current} de ${progress.total}`;\n                updateProgressUI(\n                    progress.current, \n                    progress.total, \n                    statusMsg,\n                    progress.current_artist || ''\n                );\n            } else if (progress.status === 'completed' || progress.status === 'idle') {\n                stopProgressMonitoring();\n            } else if (progress.status === 'error') {\n                stopProgressMonitoring();\n                hideProgressModal();\n                alert('Hubo un error al procesar las recomendaciones. Por favor, intenta de nuevo.');\n            }\n        } catch (error) {\n            console.error('Error fetching progress:', error);\n        }\n    }, 500);\n}\n\nfunction stopProgressMonitoring() {\n    if (progressInterval) {\n        clearInterval(progressInterval);\n        progressInterval = null;\n        progressPollCount = 0;\n    }\n}\n\n// Load recommendations (without pricing) - Spotify only\nasync function loadRecommendations() {\n    showLoading(true);\n    \n    try {\n        const response = await fetch('/recommend-vinyl');\n        const data = await response.json();\n        \n        if (data.albums && data.albums.length > 0) {\n            localStorage.setItem('last_recommendations', JSON.stringify(data.albums));\n            localStorage.setItem('last_updated', new Date().toISOString());\n            localStorage.setItem('has_spotify_connected', 'true');\n            renderRecommendations(data.albums);\n        } else {\n            showLoading(false);\n            alert('No se encontraron recomendaciones. Por favor, intenta de nuevo.');\n        }\n    } catch (error) {\n        console.error('Error loading recommendations:', error);\n        showLoading(false);\n        alert('Error al cargar recomendaciones. Por favor, intenta de nuevo.');\n    }\n}\n\n// Load all recommendations from Spotify and Last.fm\nasync function loadAllRecommendations() {\n    showLoading(true, 'Cargando recomendaciones desde todas las fuentes...');\n    \n    try {\n        const hasSpotify = localStorage.getItem('has_spotify_connected') === 'true';\n        const hasLastfm = localStorage.getItem('has_lastfm_connected') === 'true';\n        \n        const promises = [];\n        \n        if (hasSpotify) {\n            promises.push(\n                fetch('/recommend-vinyl')\n                    .then(res => res.json())\n                    .catch(err => {\n                        console.error('Spotify recommendations failed:', err);\n                        return { albums: [] };\n                    })\n            );\n        } else {\n            promises.push(Promise.resolve({ albums: [] }));\n        }\n        \n        if (hasLastfm) {\n            const lastfmUsername = localStorage.getItem('lastfm_username');\n            if (lastfmUsername) {\n                promises.push(\n                    fetch('/api/lastfm/recommendations', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify({ time_range: 'medium_term', username: lastfmUsername })\n                    })\n                        .then(res => res.json())\n                        .then(data => {\n                            const albums = data.albums || [];\n                            albums.forEach(album => {\n                                album.source = 'lastfm';\n                            });\n                            return { albums };\n                        })\n                        .catch(err => {\n                            console.error('Last.fm recommendations failed:', err);\n                            return { albums: [] };\n                        })\n                );\n            } else {\n                promises.push(Promise.resolve({ albums: [] }));\n            }\n        } else {\n            promises.push(Promise.resolve({ albums: [] }));\n        }\n        \n        const [spotifyData, lastfmData] = await Promise.all(promises);\n        \n        const spotifyAlbums = spotifyData.albums || [];\n        const lastfmAlbums = lastfmData.albums || [];\n        \n        if (spotifyAlbums.length === 0 && lastfmAlbums.length === 0) {\n            showLoading(false);\n            alert('No se encontraron recomendaciones. Por favor, conecta al menos una fuente.');\n            return;\n        }\n        \n        const mergedAlbums = await mergeRecommendationLists(spotifyAlbums, lastfmAlbums);\n        \n        localStorage.setItem('last_recommendations', JSON.stringify(mergedAlbums));\n        localStorage.setItem('last_updated', new Date().toISOString());\n        renderRecommendations(mergedAlbums);\n        \n    } catch (error) {\n        console.error('Error loading all recommendations:', error);\n        showLoading(false);\n        alert('Error al cargar recomendaciones. Por favor, intenta de nuevo.');\n    }\n}\n\n// Merge recommendation lists from multiple sources with deduplication\nasync function mergeRecommendationLists(spotifyAlbums, lastfmAlbums, artistAlbums = []) {\n    try {\n        const response = await fetch('/api/recommendations/merge', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                spotify_recommendations: spotifyAlbums,\n                lastfm_recommendations: lastfmAlbums,\n                artist_recommendations: artistAlbums\n            })\n        });\n        \n        const data = await response.json();\n        return data.recommendations || [];\n    } catch (error) {\n        console.error('Error merging recommendations:', error);\n        return [...spotifyAlbums, ...lastfmAlbums, ...artistAlbums];\n    }\n}\n\n// Load mixed recommendations (artists + Spotify)\nasync function loadMixedRecommendations(artistNames) {\n    startProgressMonitoring('Combinando Recomendaciones');\n    \n    try {\n        const response = await fetch('/api/recommendations/artists', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                artist_names: artistNames,\n                spotify_token: true\n            })\n        });\n        \n        const data = await response.json();\n        \n        stopProgressMonitoring();\n        hideProgressModal();\n        \n        if (data.recommendations && data.recommendations.length > 0) {\n            const formattedRecs = formatArtistRecommendations(data.recommendations);\n            localStorage.setItem('last_recommendations', JSON.stringify(formattedRecs));\n            localStorage.setItem('last_updated', new Date().toISOString());\n            localStorage.setItem('has_spotify_connected', 'true');\n            renderRecommendations(formattedRecs);\n        } else {\n            alert('No se encontraron recomendaciones. Por favor, intenta de nuevo.');\n        }\n    } catch (error) {\n        console.error('Error loading mixed recommendations:', error);\n        stopProgressMonitoring();\n        hideProgressModal();\n        alert('Error al cargar recomendaciones. Por favor, intenta de nuevo.');\n    }\n}\n\nlet allRecommendations = [];\nlet currentFilter = 'all';\n\n// Render recommendations grid (fast, no pricing calls)\nfunction renderRecommendations(recommendations) {\n    allRecommendations = recommendations;\n    \n    document.getElementById('landing-view').style.display = 'none';\n    document.getElementById('album-detail-view').style.display = 'none';\n    document.getElementById('recommendations-view').classList.add('active');\n    \n    const hasArtistBased = recommendations.some(rec => rec.source === 'artist_based');\n    const hasLastfmBased = recommendations.some(rec => rec.source === 'lastfm');\n    const hasSpotifyBased = recommendations.some(rec => !rec.source || (rec.source !== 'artist_based' && rec.source !== 'lastfm'));\n    const hasSpotifyConnected = localStorage.getItem('has_spotify_connected') === 'true';\n    \n    const spotifyBtn = document.getElementById('spotify-connect-btn');\n    const artistSearchBtn = document.getElementById('artist-search-header-btn');\n    const lastfmFilterBtn = document.querySelector('.filter-btn[data-filter=\"lastfm\"]');\n    \n    if (lastfmFilterBtn) {\n        lastfmFilterBtn.style.display = hasLastfmBased ? 'inline-block' : 'none';\n    }\n    \n    if (hasArtistBased && !hasSpotifyBased && !hasSpotifyConnected) {\n        spotifyBtn.style.display = 'inline-flex';\n        document.getElementById('last-updated').textContent = 'Basado en tus artistas seleccionados';\n    } else {\n        spotifyBtn.style.display = 'none';\n        updateLastUpdatedText();\n    }\n    \n    artistSearchBtn.style.display = 'inline-flex';\n    \n    const filterButtons = document.querySelectorAll('.filter-btn');\n    if (filterButtons.length > 0) {\n        filterButtons.forEach(btn => {\n            btn.classList.remove('active');\n        });\n        const activeBtn = document.querySelector(`.filter-btn[data-filter=\"${currentFilter}\"]`);\n        if (activeBtn) {\n            activeBtn.classList.add('active');\n        }\n    }\n    \n    let filtered;\n    if (currentFilter === 'all') {\n        filtered = allRecommendations;\n    } else if (currentFilter === 'spotify') {\n        filtered = allRecommendations.filter(rec => !rec.source || rec.source !== 'artist_based');\n    } else if (currentFilter === 'artists') {\n        filtered = allRecommendations.filter(rec => rec.source === 'artist_based');\n    } else {\n        filtered = allRecommendations;\n    }\n    \n    displayFilteredRecommendations(filtered);\n    \n    showLoading(false);\n}\n\nfunction displayFilteredRecommendations(recommendations) {\n    const container = document.getElementById('albums-container');\n    container.innerHTML = '';\n    \n    recommendations.forEach(rec => {\n        const card = createAlbumCard(rec);\n        container.appendChild(card);\n    });\n}\n\nfunction filterRecommendations(filter) {\n    currentFilter = filter;\n    \n    document.querySelectorAll('.filter-btn').forEach(btn => {\n        btn.classList.remove('active');\n    });\n    document.querySelector(`.filter-btn[data-filter=\"${filter}\"]`).classList.add('active');\n    \n    let filtered;\n    if (filter === 'all') {\n        filtered = allRecommendations;\n    } else if (filter === 'spotify') {\n        filtered = allRecommendations.filter(rec => !rec.source || (rec.source !== 'artist_based' && rec.source !== 'lastfm'));\n    } else if (filter === 'lastfm') {\n        filtered = allRecommendations.filter(rec => rec.source === 'lastfm');\n    } else if (filter === 'artists') {\n        filtered = allRecommendations.filter(rec => rec.source === 'artist_based');\n    }\n    \n    displayFilteredRecommendations(filtered);\n}\n\n// Create album card (no pricing data yet)\nfunction createAlbumCard(rec) {\n    let artist, album, cover;\n    \n    if (rec.source === 'artist_based' || rec.source === 'lastfm') {\n        artist = rec.artist_name || 'Unknown Artist';\n        album = rec.album_name || 'Unknown Album';\n        cover = rec.cover_url || rec.image_url || 'https://via.placeholder.com/300x300?text=No+Cover';\n    } else {\n        const albumInfo = rec.album_info || {};\n        artist = albumInfo.artists?.[0]?.name || 'Unknown Artist';\n        album = albumInfo.name || 'Unknown Album';\n        cover = albumInfo.images?.[0]?.url || 'https://via.placeholder.com/300x300?text=No+Cover';\n    }\n    \n    const card = document.createElement('div');\n    card.className = 'album-card';\n    card.innerHTML = `\n        <img src=\"${cover}\" alt=\"${album}\" class=\"album-cover\" loading=\"lazy\" onerror=\"this.src='https://via.placeholder.com/300x300?text=No+Cover'\">\n        <div class=\"album-info\">\n            <div class=\"album-title\">${album}</div>\n            <div class=\"album-artist\">${artist}</div>\n        </div>\n    `;\n    \n    card.addEventListener('click', () => {\n        openAlbumDetail(rec);\n    });\n    \n    return card;\n}\n\n// Open album detail page\nasync function openAlbumDetail(rec) {\n    let artist, album, cover, spotifyUrl;\n    \n    if (rec.source === 'artist_based' || rec.source === 'lastfm') {\n        artist = rec.artist_name || 'Unknown Artist';\n        album = rec.album_name || 'Unknown Album';\n        cover = rec.cover_url || rec.image_url || 'https://via.placeholder.com/300x300?text=No+Cover';\n        spotifyUrl = null;\n    } else {\n        const albumInfo = rec.album_info || {};\n        artist = albumInfo.artists?.[0]?.name || 'Unknown Artist';\n        album = albumInfo.name || 'Unknown Album';\n        cover = albumInfo.images?.[0]?.url || 'https://via.placeholder.com/300x300?text=No+Cover';\n        spotifyUrl = albumInfo.external_urls?.spotify || null;\n    }\n    \n    document.getElementById('recommendations-view').classList.remove('active');\n    document.getElementById('album-detail-view').style.display = 'block';\n    \n    document.getElementById('detail-cover').src = cover;\n    document.getElementById('detail-title').textContent = album;\n    document.getElementById('detail-artist').textContent = artist;\n    \n    const pricingContainer = document.getElementById('detail-pricing');\n    pricingContainer.innerHTML = `\n        <div class=\"spinner-small\"></div>\n        <p style=\"text-align: center; color: var(--text-secondary); margin-top: 1rem;\">Cargando informaci√≥n...</p>\n    `;\n    \n    try {\n        const pricingData = await fetchPricing(artist, album);\n        pricingContainer.innerHTML = renderDetailPricing(pricingData, spotifyUrl);\n    } catch (error) {\n        console.error('Error fetching pricing:', error);\n        pricingContainer.innerHTML = '<p class=\"error-text\">No se pudo cargar la informaci√≥n</p>';\n    }\n}\n\n// Go back to recommendations\nfunction backToRecommendations() {\n    document.getElementById('album-detail-view').style.display = 'none';\n    document.getElementById('recommendations-view').classList.add('active');\n}\n\n// Render pricing in detail view\nfunction renderDetailPricing(pricing, spotifyUrl) {\n    let html = '';\n    \n    // Spotify link\n    if (spotifyUrl) {\n        html += `\n            <a href=\"${spotifyUrl}\" target=\"_blank\" class=\"btn-primary\" style=\"background: #1DB954; margin-bottom: 1rem;\">\n                ‚ñ∂Ô∏è Escuchar en Spotify\n            </a>\n        `;\n    }\n    \n    // Discogs information section\n    if (pricing.discogs_type) {\n        const typeLabel = pricing.discogs_type === 'master' ? 'Master' : 'Release';\n        html += `<div class=\"info-message\">‚ÑπÔ∏è Encontrado en Discogs como ${typeLabel}</div>`;\n    } else if (pricing.discogs_url === null && pricing.discogs_id === null) {\n        html += `<div class=\"info-message warning\">‚ö†Ô∏è No se encontr√≥ este √°lbum en Discogs</div>`;\n    }\n    \n    // Tracklist section\n    if (pricing.tracklist && pricing.tracklist.length > 0) {\n        html += '<div class=\"tracklist-section\"><h3>Lista de Canciones</h3><ol class=\"tracklist\">';\n        pricing.tracklist.forEach(track => {\n            const duration = track.duration ? ` <span class=\"duration\">${track.duration}</span>` : '';\n            html += `<li><span>${track.title}</span>${duration}</li>`;\n        });\n        html += '</ol></div>';\n    } else if (pricing.discogs_type) {\n        html += `<div class=\"info-message warning\">‚ö†Ô∏è No se encontr√≥ tracklist en Discogs</div>`;\n    }\n    \n    // eBay price section\n    if (pricing.ebay_offer) {\n        const url = pricing.ebay_offer.url || '#';\n        const totalPrice = pricing.ebay_offer.total_price || 'N/A';\n        \n        html += `\n            <div class=\"price-highlight\">\n                <div class=\"price-label\">Mejor precio eBay (EU)</div>\n                <div class=\"price-value\">${totalPrice} EUR</div>\n                <a href=\"${url}\" target=\"_blank\" class=\"btn-primary\">\n                    üõí Comprar en eBay\n                </a>\n            </div>\n        `;\n    } else {\n        html += `<div class=\"info-message\">‚ÑπÔ∏è No hay ofertas de eBay disponibles en este momento</div>`;\n    }\n    \n    // Discogs marketplace link\n    if (pricing.discogs_sell_url) {\n        html += `\n            <a href=\"${pricing.discogs_sell_url}\" target=\"_blank\" class=\"btn-secondary\">\n                üéµ Ver marketplace en Discogs\n            </a>\n        `;\n    }\n    \n    // Discogs detail link\n    if (pricing.discogs_url) {\n        html += `\n            <a href=\"${pricing.discogs_url}\" target=\"_blank\" class=\"btn-secondary\">\n                üìñ Ver detalles en Discogs\n            </a>\n        `;\n    }\n    \n    // Local stores section\n    if (pricing.local_stores && typeof pricing.local_stores === 'object') {\n        const storeNames = {\n            'marilians': 'Marilians',\n            'bajo_el_volcan': 'Bajo el Volc√°n',\n            'bora_bora': 'Bora Bora',\n            'revolver': 'Revolver Records'\n        };\n        \n        const storeEntries = Object.entries(pricing.local_stores);\n        if (storeEntries.length > 0) {\n            html += '<div class=\"stores-section\"><h3>Tiendas Locales en Madrid</h3>';\n            storeEntries.forEach(([key, url]) => {\n                const name = storeNames[key] || key;\n                html += `\n                    <a href=\"${url}\" target=\"_blank\" class=\"store-link\">\n                        üè™ ${name}\n                    </a>\n                `;\n            });\n            html += '</div>';\n        }\n    }\n    \n    return html;\n}\n\n// Fetch pricing for an album\nasync function fetchPricing(artist, album) {\n    const response = await fetch(`/album-pricing/${encodeURIComponent(artist)}/${encodeURIComponent(album)}`);\n    if (!response.ok) {\n        throw new Error('Failed to fetch pricing');\n    }\n    return await response.json();\n}\n\n// Update last updated text\nfunction updateLastUpdatedText() {\n    const lastUpdated = localStorage.getItem('last_updated');\n    if (lastUpdated) {\n        const date = new Date(lastUpdated);\n        const now = new Date();\n        const diffMs = now - date;\n        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n        const diffMins = Math.floor(diffMs / (1000 * 60));\n        \n        let timeText = '';\n        if (diffHours > 0) {\n            timeText = `Actualizado hace ${diffHours} hora${diffHours > 1 ? 's' : ''}`;\n        } else if (diffMins > 0) {\n            timeText = `Actualizado hace ${diffMins} minuto${diffMins > 1 ? 's' : ''}`;\n        } else {\n            timeText = 'Actualizado hace un momento';\n        }\n        \n        document.getElementById('last-updated').textContent = `Basado en tu escucha. ${timeText}`;\n    }\n}\n\n// Check if user has cached recommendations\nfunction checkCachedRecommendations() {\n    const cached = localStorage.getItem('last_recommendations');\n    \n    if (cached) {\n        const recommendations = JSON.parse(cached);\n        renderRecommendations(recommendations);\n    }\n}\n\n// Artist Search Modal\nlet artistSearchComponent = null;\n\nfunction openArtistSearch() {\n    const modal = document.getElementById('artist-search-modal');\n    modal.classList.add('active');\n    \n    if (!artistSearchComponent) {\n        artistSearchComponent = new ArtistSearch('artist-search-container', {\n            minArtists: 3,\n            maxArtists: 10,\n            onContinue: handleArtistSelection\n        });\n        \n        const savedArtistNames = localStorage.getItem('selected_artist_names');\n        if (savedArtistNames) {\n            try {\n                const artistNames = JSON.parse(savedArtistNames);\n                console.log(`‚úì Restoring ${artistNames.length} previously selected artists:`, artistNames);\n                artistSearchComponent.restoreArtists(artistNames);\n            } catch (e) {\n                console.error('Error restoring artists:', e);\n            }\n        }\n    }\n}\n\nfunction closeArtistSearch() {\n    const modal = document.getElementById('artist-search-modal');\n    modal.classList.remove('active');\n}\n\nasync function handleArtistSelection(selectedArtists) {\n    const artistNames = selectedArtists.map(a => a.name);\n    localStorage.setItem('selected_artist_names', JSON.stringify(artistNames));\n    \n    const hasSpotifyConnected = localStorage.getItem('has_spotify_connected') === 'true';\n    \n    if (!artistSearchComponent) {\n        console.error('Artist search component not available');\n        closeArtistSearch();\n        alert('Error: el componente de b√∫squeda no est√° disponible. Por favor, intenta de nuevo.');\n        return;\n    }\n    \n    if (artistSearchComponent.pendingPromises.size > 0) {\n        console.log(`‚è≥ Waiting for ${artistSearchComponent.pendingPromises.size} pending recommendations...`);\n        showLoading(true, 'Finalizando recomendaciones...');\n        await artistSearchComponent.waitForAllPendingRecommendations();\n        showLoading(false);\n    }\n    \n    closeArtistSearch();\n    \n    const loadingStatus = artistSearchComponent.getLoadingStatus();\n    const cachedRecs = artistSearchComponent.getCachedRecommendations();\n    \n    console.log(`Cache status: ${cachedRecs.length} recommendations, ${loadingStatus.success}/${loadingStatus.total} successful, ${loadingStatus.error} errors, all successful: ${loadingStatus.hasAllSuccessful}`);\n    \n    if (!hasSpotifyConnected && loadingStatus.hasAllSuccessful && cachedRecs.length > 0) {\n        console.log('‚úì Using cached artist recommendations (no Spotify merge needed, all successful)');\n        const formattedRecs = formatArtistRecommendations(cachedRecs);\n        localStorage.setItem('last_recommendations', JSON.stringify(formattedRecs));\n        localStorage.setItem('last_updated', new Date().toISOString());\n        renderRecommendations(formattedRecs);\n        return;\n    }\n    \n    if (loadingStatus.error > 0) {\n        console.log(`‚ö† ${loadingStatus.error} artists failed to load, falling back to backend generation`);\n    }\n    \n    const title = hasSpotifyConnected ? 'Combinando Recomendaciones' : 'Generando Recomendaciones';\n    startProgressMonitoring(title);\n    \n    try {\n        const response = await fetch('/api/recommendations/artists', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                artist_names: artistNames,\n                spotify_token: hasSpotifyConnected ? true : null\n            })\n        });\n        \n        const data = await response.json();\n        \n        stopProgressMonitoring();\n        hideProgressModal();\n        \n        if (data.recommendations && data.recommendations.length > 0) {\n            const formattedRecs = formatArtistRecommendations(data.recommendations);\n            localStorage.setItem('last_recommendations', JSON.stringify(formattedRecs));\n            localStorage.setItem('last_updated', new Date().toISOString());\n            renderRecommendations(formattedRecs);\n        } else {\n            alert('No se encontraron recomendaciones para estos artistas.');\n        }\n    } catch (error) {\n        console.error('Error loading artist recommendations:', error);\n        stopProgressMonitoring();\n        hideProgressModal();\n        alert('Error al cargar recomendaciones. Por favor, intenta de nuevo.');\n    }\n}\n\nfunction formatArtistRecommendations(recommendations) {\n    return recommendations.map(rec => {\n        if (rec.source === 'artist_based') {\n            return {\n                album_name: rec.album_name,\n                artist_name: rec.artist_name,\n                image_url: rec.image_url,\n                discogs_master_id: rec.discogs_master_id,\n                rating: rec.rating,\n                votes: rec.votes,\n                year: rec.year,\n                source: 'artist_based'\n            };\n        }\n        return rec;\n    });\n}\n\n// Initialize\ndocument.addEventListener('DOMContentLoaded', () => {\n    initTheme();\n    handleSpotifyCallback();\n    handleLastfmCallback();\n    checkCachedRecommendations();\n});\n","size_bytes":34349},"tests/discogs_studio_masters.py":{"content":"# -*- coding: utf-8 -*-\n\"\"\"\ndiscogs_studio_masters.py (versi√≥n simplificada)\n\nHelpers para trabajar con Discogs centrados en VINILO, usando la API\n`/database/search` con:\n\n- format=Vinyl\n- type=release\n\nAPI pensada para usar desde la UI / servicios:\n\n- search_master(artist, title, key, secret) -> dict | None\n    Busca un master por artista + t√≠tulo.\n\n- collect_releases_from_master(master_id, key, secret) -> list[dict]\n    Releases (en vinilo) asociadas a un master_id.\n\n- search_releases(artist, title, key, secret) -> list[dict]\n    Releases (en vinilo) por artista + t√≠tulo.\n\n- discogs_dataframe(rows, official_only, es_europe_only) -> pd.DataFrame\n    Aplica filtros ligeros (oficial / Spain+Europe) y devuelve un DataFrame.\n\nTambi√©n incluye un CLI opcional:\n    python discogs_studio_masters.py --artist \"JW Francis\" --title \"Sunshine\"\n\"\"\"\n\nfrom typing import Any, Dict, List, Optional\n\nimport argparse\nimport time\n\nimport httpx\nimport pandas as pd\n\n# =========================\n# Config\n# =========================\n\nDISCOGS_KEY = \"QiaraVlzXNSUJOpkdKdK\"\nDISCOGS_SECRET = \"BssuhxnAECuSXYoFYPzIuSUixhVXRedG\"\nUSER_AGENT = \"Vinilogy/1.0 (+https://vinilogy.com)\"\nBASE_URL = \"https://api.discogs.com\"\n\n\n# =========================\n# HTTP helpers\n# =========================\n\ndef _client() -> httpx.Client:\n    \"\"\"Cliente HTTP reutilizable.\"\"\"\n    timeout = httpx.Timeout(20.0, connect=20.0)\n    headers = {\"User-Agent\": USER_AGENT}\n    return httpx.Client(timeout=timeout, headers=headers, follow_redirects=True)\n\n\ndef _get_json(\n    client: httpx.Client,\n    path: str,\n    params: Optional[Dict[str, Any]] = None,\n    max_retries: int = 4,\n    sleep_between: float = 0.6,\n) -> Dict[str, Any]:\n    \"\"\"Wrapper con reintentos para peticiones Discogs.\"\"\"\n    url = f\"{BASE_URL}{path}\"\n    backoff = sleep_between\n    last_exc: Optional[Exception] = None\n\n    for _ in range(max_retries):\n        try:\n            r = client.get(url, params=params)\n            if r.status_code == 429:\n                # rate limit ‚Üí esperamos y reintentamos\n                time.sleep(backoff)\n                backoff = min(backoff * 2, 6.0)\n                continue\n            r.raise_for_status()\n            return r.json()\n        except httpx.HTTPError as e:\n            last_exc = e\n            time.sleep(backoff)\n            backoff = min(backoff * 2, 6.0)\n\n    if last_exc:\n        raise last_exc\n    return {}\n\n\ndef _search_discogs(\n    extra_params: Dict[str, Any],\n    per_page: int = 100,\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Helper gen√©rico para /database/search con paginaci√≥n.\n    Devuelve la lista de 'results'.\n    \"\"\"\n    out: List[Dict[str, Any]] = []\n    page = 1\n\n    with _client() as client:\n        while True:\n            params = {\n                \"per_page\": per_page,\n                \"page\": page,\n                \"key\": DISCOGS_KEY,\n                \"secret\": DISCOGS_SECRET,\n                **extra_params,\n            }\n            data = _get_json(client, \"/database/search\", params)\n            results = data.get(\"results\", []) or []\n            out.extend(results)\n\n            pag = data.get(\"pagination\") or {}\n            pages = pag.get(\"pages\", 1) or 1\n            if page >= pages:\n                break\n\n            page += 1\n            time.sleep(0.3)\n\n    return out\n\n\ndef _normalize_year(raw) -> Optional[int]:\n    if isinstance(raw, int):\n        return raw\n    if isinstance(raw, str) and raw:\n        try:\n            return int(raw[:4])\n        except Exception:\n            return None\n    return None\n\n\ndef _safe_str(val: Any) -> str:\n    if val is None:\n        return \"\"\n    return str(val)\n\n\n# =========================\n# Public helpers (para UI/servicios)\n# =========================\n\ndef search_master(\n    artist: str,\n    title: str,\n    key: str = None,\n    secret: str = None,\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Devuelve el primer master que coincida (o None) para Artista + T√≠tulo.\n\n    No filtra por vinilo; solo sirve para obtener un master_id razonable.\n    \"\"\"\n    params = {\n        \"type\": \"master\",\n        \"artist\": artist,\n        \"release_title\": title,\n        \"per_page\": 20,\n        \"page\": 1,\n        \"key\": key or DISCOGS_KEY,\n        \"secret\": secret or DISCOGS_SECRET,\n    }\n    with _client() as client:\n        data = _get_json(client, \"/database/search\", params)\n\n    results = data.get(\"results\", []) or []\n    if not results:\n        return None\n\n    tnorm = (title or \"\").strip().lower()\n    exact = [\n        r for r in results\n        if _safe_str(r.get(\"title\", \"\")).lower().endswith(f\" - {tnorm}\")\n    ]\n    return exact[0] if exact else results[0]\n\n\ndef collect_releases_from_master(\n    master_id: int,\n    key: str = None,\n    secret: str = None,\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Releases (en vinilo) asociadas a un master_id.\n\n    Implementado mediante /database/search con:\n      - type=release\n      - master_id=...\n      - format=Vinyl\n    \"\"\"\n    params = {\n        \"type\": \"release\",\n        \"master_id\": master_id,\n        \"format\": \"Vinyl\",\n    }\n    results = _search_discogs(params, per_page=100)\n\n    rows: List[Dict[str, Any]] = []\n    for r in results:\n        year = _normalize_year(r.get(\"year\"))\n        fmt = r.get(\"format\")\n        if isinstance(fmt, list):\n            fmt_str = \", \".join(str(x) for x in fmt)\n        else:\n            fmt_str = _safe_str(fmt)\n\n        label = r.get(\"label\")\n        if isinstance(label, list):\n            label_str = \", \".join(str(x) for x in label)\n        else:\n            label_str = _safe_str(label)\n\n        rows.append(\n            {\n                \"release_id\": r.get(\"id\"),\n                \"title\": r.get(\"title\"),\n                \"format\": fmt_str,\n                \"country\": r.get(\"country\"),\n                \"label\": label_str,\n                \"catno\": r.get(\"catno\"),\n                \"year\": year,\n                \"source\": \"search.by_master\",\n            }\n        )\n    return rows\n\n\ndef search_releases(\n    artist: str,\n    title: str,\n    key: str = None,\n    secret: str = None,\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Releases (en vinilo) por artista + t√≠tulo, usando:\n\n      type=release\n      format=Vinyl\n\n    Sirve tanto para la UI (Streamlit) como para un endpoint.\n    \"\"\"\n    params = {\n        \"type\": \"release\",\n        \"artist\": artist,\n        \"release_title\": title,\n        \"format\": \"Vinyl\",\n    }\n    results = _search_discogs(params, per_page=100)\n\n    tnorm = (title or \"\").strip().lower()\n    rows: List[Dict[str, Any]] = []\n    for r in results:\n        year = _normalize_year(r.get(\"year\"))\n        fmt = r.get(\"format\")\n        if isinstance(fmt, list):\n            fmt_str = \", \".join(str(x) for x in fmt)\n        else:\n            fmt_str = _safe_str(fmt)\n\n        label = r.get(\"label\")\n        if isinstance(label, list):\n            label_str = \", \".join(str(x) for x in label)\n        else:\n            label_str = _safe_str(label)\n\n        rows.append(\n            {\n                \"release_id\": r.get(\"id\"),\n                \"title\": r.get(\"title\"),\n                \"format\": fmt_str,\n                \"country\": r.get(\"country\"),\n                \"label\": label_str,\n                \"catno\": r.get(\"catno\"),\n                \"year\": year,\n                \"source\": \"search.by_artist_title\",\n                \"_exact_title\": _safe_str(r.get(\"title\", \"\")).lower().endswith(\n                    f\" - {tnorm}\"\n                ),\n            }\n        )\n\n    # Orden: coincidencias exactas primero, luego por a√±o / pa√≠s\n    rows.sort(\n        key=lambda x: (\n            0 if x.get(\"_exact_title\") else 1,\n            x.get(\"year\") if x.get(\"year\") is not None else 9999,\n            _safe_str(x.get(\"country\")),\n        )\n    )\n    for r in rows:\n        r.pop(\"_exact_title\", None)\n    return rows\n\n\n# =========================\n# Filtros + DataFrame para UI\n# =========================\n\ndef _is_unofficial(fmt: Optional[str]) -> bool:\n    if not fmt:\n        return False\n    f = fmt.lower()\n    return \"unofficial release\" in f or \"unofficial\" in f\n\n\ndef _is_es_or_europe(country: Optional[str]) -> bool:\n    if not country:\n        return False\n    c = country.strip().lower()\n    return c == \"spain\" or \"europe\" in c\n\n\ndef discogs_dataframe(\n    rows: List[Dict[str, Any]],\n    official_only: bool,\n    es_europe_only: bool,\n) -> pd.DataFrame:\n    \"\"\"\n    Aplica filtros ligeros sobre la lista de releases y devuelve un DataFrame:\n      - official_only: excluye \"Unofficial Release\" en el campo format\n      - es_europe_only: solo country = Spain o que contenga 'Europe'\n    Ojo: ya asumimos que 'rows' solo contiene vinilos (format=Vinyl en la b√∫squeda).\n    \"\"\"\n    filtered = list(rows)\n\n    if official_only:\n        filtered = [r for r in filtered if not _is_unofficial(r.get(\"format\"))]\n\n    if es_europe_only:\n        filtered = [r for r in filtered if _is_es_or_europe(r.get(\"country\"))]\n\n    filtered.sort(\n        key=lambda x: (\n            x.get(\"year\") if x.get(\"year\") is not None else 9999,\n            _safe_str(x.get(\"country\")),\n            _safe_str(x.get(\"catno\")),\n        )\n    )\n\n    cols = [\"release_id\", \"year\", \"format\", \"country\", \"label\", \"catno\", \"title\", \"source\"]\n    return pd.DataFrame(filtered, columns=cols)\n\n\n# =========================\n# CLI opcional (para probar r√°pido)\n# =========================\n\ndef _cli() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Discogs helpers simplificados (solo vinilo) ‚Äì CLI de prueba\"\n    )\n    parser.add_argument(\"--artist\", help=\"Nombre del artista\")\n    parser.add_argument(\"--title\", help=\"T√≠tulo del √°lbum\")\n    parser.add_argument(\"--master-id\", type=int, help=\"Discogs master_id\")\n    args = parser.parse_args()\n\n    if args.master_id:\n        print(f\"Buscando releases en vinilo para master_id={args.master_id}...\\n\")\n        rows = collect_releases_from_master(args.master_id)\n    else:\n        if not (args.artist and args.title):\n            parser.error(\"Debes indicar --artist y --title si no usas --master-id\")\n        print(f'Buscando releases en vinilo para \"{args.artist}\" ‚Äì \"{args.title}\"...\\n')\n        rows = search_releases(args.artist, args.title)\n\n    df = discogs_dataframe(rows, official_only=False, es_europe_only=False)\n    if df.empty:\n        print(\"Sin resultados.\")\n        return\n\n    print(df.to_string(index=False))\n\n\nif __name__ == \"__main__\":\n    _cli()\n","size_bytes":10396},"libs/shared/__init__.py":{"content":"from .models import (\n    Track,\n    Artist,\n    Album,\n    DiscogsRelease,\n    DiscogsStats,\n    ScoredTrack,\n    ScoredArtist,\n    AlbumRecommendation,\n    ServiceHealth,\n    LogEvent,\n)\nfrom .utils import create_http_client, log_event\n\n__all__ = [\n    \"Track\",\n    \"Artist\",\n    \"Album\",\n    \"DiscogsRelease\",\n    \"DiscogsStats\",\n    \"ScoredTrack\",\n    \"ScoredArtist\",\n    \"AlbumRecommendation\",\n    \"ServiceHealth\",\n    \"LogEvent\",\n    \"create_http_client\",\n    \"log_event\",\n]\n","size_bytes":481},"services/pricing/pricing_client.py":{"content":"from typing import Optional, Dict, Any, List\nimport os\nimport httpx\nfrom libs.shared.utils import log_event\n\nEBAY_OAUTH_URL = \"https://api.ebay.com/identity/v1/oauth2/token\"\nEBAY_BROWSE_URL = \"https://api.ebay.com/buy/browse/v1/item_summary/search\"\nVINYL_CATEGORY_ID = \"176985\"\n\nEU_COUNTRIES = \"AT,BE,BG,HR,CY,CZ,DK,EE,FI,FR,DE,GR,HU,IE,IT,LV,LT,LU,MT,NL,PL,PT,RO,SK,SI,ES,SE\"\n\n\ndef normalize(text: str) -> str:\n    \"\"\"Normaliza strings para comparaciones simples.\"\"\"\n    return (\n        text.lower()\n        .replace(\",\", \" \")\n        .replace(\"-\", \" \")\n        .replace(\"_\", \" \")\n        .strip()\n    )\n\n\nclass PricingClient:\n    def __init__(self):\n        self.client_id = os.getenv(\"EBAY_CLIENT_ID\")\n        self.client_secret = os.getenv(\"EBAY_CLIENT_SECRET\")\n        \n        if not self.client_id or not self.client_secret:\n            raise RuntimeError(\n                \"EBAY_CLIENT_ID y EBAY_CLIENT_SECRET deben estar en variables de entorno\"\n            )\n        \n        self.http_client: Optional[httpx.AsyncClient] = None\n        self.access_token: Optional[str] = None\n\n    async def start(self):\n        \"\"\"Inicializa el cliente HTTP as√≠ncrono.\"\"\"\n        self.http_client = httpx.AsyncClient(timeout=20.0)\n        await self._get_access_token()\n\n    async def stop(self):\n        \"\"\"Cierra el cliente HTTP.\"\"\"\n        if self.http_client:\n            await self.http_client.aclose()\n\n    def is_ready(self) -> bool:\n        \"\"\"Verifica si el cliente est√° listo.\"\"\"\n        return self.http_client is not None and self.access_token is not None\n\n    async def _get_access_token(self) -> str:\n        \"\"\"Obtiene un application access token de eBay usando client credentials.\"\"\"\n        auth = (self.client_id, self.client_secret)\n        data = {\n            \"grant_type\": \"client_credentials\",\n            \"scope\": \"https://api.ebay.com/oauth/api_scope\",\n        }\n\n        resp = await self.http_client.post(\n            EBAY_OAUTH_URL,\n            auth=auth,\n            data=data,\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        )\n        resp.raise_for_status()\n        payload = resp.json()\n        self.access_token = payload[\"access_token\"]\n        return self.access_token\n\n    def _pick_best_ebay_item(\n        self,\n        item_summaries: List[dict],\n        artist: str,\n        album: str,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Dado itemSummaries de eBay, devuelve el mejor item:\n          - t√≠tulo razonable (contenga artist y algo del √°lbum)\n          - precio total m√°s bajo (item + shipping)\n          - en EUR\n          - ubicado en la Uni√≥n Europea\n        \"\"\"\n        artist_n = normalize(artist)\n        album_n = normalize(album)\n        \n        # Lista de c√≥digos de pa√≠s UE para validaci√≥n\n        eu_country_codes = EU_COUNTRIES.split(\",\")\n\n        candidates: List[Dict[str, Any]] = []\n\n        for item in item_summaries:\n            # FILTRO DE UBICACI√ìN UE (defensa contra API que ignora itemLocationCountry)\n            item_location = item.get(\"itemLocation\", {})\n            item_country = item_location.get(\"country\")\n            \n            if not item_country or item_country not in eu_country_codes:\n                # Log warning cuando eBay devuelve item fuera de UE\n                if item_country:\n                    log_event(\n                        \"pricing-service\", \n                        \"WARNING\", \n                        f\"eBay returned non-EU item from {item_country}, filtering out\"\n                    )\n                continue\n            \n            title = item.get(\"title\", \"\")\n            title_n = normalize(title)\n\n            if not any(w for w in artist_n.split() if w in title_n):\n                continue\n\n            if all(word not in title_n for word in album_n.split() if word):\n                continue\n\n            if \"cd\" in title_n or \"cassette\" in title_n:\n                continue\n\n            price = item.get(\"price\", {})\n            ship_opts = item.get(\"shippingOptions\", [])\n\n            if not price or not ship_opts:\n                continue\n\n            if price.get(\"currency\") != \"EUR\":\n                continue\n\n            try:\n                item_price = float(price.get(\"value\", 0.0))\n            except (TypeError, ValueError):\n                continue\n\n            try:\n                ship_cost = float(\n                    ship_opts[0].get(\"shippingCost\", {}).get(\"value\", 0.0)\n                )\n            except (TypeError, ValueError, IndexError):\n                continue\n\n            total = item_price + ship_cost\n\n            candidates.append(\n                {\n                    \"provider\": \"ebay\",\n                    \"title\": title,\n                    \"item_price\": item_price,\n                    \"shipping_cost\": ship_cost,\n                    \"total_price\": total,\n                    \"currency\": price.get(\"currency\"),\n                    \"url\": item.get(\"itemWebUrl\"),\n                }\n            )\n\n        if not candidates:\n            return None\n\n        candidates.sort(key=lambda c: c[\"total_price\"])\n        return candidates[0]\n\n    async def fetch_best_ebay_offer(\n        self,\n        artist: str,\n        album: str,\n        marketplace_id: str = \"EBAY_ES\",\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Busca en eBay el vinilo de artist + album y devuelve la mejor oferta\n        (precio m√°s barato en EUR ubicado en la Uni√≥n Europea).\n        \"\"\"\n        if not self.access_token:\n            await self._get_access_token()\n\n        query = f\"{artist} {album}\"\n        params = {\n            \"q\": query,\n            \"category_ids\": VINYL_CATEGORY_ID,\n            \"filter\": f\"itemLocationCountry:{{{EU_COUNTRIES}}}\",\n            \"sort\": \"priceWithShipping\",\n            \"limit\": \"20\",\n        }\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.access_token}\",\n            \"X-EBAY-C-MARKETPLACE-ID\": marketplace_id,\n            \"Content-Type\": \"application/json\",\n        }\n\n        resp = await self.http_client.get(\n            EBAY_BROWSE_URL, params=params, headers=headers\n        )\n        resp.raise_for_status()\n        data = resp.json()\n        \n        items = data.get(\"itemSummaries\", [])\n        return self._pick_best_ebay_item(items, artist=artist, album=album)\n\n    def get_local_store_links(self, artist: str, album: str) -> dict:\n        \"\"\"Devuelve enlaces preparados para tiendas locales sin scraping.\"\"\"\n        query = f\"{artist} {album}\".replace(\" \", \"+\")\n\n        return {\n            \"marilians\": (\n                f\"https://www.marilians.com/busqueda?\"\n                f\"controller=search&s={query}\"\n            ),\n            \"bajo_el_volcan\": (\n                \"https://www.bajoelvolcan.es/busqueda/listaLibros.php?\"\n                f\"tipoBus=full&palabrasBusqueda={query}\"\n            ),\n            \"bora_bora\": f\"https://discosborabora.com/?s={query}\",\n            \"revolver\": (\n                f\"https://www.revolverrecords.es/?s={query}&post_type=product\"\n            ),\n        }\n","size_bytes":7055},"tests/mb_studio_vinyl.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nlastfm_artist_explorer.py\n\nApp TODO-en-uno (frontend + l√≥gica) para:\n\n- Buscar artistas en Last.fm mientras escribes (artist.search).\n- A√±adir artistas seleccionados.\n- Calcular sugerencias combinando artistas similares (v√≠a artist.getInfo).\n- Ver los discos de estudio (MusicBrainz) y rating de vinilo (Discogs) de cada artista.\n\nEjecutar con:\n\n    streamlit run lastfm_artist_explorer.py --server.port 8000 --server.address 0.0.0.0\n\"\"\"\n\nimport os\nimport re\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Tuple, Any\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\nimport httpx\nimport pandas as pd\nimport streamlit as st\n\n# =========================\n# Configuraci√≥n APIs\n# =========================\n\nLASTFM_API_KEY = os.getenv(\"LASTFM_API_KEY\")\nLASTFM_BASE_URL = \"https://ws.audioscrobbler.com/2.0/\"\n\nMB_BASE = \"https://musicbrainz.org/ws/2\"\nDISCOGS_BASE = \"https://api.discogs.com\"\n\nDISCOGS_KEY = os.getenv(\"DISCOGS_KEY\")\nDISCOGS_SECRET = os.getenv(\"DISCOGS_SECRET\")\n\nHEADERS = {\n    \"User-Agent\": \"Vinilogy/1.0 (+https://vinilogy.com; contact@vinilogy.com)\"\n}\n\n_RE_DISCOGS_MASTER = re.compile(\n    r\"https?://(?:www\\.)?discogs\\.com/(?:[a-z]{2}/)?master/(\\d+)\", re.I\n)\n\n# =========================\n# Cliente HTTP reutilizable (MB + Discogs)\n# =========================\n\nCLIENT = httpx.Client(\n    headers=HEADERS,\n    http2=False,\n    timeout=httpx.Timeout(30.0),\n    limits=httpx.Limits(max_connections=10, max_keepalive_connections=10),\n    follow_redirects=True,\n)\n\n# =========================\n# Modelos internos\n# =========================\n\n@dataclass\nclass Artist:\n    name: str\n    mbid: Optional[str] = None\n    image_url: Optional[str] = None\n\n\n# =========================\n# Cliente Last.fm\n# =========================\n\nclass LastFMClient:\n    \"\"\"\n    - search_artists -> artist.search (para autocompletar)\n    - get_artist_info -> artist.getInfo (info + similares)\n    - get_similar_artists -> usa get_artist_info internamente\n    \"\"\"\n\n    def __init__(self, api_key: str, base_url: str = LASTFM_BASE_URL) -> None:\n        self.api_key = api_key\n        self.base_url = base_url\n        # Cache sencilla para no repetir artist.getInfo\n        self.info_cache: Dict[str, Dict[str, Any]] = {}\n\n    def _build_params(self, method: str, extra: Optional[Dict[str, str]] = None) -> Dict[str, str]:\n        params = {\n            \"method\": method,\n            \"api_key\": self.api_key,\n            \"format\": \"json\",\n        }\n        if extra:\n            params.update(extra)\n        return params\n\n    # ---------- B√öSQUEDA POR TEXTO (artist.search) ----------\n\n    def search_artists(self, query: str, limit: int = 10) -> List[Artist]:\n        \"\"\"Last.fm artist.search (para sugerencias mientras se escribe).\"\"\"\n        if not query.strip():\n            return []\n\n        params = self._build_params(\n            \"artist.search\",\n            {\n                \"artist\": query,\n                \"limit\": str(limit),\n            },\n        )\n\n        try:\n            with httpx.Client(timeout=10.0) as client:\n                resp = client.get(self.base_url, params=params)\n            resp.raise_for_status()\n        except httpx.HTTPError as e:\n            st.error(f\"Error al consultar Last.fm (search): {e}\")\n            return []\n\n        data = resp.json()\n        results = data.get(\"results\", {}).get(\"artistmatches\", {}).get(\"artist\", [])\n\n        if isinstance(results, dict):\n            results = [results]\n\n        artists: List[Artist] = []\n        for item in results:\n            name = item.get(\"name\")\n            if not name:\n                continue\n            mbid = item.get(\"mbid\") or None\n            image_url = self._extract_best_image(item.get(\"image\"))\n            artists.append(Artist(name=name, mbid=mbid, image_url=image_url))\n        return artists\n\n    # ---------- artist.getInfo (info + similares) ----------\n\n    def get_artist_info(\n        self,\n        *,\n        name: Optional[str] = None,\n        mbid: Optional[str] = None,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Llama a artist.getInfo. Usa cache para evitar repetir llamadas.\n        \"\"\"\n        if not name and not mbid:\n            return None\n\n        if mbid:\n            cache_key = f\"mbid:{mbid}\"\n        else:\n            cache_key = f\"name:{name.lower()}\"\n\n        if cache_key in self.info_cache:\n            return self.info_cache[cache_key]\n\n        extra: Dict[str, str] = {}\n        if mbid:\n            extra[\"mbid\"] = mbid\n        else:\n            extra[\"artist\"] = name  # type: ignore[arg-type]\n\n        params = self._build_params(\"artist.getInfo\", extra)\n\n        try:\n            with httpx.Client(timeout=10.0) as client:\n                resp = client.get(self.base_url, params=params)\n            resp.raise_for_status()\n        except httpx.HTTPError as e:\n            st.error(f\"Error al consultar Last.fm (getInfo): {e}\")\n            return None\n\n        data = resp.json()\n        artist_obj = data.get(\"artist\")\n        if not artist_obj:\n            return None\n\n        self.info_cache[cache_key] = artist_obj\n        return artist_obj\n\n    def get_similar_artists(\n        self,\n        *,\n        name: Optional[str] = None,\n        mbid: Optional[str] = None,\n        limit: int = 50,\n    ) -> List[Artist]:\n        \"\"\"\n        Usa artist.getInfo y devuelve artist.similar.artist.\n        \"\"\"\n        info = self.get_artist_info(name=name, mbid=mbid)\n        if not info:\n            return []\n\n        similars_raw = (info.get(\"similar\") or {}).get(\"artist\", [])\n        if isinstance(similars_raw, dict):\n            similars_raw = [similars_raw]\n\n        artists: List[Artist] = []\n        for item in similars_raw:\n            aname = item.get(\"name\")\n            if not aname:\n                continue\n            ambid = item.get(\"mbid\") or None\n            image_url = self._extract_best_image(item.get(\"image\"))\n            artists.append(Artist(name=aname, mbid=ambid, image_url=image_url))\n\n        if len(artists) > limit:\n            artists = artists[:limit]\n\n        return artists\n\n    # ---------- Utilidad para im√°genes ----------\n\n    @staticmethod\n    def _extract_best_image(images: Any) -> Optional[str]:\n        if not images:\n            return None\n\n        if isinstance(images, dict):\n            images_list = [images]\n        elif isinstance(images, list):\n            images_list = images\n        else:\n            return None\n\n        urls: List[str] = []\n        for img in images_list:\n            if not isinstance(img, dict):\n                continue\n            url = img.get(\"#text\") or img.get(\"text\") or \"\"\n            url = url.strip()\n            if url:\n                urls.append(url)\n\n        if not urls:\n            return None\n\n        return urls[-1]  # normalmente la m√°s grande\n\n\n# =========================\n# Helpers MusicBrainz\n# =========================\n\ndef _mb_get(path: str, params: Dict[str, Any], tries: int = 5,\n            sleep_after_ok: float = 1.0, debug: bool = False) -> Dict[str, Any]:\n    url = f\"{MB_BASE}{path}\"\n    params = {**params, \"fmt\": \"json\"}\n    last_exc = None\n    backoff = 0.6\n\n    for attempt in range(1, tries + 1):\n        try:\n            if debug:\n                st.write(f\"[MB] GET {url} params={params} (attempt {attempt})\")\n            r = CLIENT.get(url, params=params)\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError(\"Transient\", r.request, r)\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            if debug:\n                st.write(f\"[MB] error {e}; retrying in {backoff:.1f}s\")\n            time.sleep(backoff)\n            backoff = min(backoff * 1.7, 5.0)\n\n    raise RuntimeError(f\"MB failed: {last_exc}\")\n\n\ndef _find_artist_mbid(name: str, debug: bool = False) -> Optional[str]:\n    data = _mb_get(\"/artist\", {\"query\": f'artist:\"{name}\"', \"limit\": 10}, debug=debug)\n    artists = data.get(\"artists\", []) or []\n    if not artists:\n        return None\n    exact = [a for a in artists if (a.get(\"name\") or \"\").lower() == name.lower()]\n    chosen = exact[0] if exact else artists[0]\n    return chosen.get(\"id\")\n\n\ndef _fetch_release_groups(artist_mbid: str, limit: int = 100, debug: bool = False):\n    data = _mb_get(\n        \"/release-group\",\n        {\n            \"artist\": artist_mbid,\n            \"primary-type\": \"Album\",\n            \"inc\": \"artist-credits+url-rels\",\n            \"limit\": min(limit, 100),\n        },\n        debug=debug,\n    )\n    return data.get(\"release-groups\", []) or []\n\n\ndef _is_studio_album(rg: Dict[str, Any], artist_mbid: str) -> bool:\n    if rg.get(\"primary-type\") != \"Album\":\n        return False\n    if rg.get(\"secondary-types\"):\n        return False\n    ac = rg.get(\"artist-credit\") or []\n    if len(ac) != 1:\n        return False\n    return (ac[0].get(\"artist\") or {}).get(\"id\") == artist_mbid\n\n\ndef _year_from_date(item: Dict[str, Any]) -> str:\n    d = item.get(\"first-release-date\") or \"\"\n    return d.split(\"-\")[0] if d else \"\"\n\n\ndef _discogs_master_from_rels(relations: Any) -> str:\n    if not relations:\n        return \"\"\n    for rel in relations:\n        if rel.get(\"type\") == \"discogs\":\n            url = (rel.get(\"url\") or {}).get(\"resource\", \"\")\n            m = _RE_DISCOGS_MASTER.search(url)\n            if m:\n                return m.group(1)\n    return \"\"\n\n\n# =========================\n# Helpers Discogs\n# =========================\n\ndef _discogs_get(path: str, params: Dict[str, Any],\n                 key: str, secret: str,\n                 sleep_after_ok: float = 0.25,\n                 debug: bool = False):\n\n    url = f\"{DISCOGS_BASE}{path}\"\n    params = {**params, \"key\": key, \"secret\": secret}\n\n    if debug:\n        st.write(f\"[Discogs] GET {url} {params}\")\n\n    r = CLIENT.get(url, params=params)\n    r.raise_for_status()\n    time.sleep(sleep_after_ok)\n    return r.json()\n\n\ndef _discogs_master_rating(master_id: str, key: str, secret: str, debug: bool = False):\n    \"\"\"\n    Devuelve (rating, votes) usando master o main_release.\n    \"\"\"\n    if not master_id:\n        return None, None\n\n    data = _discogs_get(f\"/masters/{master_id}\", {}, key, secret, debug=debug)\n    r = (data.get(\"community\") or {}).get(\"rating\") or {}\n    if r.get(\"average\") is not None:\n        return float(r[\"average\"]), int(r.get(\"count\", 0))\n\n    main_rel = data.get(\"main_release\")\n    if not main_rel:\n        return None, None\n\n    rel = _discogs_get(f\"/releases/{main_rel}\", {}, key, secret, debug=debug)\n    rr = (rel.get(\"community\") or {}).get(\"rating\") or {}\n    if rr.get(\"average\") is None:\n        return None, None\n    return float(rr.get(\"average\", 0.0)), int(rr.get(\"count\", 0))\n\n\n# =========================\n# Parallel rating fetcher (Discogs)\n# =========================\n\ndef attach_discogs_ratings(df: pd.DataFrame, key: str, secret: str, debug: bool = False) -> pd.DataFrame:\n    if df.empty:\n        return df\n\n    df = df.copy()\n    master_ids = df[\"discogs_master_id\"].tolist()\n\n    def process_one(mid: str):\n        if not mid:\n            return (None, None)\n        try:\n            return _discogs_master_rating(mid, key, secret, debug)\n        except Exception:\n            return (None, None)\n\n    batch_size = 5\n    # Preasignamos para mantener el orden de df\n    results: List[Tuple[Optional[float], Optional[int]]] = [(None, None)] * len(master_ids)\n\n    for i in range(0, len(master_ids), batch_size):\n        chunk = master_ids[i:i + batch_size]\n        with ThreadPoolExecutor(max_workers=batch_size) as exe:\n            future_map = {}\n            for j, mid in enumerate(chunk):\n                idx = i + j\n                fut = exe.submit(process_one, mid)\n                future_map[fut] = idx\n\n            for fut in as_completed(future_map):\n                idx = future_map[fut]\n                results[idx] = fut.result()\n\n        time.sleep(0.25)\n\n    df[\"discogs_rating\"] = [r[0] for r in results]\n    df[\"discogs_votes\"] = [r[1] for r in results]\n    return df\n\n\n# =========================\n# API p√∫blica: MB + Discogs (con fallback MBID ‚Üí nombre)\n# =========================\n\ndef _studio_albums_by_mbid(artist_mbid: str, debug: bool = False) -> List[Dict[str, Any]]:\n    rgs = _fetch_release_groups(artist_mbid, debug=debug)\n    filtered = [rg for rg in rgs if _is_studio_album(rg, artist_mbid)]\n    rows: List[Dict[str, Any]] = []\n    for rg in filtered:\n        rows.append({\n            \"year\": _year_from_date(rg),\n            \"title\": (rg.get(\"title\") or \"\").strip(),\n            \"discogs_master_id\": _discogs_master_from_rels(rg.get(\"relations\")),\n            \"rg_mbid\": rg.get(\"id\", \"\")\n        })\n    return rows\n\n\ndef mb_dataframe(\n    artist: Optional[str] = None,\n    artist_mbid: Optional[str] = None,\n    discogs_key: Optional[str] = None,\n    discogs_secret: Optional[str] = None,\n    debug: bool = False,\n) -> pd.DataFrame:\n    \"\"\"\n    Devuelve los √°lbumes de estudio de un artista:\n    - year, title, discogs_master_id, rg_mbid\n    Y si hay Discogs key/secret:\n    - discogs_rating, discogs_votes\n\n    L√≥gica:\n    1) Si hay artist_mbid -> intenta con ese MBID.\n    2) Si no hay resultados y tenemos nombre -> busca MBID por nombre y reintenta.\n    \"\"\"\n\n    rows: List[Dict[str, Any]] = []\n\n    # 1) Intentar por MBID (si viene)\n    tried_mbid = False\n    if artist_mbid:\n        tried_mbid = True\n        rows = _studio_albums_by_mbid(artist_mbid, debug=debug)\n\n    # 2) Fallback: si no hubo resultados y tenemos nombre, buscar MBID por nombre\n    if not rows and artist:\n        mbid_from_name = _find_artist_mbid(artist, debug=debug)\n        if mbid_from_name and (not tried_mbid or mbid_from_name != artist_mbid):\n            rows = _studio_albums_by_mbid(mbid_from_name, debug=debug)\n\n    df = pd.DataFrame(rows)\n    if df.empty:\n        return df\n\n    df.sort_values(\"year\", inplace=True, ignore_index=True)\n\n    if discogs_key and discogs_secret:\n        df = attach_discogs_ratings(df, discogs_key, discogs_secret, debug)\n\n    return df\n\n\n# =========================\n# L√≥gica de sugerencias (usando getInfo)\n# =========================\n\ndef build_suggestions(\n    client: LastFMClient,\n    selected: List[Artist],\n    limit: int = 10,\n) -> List[Artist]:\n    if not selected or limit <= 0:\n        return []\n\n    base_weight = 0.6\n    step = 0.3\n\n    candidate_scores: Dict[Tuple[Optional[str], str], float] = {}\n    candidate_artist_data: Dict[Tuple[Optional[str], str], Artist] = {}\n\n    for idx, seed in enumerate(selected):\n        weight = base_weight + step * idx\n        similars = client.get_similar_artists(name=seed.name, mbid=seed.mbid, limit=50)\n\n        for rank, artist in enumerate(similars):\n            key = (artist.mbid, artist.name.lower())\n\n            if artist.name.lower() == seed.name.lower() and (\n                seed.mbid is None or artist.mbid == seed.mbid\n            ):\n                continue\n\n            score_increment = weight / float(rank + 1)\n            candidate_scores[key] = candidate_scores.get(key, 0.0) + score_increment\n\n            if key not in candidate_artist_data:\n                candidate_artist_data[key] = artist\n\n    selected_keys = {(s.mbid, s.name.lower()) for s in selected}\n    for sel_key in selected_keys:\n        candidate_scores.pop(sel_key, None)\n        candidate_artist_data.pop(sel_key, None)\n\n    sorted_candidates = sorted(\n        candidate_scores.items(),\n        key=lambda kv: kv[1],\n        reverse=True,\n    )\n\n    suggestions: List[Artist] = []\n    for key, _score in sorted_candidates:\n        artist = candidate_artist_data.get(key)\n        if artist:\n            suggestions.append(artist)\n        if len(suggestions) >= limit:\n            break\n\n    return suggestions\n\n\n# =========================\n# Helpers de estado (Streamlit)\n# =========================\n\ndef init_state():\n    if \"selected_artists\" not in st.session_state:\n        st.session_state.selected_artists: List[Artist] = []\n    if \"suggested_artists\" not in st.session_state:\n        st.session_state.suggested_artists: List[Artist] = []\n    if \"last_suggestions_time\" not in st.session_state:\n        st.session_state.last_suggestions_time = None\n    if \"last_albums_time\" not in st.session_state:\n        # dict: nombre_artista -> tiempo\n        st.session_state.last_albums_time: Dict[str, float] = {}\n\n\ndef add_selected(artist: Artist, client: LastFMClient, limit: int = 10):\n    for a in st.session_state.selected_artists:\n        if a.name.lower() == artist.name.lower() and (\n            (not a.mbid and not artist.mbid) or (a.mbid == artist.mbid)\n        ):\n            return\n    st.session_state.selected_artists.append(artist)\n\n    start = time.perf_counter()\n    st.session_state.suggested_artists = build_suggestions(\n        client, st.session_state.selected_artists, limit=limit\n    )\n    elapsed = time.perf_counter() - start\n    st.session_state.last_suggestions_time = elapsed\n\n\ndef remove_selected(index: int, client: LastFMClient, limit: int = 10):\n    if 0 <= index < len(st.session_state.selected_artists):\n        st.session_state.selected_artists.pop(index)\n\n        start = time.perf_counter()\n        st.session_state.suggested_artists = build_suggestions(\n            client, st.session_state.selected_artists, limit=limit\n        )\n        elapsed = time.perf_counter() - start\n        st.session_state.last_suggestions_time = elapsed\n\n\n# =========================\n# App Streamlit\n# =========================\n\ndef main():\n    st.set_page_config(page_title=\"Explorador de artistas (Last.fm)\", layout=\"wide\")\n    st.title(\"üéß Explorador de artistas (Last.fm) + discos de estudio (MB / Discogs)\")\n\n    if not LASTFM_API_KEY:\n        st.error(\n            \"No se ha encontrado `LASTFM_API_KEY`. \"\n            \"A√±√°delo como variable de entorno/Secret.\"\n        )\n        st.stop()\n\n    init_state()\n    client = LastFMClient(api_key=LASTFM_API_KEY)\n\n    # Mostrar tiempo global de sugerencias (si existe)\n    if st.session_state.last_suggestions_time is not None:\n        st.info(\n            f\"‚è± √öltimo c√°lculo de sugerencias: \"\n            f\"{st.session_state.last_suggestions_time:.2f} segundos\"\n        )\n\n    if not DISCOGS_KEY or not DISCOGS_SECRET:\n        st.warning(\n            \"No se han encontrado `DISCOGS_KEY` y/o `DISCOGS_SECRET`. \"\n            \"Se mostrar√°n los discos de estudio pero sin rating de Discogs.\"\n        )\n\n    st.markdown(\n        \"1. Escribe un nombre de artista y a√±√°delo a la lista.\\n\"\n        \"2. Ver√°s hasta **10 artistas similares**, usando `artist.getInfo`.\\n\"\n        \"3. Para cada artista seleccionado, puedes ver sus **discos de estudio** \"\n        \"con rating de vinilo desde Discogs (cuando est√© disponible).\\n\"\n    )\n\n    col_search, col_selected, col_suggestions = st.columns([2, 2, 3])\n\n    # -------- B√öSQUEDA --------\n    with col_search:\n        st.subheader(\"üîç Buscar artista\")\n        query = st.text_input(\n            \"Nombre del artista\",\n            placeholder=\"Arctic Monkeys, Metallica...\",\n            key=\"search_box\",\n        )\n\n        search_results: List[Artist] = []\n        if st.session_state.search_box and len(st.session_state.search_box.strip()) >= 2:\n            search_results = client.search_artists(st.session_state.search_box.strip(), limit=10)\n\n        if query and not search_results:\n            st.info(\"No se han encontrado artistas para esa b√∫squeda.\")\n\n        for i, artist in enumerate(search_results):\n            with st.container():\n                cols = st.columns([1, 3])\n                with cols[0]:\n                    if artist.image_url:\n                        st.image(artist.image_url, use_container_width=True)\n                    else:\n                        st.write(\"üéµ\")\n                with cols[1]:\n                    st.markdown(f\"**{artist.name}**\")\n                    if artist.mbid:\n                        st.caption(f\"mbid: {artist.mbid}\")\n\n                    if st.button(\"‚ûï A√±adir\", key=f\"add_search_{artist.name}_{i}\"):\n                        add_selected(artist, client, limit=10)\n                        st.rerun()\n\n    # -------- SELECCIONADOS --------\n    with col_selected:\n        st.subheader(\"‚úÖ Artistas seleccionados\")\n        if not st.session_state.selected_artists:\n            st.caption(\"Todav√≠a no has seleccionado ning√∫n artista.\")\n        else:\n            for idx, artist in enumerate(st.session_state.selected_artists):\n                with st.container():\n                    cols = st.columns([3, 2])\n                    with cols[0]:\n                        st.markdown(f\"**{artist.name}**\")\n                        if artist.mbid:\n                            st.caption(f\"mbid: {artist.mbid}\")\n                    with cols[1]:\n                        if st.button(\"‚ùå Quitar\", key=f\"remove_sel_{idx}\"):\n                            remove_selected(idx, client, limit=10)\n                            st.rerun()\n\n                    # Bot√≥n para ver discos de estudio\n                    if st.button(\"üìÄ Ver discos de estudio\", key=f\"albums_{idx}\"):\n                        with st.spinner(\"Buscando discos de estudio...\"):\n                            start = time.perf_counter()\n                            df_albums = mb_dataframe(\n                                artist=artist.name,\n                                artist_mbid=artist.mbid,\n                                discogs_key=DISCOGS_KEY,\n                                discogs_secret=DISCOGS_SECRET,\n                                debug=False,\n                            )\n                            elapsed = time.perf_counter() - start\n                            st.session_state.last_albums_time[artist.name] = elapsed\n\n                        if df_albums.empty:\n                            st.info(\"No se han encontrado √°lbumes de estudio.\")\n                        else:\n                            st.success(\n                                f\"‚è± Discos de estudio para **{artist.name}**: \"\n                                f\"{elapsed:.2f} segundos\"\n                            )\n                            st.dataframe(df_albums, use_container_width=True)\n\n    # -------- SUGERENCIAS --------\n    with col_suggestions:\n        st.subheader(\"‚ú® Sugerencias (hasta 10)\")\n        suggestions = st.session_state.suggested_artists\n\n        if st.session_state.last_suggestions_time is not None:\n            st.caption(\n                f\"‚è± √öltimo c√°lculo de sugerencias: \"\n                f\"{st.session_state.last_suggestions_time:.2f} s\"\n            )\n\n        if not st.session_state.selected_artists:\n            st.caption(\"A√±ade al menos un artista para ver sugerencias.\")\n        elif not suggestions:\n            st.caption(\"No hay sugerencias disponibles ahora mismo.\")\n        else:\n            for i, artist in enumerate(suggestions):\n                with st.container():\n                    cols = st.columns([1, 3, 1])\n                    with cols[0]:\n                        if artist.image_url:\n                            st.image(artist.image_url, use_container_width=True)\n                        else:\n                            st.write(\"üéµ\")\n                    with cols[1]:\n                        st.markdown(f\"**{artist.name}**\")\n                        if artist.mbid:\n                            st.caption(f\"mbid: {artist.mbid}\")\n                    with cols[2]:\n                        if st.button(\"‚ûï A√±adir\", key=f\"add_sugg_{artist.name}_{i}\"):\n                            add_selected(artist, client, limit=10)\n                            st.rerun()\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":23780},"start_services.py":{"content":"import subprocess\nimport os\nimport signal\nimport sys\nimport time\n\nprocesses = []\n\n\ndef cleanup(signum, frame):\n    print(\"\\nShutting down all services...\")\n    for p in processes:\n        p.terminate()\n    for p in processes:\n        p.wait()\n    sys.exit(0)\n\n\nsignal.signal(signal.SIGINT, cleanup)\nsignal.signal(signal.SIGTERM, cleanup)\n\nif __name__ == \"__main__\":\n    print(\"Starting all microservices...\")\n    \n    services = [\n        (\"Spotify Service\", [\"uvicorn\", \"services.spotify.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3000\"]),\n        (\"Discogs Service\", [\"uvicorn\", \"services.discogs.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3001\"]),\n        (\"Recommender Service\", [\"uvicorn\", \"services.recommender.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3002\"]),\n        (\"Pricing Service\", [\"uvicorn\", \"services.pricing.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3003\"]),\n        (\"Last.fm Service\", [\"uvicorn\", \"services.lastfm.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3004\"]),\n        (\"API Gateway\", [\"uvicorn\", \"gateway.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"5000\"]),\n    ]\n    \n    for name, cmd in services:\n        print(f\"Starting {name}...\")\n        p = subprocess.Popen(cmd)\n        processes.append(p)\n        time.sleep(2)\n    \n    print(\"\\nAll services started!\")\n    print(\"- Spotify Service: http://localhost:3000\")\n    print(\"- Discogs Service: http://localhost:3001\")\n    print(\"- Recommender Service: http://localhost:3002\")\n    print(\"- Pricing Service: http://localhost:3003\")\n    print(\"- Last.fm Service: http://localhost:3004\")\n    print(\"- API Gateway: http://localhost:5000\")\n    print(\"\\nPress Ctrl+C to stop all services\")\n    \n    try:\n        for p in processes:\n            p.wait()\n    except KeyboardInterrupt:\n        cleanup(None, None)\n","size_bytes":1784},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":157},"services/discogs/__init__.py":{"content":"# Discogs Service\n","size_bytes":18},"gateway/static/artist-search.css":{"content":".artist-search-modal {\n    width: 100%;\n    max-width: 900px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\n.artist-search-header h2 {\n    font-size: 16px;\n    font-weight: 400;\n    color: var(--text-secondary);\n    text-align: center;\n    margin: 0 0 30px 0;\n}\n\n.artist-search-input-wrapper {\n    position: relative;\n    margin-bottom: 30px;\n}\n\n.artist-search-input {\n    width: 100%;\n    padding: 16px 50px 16px 50px;\n    font-size: 16px;\n    border: 2px solid var(--border-color);\n    border-radius: 50px;\n    background: var(--background);\n    color: var(--text);\n    transition: all 0.3s ease;\n    outline: none;\n}\n\n.artist-search-input:focus {\n    border-color: var(--primary);\n    box-shadow: 0 0 0 3px var(--primary-fade);\n}\n\n.artist-search-input::before {\n    content: 'üîç';\n    position: absolute;\n    left: 20px;\n    top: 50%;\n    transform: translateY(-50%);\n    font-size: 18px;\n}\n\n.clear-search-btn {\n    position: absolute;\n    right: 20px;\n    top: 50%;\n    transform: translateY(-50%);\n    background: none;\n    border: none;\n    color: var(--text-secondary);\n    font-size: 20px;\n    cursor: pointer;\n    padding: 5px;\n    opacity: 0.6;\n    transition: opacity 0.2s;\n}\n\n.clear-search-btn:hover {\n    opacity: 1;\n}\n\n.search-results-container {\n    margin-bottom: 30px;\n}\n\n.search-results-label {\n    font-size: 14px;\n    font-weight: 500;\n    color: var(--text-secondary);\n    margin-bottom: 15px;\n}\n\n.artist-grid {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 12px;\n}\n\n@media (max-width: 600px) {\n    .artist-grid {\n        grid-template-columns: 1fr;\n    }\n}\n\n.artist-card {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 12px 16px;\n    background: var(--card-background);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    transition: all 0.2s ease;\n    cursor: pointer;\n}\n\n.artist-card:hover:not(.disabled) {\n    border-color: var(--primary);\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.artist-card.selected {\n    border-color: var(--primary);\n    background: var(--primary-fade);\n}\n\n.artist-card.disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.artist-card-content {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    flex: 1;\n    min-width: 0;\n}\n\n.artist-image-wrapper {\n    flex-shrink: 0;\n}\n\n.artist-image {\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    object-fit: cover;\n}\n\n.artist-image-placeholder {\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    background: var(--background);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 24px;\n}\n\n.artist-info {\n    flex: 1;\n    min-width: 0;\n}\n\n.artist-name {\n    font-size: 15px;\n    font-weight: 500;\n    color: var(--text);\n    margin-bottom: 3px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.artist-genres {\n    font-size: 12px;\n    color: var(--text-secondary);\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.add-artist-btn {\n    flex-shrink: 0;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    border: 2px solid var(--primary);\n    background: var(--background);\n    color: var(--primary);\n    font-size: 18px;\n    font-weight: bold;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.2s;\n}\n\n.add-artist-btn:hover:not(:disabled) {\n    background: var(--primary);\n    color: white;\n    transform: scale(1.1);\n}\n\n.add-artist-btn.added {\n    background: var(--primary);\n    color: white;\n}\n\n.add-artist-btn:disabled {\n    opacity: 0.3;\n    cursor: not-allowed;\n}\n\n.selected-artists-section {\n    margin-bottom: 30px;\n}\n\n.selected-artists-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 15px;\n    font-size: 14px;\n    font-weight: 500;\n    color: var(--text-secondary);\n}\n\n.artist-counter {\n    font-size: 13px;\n    color: var(--text-secondary);\n}\n\n.selected-artists-pills {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 10px;\n}\n\n.no-selection {\n    text-align: center;\n    padding: 30px;\n    color: var(--text-secondary);\n    font-size: 14px;\n}\n\n.artist-pill {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 12px 8px 8px;\n    background: var(--primary);\n    color: white;\n    border-radius: 25px;\n    font-size: 14px;\n}\n\n.pill-image {\n    width: 28px;\n    height: 28px;\n    border-radius: 50%;\n    object-fit: cover;\n}\n\n.pill-name {\n    font-weight: 500;\n}\n\n.pill-remove-btn {\n    background: rgba(255, 255, 255, 0.2);\n    border: none;\n    color: white;\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    transition: background 0.2s;\n}\n\n.pill-remove-btn:hover {\n    background: rgba(255, 255, 255, 0.3);\n}\n\n.continue-btn {\n    width: 100%;\n    padding: 16px;\n    font-size: 16px;\n    font-weight: 600;\n    color: white;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    border: none;\n    border-radius: 12px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.continue-btn:hover:not(:disabled) {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);\n}\n\n.continue-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.loading, .error, .no-results {\n    text-align: center;\n    padding: 40px;\n    color: var(--text-secondary);\n    font-size: 14px;\n    grid-column: 1 / -1;\n}\n\n.error {\n    color: var(--error);\n}\n\n.artist-pill.loading {\n    opacity: 0.8;\n}\n\n.artist-pill.cached {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n}\n\n.pill-spinner {\n    animation: spin 1s linear infinite;\n    font-size: 14px;\n}\n\n@keyframes spin {\n    from {\n        transform: rotate(0deg);\n    }\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n.pill-check {\n    font-size: 14px;\n    font-weight: bold;\n}\n\n.pill-error {\n    font-size: 14px;\n    cursor: help;\n}\n\n.artist-pill.error {\n    background: linear-gradient(135deg, #f56565 0%, #c53030 100%);\n}\n","size_bytes":6211},"services/recommender/artist_recommendations.py":{"content":"import os\nimport time\nimport re\nimport threading\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport httpx\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\n\nMB_BASE = \"https://musicbrainz.org/ws/2\"\nDISCOGS_BASE = \"https://api.discogs.com\"\n\nHEADERS = {\n    \"User-Agent\": \"Vinilogy/1.0 (+https://vinilogy.com; contact@vinilogy.com)\"\n}\n\n_RE_DISCOGS_MASTER = re.compile(\n    r\"https?://(?:www\\.)?discogs\\.com/(?:[a-z]{2}/)?master/(\\d+)\", re.I\n)\n\nCLIENT = httpx.Client(\n    headers=HEADERS,\n    http2=False,\n    timeout=httpx.Timeout(30.0),\n    limits=httpx.Limits(max_connections=10, max_keepalive_connections=10),\n    follow_redirects=True,\n)\n\nCACHE_EXPIRY_DAYS = 7\n\n_last_discogs_call_time = 0.0\n_MIN_DISCOGS_DELAY = 1.5\n_discogs_lock = threading.Lock()\n\n\ndef _get_db_connection():\n    \"\"\"Get PostgreSQL connection\"\"\"\n    try:\n        return psycopg2.connect(os.getenv(\"DATABASE_URL\"))\n    except Exception as e:\n        print(f\"[DB] Connection failed: {e}\")\n        return None\n\n\ndef _get_cached_artist_albums(artist_name: str) -> Optional[List[Dict[str, Any]]]:\n    \"\"\"Get cached artist albums from PostgreSQL\"\"\"\n    conn = _get_db_connection()\n    if not conn:\n        return None\n    \n    try:\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\n        \n        cursor.execute(\n            \"SELECT id, mbid, last_updated FROM artists WHERE name = %s\",\n            (artist_name,)\n        )\n        artist = cursor.fetchone()\n        \n        if not artist:\n            return None\n        \n        cache_age = datetime.now() - artist[\"last_updated\"]\n        if cache_age > timedelta(days=CACHE_EXPIRY_DAYS):\n            print(f\"[DB] Cache for '{artist_name}' is {cache_age.days} days old (expired)\")\n            return None\n        \n        cursor.execute(\n            \"\"\"SELECT title, year, discogs_master_id, discogs_release_id, \n                      rating, votes, cover_url\n               FROM albums \n               WHERE artist_id = %s \n               ORDER BY rating DESC NULLS LAST, votes DESC NULLS LAST\"\"\",\n            (artist[\"id\"],)\n        )\n        albums = cursor.fetchall()\n        \n        if not albums:\n            return None\n        \n        print(f\"[DB] ‚úì Found {len(albums)} cached albums for '{artist_name}' (age: {cache_age.days}d)\")\n        return [dict(album) for album in albums]\n    \n    except Exception as e:\n        print(f\"[DB] Error reading cache for '{artist_name}': {e}\")\n        return None\n    finally:\n        conn.close()\n\n\ndef _save_artist_albums(artist_name: str, mbid: str, albums: List['StudioAlbum'], \n                        image_url: Optional[str] = None):\n    \"\"\"Save artist and albums to PostgreSQL\"\"\"\n    conn = _get_db_connection()\n    if not conn:\n        print(f\"[DB] Cannot save '{artist_name}' - no database connection\")\n        return\n    \n    try:\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\n        \n        cursor.execute(\n            \"\"\"INSERT INTO artists (name, mbid, image_url) \n               VALUES (%s, %s, %s) \n               ON CONFLICT (name) \n               DO UPDATE SET mbid = EXCLUDED.mbid, \n                            image_url = EXCLUDED.image_url,\n                            last_updated = CURRENT_TIMESTAMP\n               RETURNING id\"\"\",\n            (artist_name, mbid, image_url)\n        )\n        result = cursor.fetchone()\n        if not result:\n            return\n        artist_id = result[\"id\"]\n        \n        cursor.execute(\"DELETE FROM albums WHERE artist_id = %s\", (artist_id,))\n        \n        for album in albums:\n            cursor.execute(\n                \"\"\"INSERT INTO albums (artist_id, title, year, discogs_master_id, \n                                      discogs_release_id, rating, votes, cover_url)\n                   VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\"\"\",\n                (artist_id, album.title, album.year, album.discogs_master_id,\n                 album.discogs_release_id, album.rating, album.votes, album.cover_image)\n            )\n        \n        conn.commit()\n        print(f\"[DB] ‚úì Saved {len(albums)} albums for '{artist_name}' to cache\")\n    \n    except Exception as e:\n        conn.rollback()\n        print(f\"[DB] Error saving '{artist_name}': {e}\")\n    finally:\n        conn.close()\n\n\nclass StudioAlbum:\n    def __init__(self, title: str, year: str, discogs_master_id: Optional[str],\n                 artist_name: str, rating: Optional[float] = None,\n                 votes: Optional[int] = None, cover_image: Optional[str] = None,\n                 discogs_release_id: Optional[str] = None, discogs_type: str = \"master\"):\n        self.title = title\n        self.year = year\n        self.discogs_master_id = discogs_master_id\n        self.discogs_release_id = discogs_release_id\n        self.discogs_type = discogs_type\n        self.artist_name = artist_name\n        self.rating = rating\n        self.votes = votes\n        self.cover_image = cover_image\n\n\ndef _mb_get(path: str, params: Dict[str, Any], tries: int = 5,\n            sleep_after_ok: float = 1.0) -> Dict[str, Any]:\n    url = f\"{MB_BASE}{path}\"\n    params = {**params, \"fmt\": \"json\"}\n    last_exc = None\n    backoff = 0.6\n\n    for attempt in range(1, tries + 1):\n        try:\n            r = CLIENT.get(url, params=params)\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError(\"Transient\", request=r.request, response=r)\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            time.sleep(backoff)\n            backoff = min(backoff * 1.7, 5.0)\n\n    raise RuntimeError(f\"MB failed: {last_exc}\")\n\n\ndef _find_artist_mbid(name: str) -> Optional[str]:\n    try:\n        data = _mb_get(\"/artist\", {\"query\": f'artist:\"{name}\"', \"limit\": 10})\n        artists = data.get(\"artists\", []) or []\n        if not artists:\n            return None\n        exact = [a for a in artists if a.get(\"name\", \"\").lower() == name.lower()]\n        chosen = exact[0] if exact else artists[0]\n        return chosen.get(\"id\")\n    except Exception:\n        return None\n\n\ndef _fetch_release_groups(artist_mbid: str, limit: int = 100):\n    try:\n        data = _mb_get(\n            \"/release-group\",\n            {\n                \"artist\": artist_mbid,\n                \"primary-type\": \"Album\",\n                \"inc\": \"artist-credits+url-rels\",\n                \"limit\": min(limit, 100),\n            }\n        )\n        return data.get(\"release-groups\", []) or []\n    except Exception:\n        return []\n\n\ndef _is_studio_album(rg: Dict[str, Any], artist_mbid: str) -> bool:\n    if rg.get(\"primary-type\") != \"Album\":\n        return False\n    if rg.get(\"secondary-types\"):\n        return False\n    ac = rg.get(\"artist-credit\") or []\n    if len(ac) != 1:\n        return False\n    return (ac[0].get(\"artist\") or {}).get(\"id\") == artist_mbid\n\n\ndef _year_from_date(item: Dict[str, Any]) -> str:\n    d = item.get(\"first-release-date\") or \"\"\n    return d.split(\"-\")[0] if d else \"\"\n\n\ndef _discogs_master_from_rels(relations: Any) -> str:\n    if not relations:\n        return \"\"\n    for rel in relations:\n        if rel.get(\"type\") == \"discogs\":\n            url = (rel.get(\"url\") or {}).get(\"resource\", \"\")\n            m = _RE_DISCOGS_MASTER.search(url)\n            if m:\n                return m.group(1)\n    return \"\"\n\n\ndef _get_artist_image_from_discogs(artist_name: str, discogs_key: str, discogs_secret: str, csv_mode: bool = False) -> Optional[str]:\n    \"\"\"Get artist image from Discogs search\"\"\"\n    try:\n        sleep_time = 1.0 if csv_mode else 0.25\n        data = _discogs_get(\"/database/search\", {\n            \"q\": artist_name,\n            \"type\": \"artist\",\n            \"per_page\": 1\n        }, discogs_key, discogs_secret, sleep_after_ok=sleep_time)\n        results = data.get(\"results\", [])\n        if results:\n            return results[0].get(\"cover_image\")\n    except Exception as e:\n        print(f\"[ARTIST IMAGE] Could not get image for {artist_name}: {e}\")\n    return None\n\n\ndef _discogs_get(path: str, params: Dict[str, Any],\n                 key: str, secret: str,\n                 sleep_after_ok: float = 0.25,\n                 tries: int = 5):\n    url = f\"{DISCOGS_BASE}{path}\"\n    params = {**params, \"key\": key, \"secret\": secret}\n    last_exc = None\n    backoff = 1.0\n    \n    for attempt in range(1, tries + 1):\n        try:\n            r = CLIENT.get(url, params=params)\n            if r.status_code == 429:\n                if attempt < tries:\n                    wait_time = 60.0\n                    print(f\"[DISCOGS] ‚ö†Ô∏è  RATE LIMIT HIT (429) - sleeping {wait_time}s before retry (attempt {attempt}/{tries})\")\n                    time.sleep(wait_time)\n                    continue\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            if attempt < tries:\n                time.sleep(backoff)\n                backoff = min(backoff * 2.0, 10.0)\n    \n    raise RuntimeError(f\"Discogs API failed after {tries} attempts: {last_exc}\")\n\n\ndef _search_discogs_master(artist_name: str, album_title: str, key: str, secret: str, csv_mode: bool = False) -> Optional[str]:\n    \"\"\"Fallback: Search Discogs for master_id by artist + album title\"\"\"\n    try:\n        query = f\"{artist_name} {album_title}\"\n        sleep_time = 1.0 if csv_mode else 0.25\n        data = _discogs_get(\"/database/search\", {\n            \"q\": query,\n            \"type\": \"master\",\n            \"per_page\": 5\n        }, key, secret, sleep_after_ok=sleep_time)\n        \n        results = data.get(\"results\", [])\n        if not results:\n            return None\n        \n        for result in results:\n            result_title = result.get(\"title\", \"\").lower()\n            if album_title.lower() in result_title:\n                return str(result.get(\"id\", \"\"))\n        \n        return str(results[0].get(\"id\", \"\")) if results else None\n    except Exception:\n        return None\n\n\ndef _search_discogs_release(artist_name: str, album_title: str, key: str, secret: str, csv_mode: bool = False) -> Optional[str]:\n    \"\"\"Second fallback: Search Discogs for release_id by artist + album title\"\"\"\n    try:\n        query = f\"{artist_name} {album_title}\"\n        sleep_time = 1.0 if csv_mode else 0.25\n        data = _discogs_get(\"/database/search\", {\n            \"q\": query,\n            \"type\": \"release\",\n            \"format\": \"vinyl\",\n            \"per_page\": 5\n        }, key, secret, sleep_after_ok=sleep_time)\n        \n        results = data.get(\"results\", [])\n        if not results:\n            return None\n        \n        for result in results:\n            result_title = result.get(\"title\", \"\").lower()\n            if album_title.lower() in result_title:\n                return str(result.get(\"id\", \"\"))\n        \n        return str(results[0].get(\"id\", \"\")) if results else None\n    except Exception:\n        return None\n\n\ndef _discogs_release_data(release_id: str, key: str, secret: str, csv_mode: bool = False) -> Tuple[Optional[float], Optional[int], Optional[str]]:\n    \"\"\"Get rating and cover from a Discogs release (not master)\"\"\"\n    if not release_id:\n        return None, None, None\n    \n    try:\n        sleep_time = 1.0 if csv_mode else 0.25\n        rel = _discogs_get(f\"/releases/{release_id}\", {}, key, secret, sleep_after_ok=sleep_time)\n        rr = (rel.get(\"community\") or {}).get(\"rating\") or {}\n        \n        cover_image = None\n        rel_images = rel.get(\"images\", [])\n        if rel_images and len(rel_images) > 0:\n            cover_image = rel_images[0].get(\"uri\")\n        \n        if rr.get(\"average\") is None:\n            print(f\"[RATING] Release {release_id}: NO RATING\")\n            return None, None, cover_image\n        \n        rating = float(rr[\"average\"])\n        votes = int(rr.get(\"count\", 0))\n        print(f\"[RATING] Release {release_id}: rating={rating}, votes={votes}\")\n        return rating, votes, cover_image\n    except Exception as e:\n        print(f\"[RATING] Release {release_id}: ERROR - {str(e)}\")\n        return None, None, None\n\n\ndef _discogs_master_data(master_id: str, key: str, secret: str, csv_mode: bool = False) -> Tuple[Optional[float], Optional[int], Optional[str]]:\n    if not master_id:\n        return None, None, None\n\n    try:\n        sleep_time = 1.0 if csv_mode else 0.25\n        data = _discogs_get(f\"/masters/{master_id}\", {}, key, secret, sleep_after_ok=sleep_time)\n        r = (data.get(\"community\") or {}).get(\"rating\") or {}\n        \n        cover_image = None\n        images = data.get(\"images\", [])\n        if images and len(images) > 0:\n            cover_image = images[0].get(\"uri\")\n        \n        if r.get(\"average\") is not None:\n            rating = float(r[\"average\"])\n            votes = int(r.get(\"count\", 0))\n            print(f\"[RATING] Master {master_id}: rating={rating}, votes={votes} (from master)\")\n            return rating, votes, cover_image\n\n        main_rel = data.get(\"main_release\")\n        if not main_rel:\n            print(f\"[RATING] Master {master_id}: NO RATING (no master rating, no main_release)\")\n            return None, None, cover_image\n\n        print(f\"[RATING] Master {master_id}: No master rating, checking main_release {main_rel}\")\n        rel = _discogs_get(f\"/releases/{main_rel}\", {}, key, secret, sleep_after_ok=sleep_time)\n        rr = (rel.get(\"community\") or {}).get(\"rating\") or {}\n        \n        if not cover_image:\n            rel_images = rel.get(\"images\", [])\n            if rel_images and len(rel_images) > 0:\n                cover_image = rel_images[0].get(\"uri\")\n        \n        if rr.get(\"average\") is None:\n            print(f\"[RATING] Master {master_id}: NO RATING (main_release {main_rel} has no rating)\")\n            return None, None, cover_image\n        \n        rating = float(rr[\"average\"])\n        votes = int(rr.get(\"count\", 0))\n        print(f\"[RATING] Master {master_id}: rating={rating}, votes={votes} (from main_release {main_rel})\")\n        return rating, votes, cover_image\n    except Exception as e:\n        print(f\"[RATING] Master {master_id}: ERROR - {str(e)}\")\n        return None, None, None\n\n\ndef get_artist_studio_albums(artist_name: str, discogs_key: str, discogs_secret: str,\n                              top_n: int = 3, csv_mode: bool = False) -> List[StudioAlbum]:\n    cached_albums = _get_cached_artist_albums(artist_name)\n    if cached_albums:\n        result = []\n        for album_data in cached_albums[:top_n]:\n            discogs_type = \"master\" if album_data.get(\"discogs_master_id\") else \"release\"\n            album = StudioAlbum(\n                title=album_data[\"title\"],\n                year=album_data[\"year\"],\n                discogs_master_id=album_data.get(\"discogs_master_id\"),\n                discogs_release_id=album_data.get(\"discogs_release_id\"),\n                discogs_type=discogs_type,\n                artist_name=artist_name,\n                rating=album_data.get(\"rating\"),\n                votes=album_data.get(\"votes\"),\n                cover_image=album_data.get(\"cover_url\")\n            )\n            result.append(album)\n        return result\n    \n    mbid = _find_artist_mbid(artist_name)\n    if not mbid:\n        return []\n\n    release_groups = _fetch_release_groups(mbid, limit=100)\n    \n    studio_albums: List[StudioAlbum] = []\n    for rg in release_groups:\n        if not _is_studio_album(rg, mbid):\n            continue\n        \n        title = rg.get(\"title\", \"\")\n        year = _year_from_date(rg)\n        rels = rg.get(\"relations\", [])\n        discogs_master_id = _discogs_master_from_rels(rels)\n        \n        album = StudioAlbum(\n            title=title,\n            year=year,\n            discogs_master_id=discogs_master_id,\n            artist_name=artist_name,\n            rating=None,\n            votes=None\n        )\n        studio_albums.append(album)\n    \n    albums_with_discogs = []\n    albums_without_discogs = []\n    \n    for album in studio_albums:\n        if album.discogs_master_id:\n            albums_with_discogs.append(album)\n        else:\n            albums_without_discogs.append(album)\n    \n    for album in albums_without_discogs:\n        master_id = _search_discogs_master(artist_name, album.title, discogs_key, discogs_secret, csv_mode)\n        if master_id:\n            album.discogs_master_id = master_id\n            album.discogs_type = \"master\"\n            albums_with_discogs.append(album)\n        else:\n            release_id = _search_discogs_release(artist_name, album.title, discogs_key, discogs_secret, csv_mode)\n            if release_id:\n                album.discogs_release_id = release_id\n                album.discogs_type = \"release\"\n                albums_with_discogs.append(album)\n    \n    def fetch_data(album: StudioAlbum) -> StudioAlbum:\n        print(f\"[ALBUM] Fetching rating for '{album.title}' ({album.year}) by {album.artist_name}\")\n        \n        if album.discogs_type == \"master\" and album.discogs_master_id:\n            rating, votes, cover_image = _discogs_master_data(album.discogs_master_id, discogs_key, discogs_secret, csv_mode)\n        elif album.discogs_type == \"release\" and album.discogs_release_id:\n            rating, votes, cover_image = _discogs_release_data(album.discogs_release_id, discogs_key, discogs_secret, csv_mode)\n        else:\n            print(f\"[ALBUM] '{album.title}': No Discogs ID available\")\n            rating, votes, cover_image = None, None, None\n        \n        album.rating = rating\n        album.votes = votes\n        album.cover_image = cover_image\n        \n        if rating is not None:\n            print(f\"[ALBUM] ‚úì '{album.title}': FINAL rating={rating}, votes={votes}\")\n        else:\n            print(f\"[ALBUM] ‚úó '{album.title}': NO RATING - will be discarded\")\n        \n        return album\n    \n    # CSV mode: ultra-conservative (1 worker, slow)\n    # Normal mode: fast (5 workers, parallel)\n    max_workers = 1 if csv_mode else 5\n    \n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        future_to_album = {executor.submit(fetch_data, album): album for album in albums_with_discogs}\n        for future in as_completed(future_to_album):\n            try:\n                future.result()\n            except Exception:\n                pass\n    \n    rated_albums = [a for a in albums_with_discogs if a.rating is not None]\n    discarded_albums = [a for a in albums_with_discogs if a.rating is None]\n    rated_albums.sort(key=lambda a: (a.rating or 0, a.votes or 0), reverse=True)\n    \n    total_found = len(albums_with_discogs)\n    with_rating = len(rated_albums)\n    without_rating = len(discarded_albums)\n    \n    if without_rating > 0:\n        print(f\"[STATS] ‚ö†Ô∏è  {artist_name}: {without_rating} albums discarded (no rating from Discogs)\")\n        for album in discarded_albums:\n            print(f\"  - '{album.title}' ({album.year})\")\n    \n    if rated_albums and mbid:\n        artist_image = _get_artist_image_from_discogs(artist_name, discogs_key, discogs_secret, csv_mode)\n        _save_artist_albums(artist_name, mbid, rated_albums, artist_image)\n    \n    print(f\"[DB] ‚úì Saved {with_rating} albums for '{artist_name}' to cache (discarded {without_rating})\")\n    \n    return rated_albums[:top_n]\n\n\ndef get_artist_based_recommendations(artist_names: List[str], discogs_key: str,\n                                      discogs_secret: str, top_per_artist: int = 3,\n                                      progress_callback=None) -> List[Dict[str, Any]]:\n    all_albums: List[StudioAlbum] = []\n    \n    for idx, artist_name in enumerate(artist_names, 1):\n        if progress_callback:\n            progress_callback(idx, artist_name)\n        \n        artist_albums = get_artist_studio_albums(artist_name, discogs_key, discogs_secret, top_n=top_per_artist)\n        all_albums.extend(artist_albums)\n    \n    all_albums.sort(key=lambda a: (a.rating or 0, a.votes or 0), reverse=True)\n    \n    recommendations = []\n    for album in all_albums:\n        rec = {\n            \"album_name\": album.title,\n            \"artist_name\": album.artist_name,\n            \"year\": album.year,\n            \"rating\": album.rating,\n            \"votes\": album.votes,\n            \"discogs_master_id\": album.discogs_master_id or album.discogs_release_id,\n            \"discogs_type\": album.discogs_type,\n            \"image_url\": album.cover_image or \"https://via.placeholder.com/300x300?text=No+Cover\",\n            \"source\": \"artist_based\"\n        }\n        recommendations.append(rec)\n    \n    return recommendations\n","size_bytes":20671},"gateway/static/artist-search.js":{"content":"class ArtistSearch {\n    constructor(containerId, options = {}) {\n        this.container = document.getElementById(containerId);\n        this.options = {\n            minArtists: options.minArtists || 3,\n            maxArtists: options.maxArtists || 10,\n            onSelectionChange: options.onSelectionChange || (() => {}),\n            onContinue: options.onContinue || null,\n            ...options\n        };\n        \n        this.selectedArtists = [];\n        this.searchResults = [];\n        this.searchTimeout = null;\n        this.recommendationsCache = {};\n        this.loadingArtists = new Set();\n        this.pendingPromises = new Map();\n        \n        this.render();\n        this.attachEventListeners();\n    }\n    \n    render() {\n        this.container.innerHTML = `\n            <div class=\"artist-search-modal\">\n                <div class=\"artist-search-header\">\n                    <h2>Selecciona entre ${this.options.minArtists} y ${this.options.maxArtists} artistas. Puedes buscar o elegir de los sugeridos.</h2>\n                </div>\n                \n                <div class=\"artist-search-input-wrapper\">\n                    <input \n                        type=\"text\" \n                        id=\"artist-search-input\" \n                        placeholder=\"Escribe al menos 4 caracteres...\" \n                        class=\"artist-search-input\"\n                        autocomplete=\"off\"\n                    />\n                    <button id=\"clear-search-btn\" class=\"clear-search-btn\" style=\"display: none;\">‚úï</button>\n                </div>\n                \n                <div id=\"search-results-container\" class=\"search-results-container\">\n                    <div class=\"search-results-label\">Resultados de b√∫squeda</div>\n                    <div id=\"search-results-grid\" class=\"artist-grid\"></div>\n                </div>\n                \n                <div class=\"selected-artists-section\">\n                    <div class=\"selected-artists-header\">\n                        <span>Artistas seleccionados (m√≠n. ${this.options.minArtists}, m√°x. ${this.options.maxArtists})</span>\n                        <span id=\"artist-counter\" class=\"artist-counter\">0/${this.options.maxArtists} seleccionados</span>\n                    </div>\n                    <div id=\"selected-artists-pills\" class=\"selected-artists-pills\"></div>\n                </div>\n                \n                ${this.options.onContinue ? `\n                    <button id=\"continue-btn\" class=\"continue-btn\" disabled>\n                        Continuar\n                    </button>\n                ` : ''}\n            </div>\n        `;\n    }\n    \n    attachEventListeners() {\n        const searchInput = document.getElementById('artist-search-input');\n        const clearBtn = document.getElementById('clear-search-btn');\n        const continueBtn = document.getElementById('continue-btn');\n        \n        searchInput.addEventListener('input', (e) => {\n            const query = e.target.value.trim();\n            \n            if (query.length > 0) {\n                clearBtn.style.display = 'block';\n            } else {\n                clearBtn.style.display = 'none';\n            }\n            \n            if (this.searchTimeout) {\n                clearTimeout(this.searchTimeout);\n            }\n            \n            if (query.length >= 4) {\n                this.searchTimeout = setTimeout(() => {\n                    this.performSearch(query);\n                }, 300);\n            } else {\n                this.clearSearchResults();\n            }\n        });\n        \n        if (clearBtn) {\n            clearBtn.addEventListener('click', () => {\n                searchInput.value = '';\n                clearBtn.style.display = 'none';\n                this.clearSearchResults();\n            });\n        }\n        \n        if (continueBtn) {\n            continueBtn.addEventListener('click', async () => {\n                if (this.options.onContinue && this.isValidSelection()) {\n                    await this.options.onContinue(this.selectedArtists);\n                }\n            });\n        }\n    }\n    \n    async performSearch(query) {\n        const resultsGrid = document.getElementById('search-results-grid');\n        resultsGrid.innerHTML = '<div class=\"loading\">Buscando...</div>';\n        \n        try {\n            const response = await fetch(`/api/lastfm/search?q=${encodeURIComponent(query)}`);\n            const data = await response.json();\n            \n            this.searchResults = data.artists || [];\n            this.renderSearchResults();\n        } catch (error) {\n            console.error('Search failed:', error);\n            resultsGrid.innerHTML = '<div class=\"error\">Error al buscar artistas</div>';\n        }\n    }\n    \n    renderSearchResults() {\n        const resultsGrid = document.getElementById('search-results-grid');\n        \n        if (this.searchResults.length === 0) {\n            resultsGrid.innerHTML = '<div class=\"no-results\">No se encontraron artistas</div>';\n            return;\n        }\n        \n        resultsGrid.innerHTML = this.searchResults.map(artist => {\n            const isSelected = this.selectedArtists.some(a => a.name === artist.name);\n            const isDisabled = !isSelected && this.selectedArtists.length >= this.options.maxArtists;\n            \n            return `\n                <div class=\"artist-card ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}\" \n                     data-artist-name=\"${artist.name}\">\n                    <div class=\"artist-card-content\">\n                        <div class=\"artist-image-wrapper\">\n                            ${artist.image_url \n                                ? `<img src=\"${artist.image_url}\" alt=\"${artist.name}\" class=\"artist-image\" />`\n                                : `<div class=\"artist-image-placeholder\">üéµ</div>`\n                            }\n                        </div>\n                        <div class=\"artist-info\">\n                            <div class=\"artist-name\">${artist.name}</div>\n                            ${artist.genres && artist.genres.length > 0 \n                                ? `<div class=\"artist-genres\">${artist.genres.join(', ')}</div>`\n                                : ''\n                            }\n                        </div>\n                    </div>\n                    <button class=\"add-artist-btn ${isSelected ? 'added' : ''}\" \n                            ${isDisabled ? 'disabled' : ''}\n                            data-artist='${JSON.stringify(artist)}'>\n                        ${isSelected ? '‚úì' : '+'}\n                    </button>\n                </div>\n            `;\n        }).join('');\n        \n        this.attachArtistCardListeners();\n    }\n    \n    attachArtistCardListeners() {\n        const addButtons = document.querySelectorAll('.add-artist-btn');\n        \n        addButtons.forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                const artist = JSON.parse(btn.dataset.artist);\n                const isSelected = this.selectedArtists.some(a => a.name === artist.name);\n                \n                if (isSelected) {\n                    this.removeArtist(artist.name);\n                } else if (this.selectedArtists.length < this.options.maxArtists) {\n                    this.addArtist(artist);\n                }\n            });\n        });\n    }\n    \n    async addArtist(artist) {\n        if (this.selectedArtists.length >= this.options.maxArtists) {\n            return;\n        }\n        \n        if (!this.selectedArtists.some(a => a.name === artist.name)) {\n            this.selectedArtists.push(artist);\n            this.loadingArtists.add(artist.name);\n            this.updateUI();\n            \n            const fetchPromise = (async () => {\n                try {\n                    const response = await fetch('/api/recommendations/artist-single', {\n                        method: 'POST',\n                        headers: { 'Content-Type': 'application/json' },\n                        body: JSON.stringify({ artist_name: artist.name, top_albums: 3 })\n                    });\n                    \n                    if (response.ok) {\n                        const data = await response.json();\n                        const recs = data.recommendations || [];\n                        if (recs.length > 0) {\n                            this.recommendationsCache[artist.name] = {\n                                status: 'success',\n                                recommendations: recs,\n                                timestamp: Date.now()\n                            };\n                            console.log(`‚úì Cached ${recs.length} recommendations for ${artist.name}`);\n                        } else {\n                            this.recommendationsCache[artist.name] = {\n                                status: 'error',\n                                error: 'No albums found',\n                                timestamp: Date.now()\n                            };\n                            console.warn(`‚ö† No albums found for ${artist.name}`);\n                        }\n                    } else {\n                        const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));\n                        this.recommendationsCache[artist.name] = {\n                            status: 'error',\n                            error: errorData.detail || `HTTP ${response.status}`,\n                            timestamp: Date.now()\n                        };\n                        console.error(`‚úó Failed to get recommendations for ${artist.name}: ${errorData.detail}`);\n                    }\n                } catch (error) {\n                    this.recommendationsCache[artist.name] = {\n                        status: 'error',\n                        error: error.message || 'Network error',\n                        timestamp: Date.now()\n                    };\n                    console.error(`‚úó Error fetching recommendations for ${artist.name}:`, error);\n                } finally {\n                    this.loadingArtists.delete(artist.name);\n                    this.pendingPromises.delete(artist.name);\n                    this.updateUI();\n                }\n            })();\n            \n            this.pendingPromises.set(artist.name, fetchPromise);\n        }\n    }\n    \n    removeArtist(artistName) {\n        this.selectedArtists = this.selectedArtists.filter(a => a.name !== artistName);\n        delete this.recommendationsCache[artistName];\n        this.loadingArtists.delete(artistName);\n        this.pendingPromises.delete(artistName);\n        console.log(`‚úó Removed ${artistName} and its cached recommendations`);\n        this.updateUI();\n    }\n    \n    async waitForAllPendingRecommendations() {\n        if (this.pendingPromises.size === 0) {\n            return;\n        }\n        \n        console.log(`‚è≥ Waiting for ${this.pendingPromises.size} pending recommendations to complete...`);\n        const allPromises = Array.from(this.pendingPromises.values());\n        await Promise.allSettled(allPromises);\n        console.log('‚úì All pending recommendations completed');\n    }\n    \n    updateUI() {\n        this.renderSelectedArtists();\n        this.renderSearchResults();\n        this.updateCounter();\n        this.updateContinueButton();\n        this.options.onSelectionChange(this.selectedArtists);\n    }\n    \n    renderSelectedArtists() {\n        const pillsContainer = document.getElementById('selected-artists-pills');\n        \n        if (this.selectedArtists.length === 0) {\n            pillsContainer.innerHTML = '<div class=\"no-selection\">A√∫n no has seleccionado artistas</div>';\n            return;\n        }\n        \n        pillsContainer.innerHTML = this.selectedArtists.map(artist => {\n            const isLoading = this.loadingArtists.has(artist.name);\n            const cached = this.recommendationsCache[artist.name];\n            const hasSuccess = cached && cached.status === 'success';\n            const hasError = cached && cached.status === 'error';\n            \n            return `\n                <div class=\"artist-pill ${isLoading ? 'loading' : ''} ${hasSuccess ? 'cached' : ''} ${hasError ? 'error' : ''}\">\n                    ${artist.image_url \n                        ? `<img src=\"${artist.image_url}\" alt=\"${artist.name}\" class=\"pill-image\" />`\n                        : ''\n                    }\n                    <span class=\"pill-name\">${artist.name}</span>\n                    ${isLoading ? '<span class=\"pill-spinner\">‚è≥</span>' : ''}\n                    ${!isLoading && hasSuccess ? '<span class=\"pill-check\">‚úì</span>' : ''}\n                    ${!isLoading && hasError ? '<span class=\"pill-error\" title=\"' + (cached.error || 'Error') + '\">‚ö†</span>' : ''}\n                    <button class=\"pill-remove-btn\" data-artist-name=\"${artist.name}\">‚úï</button>\n                </div>\n            `;\n        }).join('');\n        \n        const removeButtons = pillsContainer.querySelectorAll('.pill-remove-btn');\n        removeButtons.forEach(btn => {\n            btn.addEventListener('click', () => {\n                this.removeArtist(btn.dataset.artistName);\n            });\n        });\n    }\n    \n    updateCounter() {\n        const counter = document.getElementById('artist-counter');\n        if (counter) {\n            counter.textContent = `${this.selectedArtists.length}/${this.options.maxArtists} seleccionados`;\n        }\n    }\n    \n    updateContinueButton() {\n        const continueBtn = document.getElementById('continue-btn');\n        if (continueBtn) {\n            const isValid = this.isValidSelection();\n            const isLoading = this.loadingArtists.size > 0;\n            continueBtn.disabled = !isValid || isLoading;\n            \n            if (isLoading && isValid) {\n                continueBtn.textContent = `Cargando ${this.loadingArtists.size}...`;\n            } else {\n                continueBtn.textContent = 'Continuar';\n            }\n        }\n    }\n    \n    isValidSelection() {\n        return this.selectedArtists.length >= this.options.minArtists && \n               this.selectedArtists.length <= this.options.maxArtists;\n    }\n    \n    clearSearchResults() {\n        const resultsGrid = document.getElementById('search-results-grid');\n        resultsGrid.innerHTML = '';\n        this.searchResults = [];\n    }\n    \n    getSelectedArtists() {\n        return this.selectedArtists;\n    }\n    \n    setSelectedArtists(artists) {\n        this.selectedArtists = artists;\n        this.updateUI();\n    }\n    \n    async restoreArtists(artistNames) {\n        console.log(`üîÑ Restoring ${artistNames.length} artists:`, artistNames);\n        \n        const fetchAndAddArtist = async (name) => {\n            try {\n                const response = await fetch(`/api/lastfm/artist/search?query=${encodeURIComponent(name)}&limit=1`);\n                if (response.ok) {\n                    const data = await response.json();\n                    if (data.artists && data.artists.length > 0) {\n                        const artist = data.artists[0];\n                        console.log(`‚úì Restored artist: ${artist.name}`);\n                        await this.addArtist(artist);\n                        return { success: true, name };\n                    } else {\n                        console.warn(`‚ö† Could not find artist ${name} in Last.fm`);\n                        return { success: false, name, reason: 'Not found' };\n                    }\n                } else {\n                    console.error(`‚úó Failed to search for ${name} (HTTP ${response.status})`);\n                    return { success: false, name, reason: `HTTP ${response.status}` };\n                }\n            } catch (error) {\n                console.error(`‚úó Error restoring artist ${name}:`, error);\n                return { success: false, name, reason: error.message };\n            }\n        };\n        \n        const results = await Promise.all(artistNames.map(fetchAndAddArtist));\n        const successful = results.filter(r => r.success).length;\n        const failed = results.filter(r => !r.success);\n        \n        console.log(`‚úì Restored ${successful}/${artistNames.length} artists successfully`);\n        if (failed.length > 0) {\n            console.warn(`‚ö† Failed to restore ${failed.length} artists:`, failed);\n        }\n    }\n    \n    getCachedRecommendations() {\n        const allRecommendations = [];\n        for (const artistName of this.selectedArtists.map(a => a.name)) {\n            const cached = this.recommendationsCache[artistName];\n            if (cached && cached.status === 'success' && cached.recommendations) {\n                allRecommendations.push(...cached.recommendations);\n            }\n        }\n        return allRecommendations;\n    }\n    \n    isLoadingComplete() {\n        if (this.loadingArtists.size > 0) {\n            return false;\n        }\n        return this.selectedArtists.every(artist => {\n            const cached = this.recommendationsCache[artist.name];\n            return cached !== undefined;\n        });\n    }\n    \n    hasAllSuccessful() {\n        if (this.selectedArtists.length === 0) {\n            return false;\n        }\n        return this.selectedArtists.every(artist => {\n            const cached = this.recommendationsCache[artist.name];\n            return cached && cached.status === 'success';\n        });\n    }\n    \n    getLoadingStatus() {\n        const successCount = this.selectedArtists.filter(artist => {\n            const cached = this.recommendationsCache[artist.name];\n            return cached && cached.status === 'success';\n        }).length;\n        \n        const errorCount = this.selectedArtists.filter(artist => {\n            const cached = this.recommendationsCache[artist.name];\n            return cached && cached.status === 'error';\n        }).length;\n        \n        return {\n            total: this.selectedArtists.length,\n            success: successCount,\n            error: errorCount,\n            loading: this.loadingArtists.size,\n            isComplete: this.isLoadingComplete(),\n            hasAllSuccessful: this.hasAllSuccessful()\n        };\n    }\n}\n","size_bytes":18253},"services/lastfm/main.py":{"content":"import os\nimport sys\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))\n\nfrom fastapi import FastAPI, HTTPException\nfrom contextlib import asynccontextmanager\nfrom typing import List\nfrom pydantic import BaseModel\nfrom libs.shared.utils import log_event\nfrom .auth import LastFMAuthManager\nfrom .lastfm_client import LastFMClient\n\n\nfrom typing import Dict\nimport time\nimport asyncio\n\nauth_managers: Dict[str, tuple[LastFMAuthManager, float]] = {}\nlastfm_clients: Dict[str, LastFMClient] = {}\nAUTH_TOKEN_TTL = 600\n\n\nasync def cleanup_expired_tokens():\n    \"\"\"Remove expired auth tokens (older than 10 minutes)\"\"\"\n    while True:\n        try:\n            await asyncio.sleep(60)\n            now = time.time()\n            expired = [token for token, (_, created) in auth_managers.items() if now - created > AUTH_TOKEN_TTL]\n            for token in expired:\n                log_event(\"lastfm-service\", \"INFO\", f\"Removing expired auth token: {token[:10]}...\")\n                del auth_managers[token]\n        except Exception as e:\n            log_event(\"lastfm-service\", \"ERROR\", f\"Error cleaning tokens: {str(e)}\")\n\n\nclass TimeRangeRequest(BaseModel):\n    time_range: str = \"medium_term\"\n    username: str\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    log_event(\"lastfm-service\", \"INFO\", \"Starting Last.fm service\")\n    cleanup_task = asyncio.create_task(cleanup_expired_tokens())\n    try:\n        yield\n    finally:\n        cleanup_task.cancel()\n        try:\n            await cleanup_task\n        except asyncio.CancelledError:\n            pass\n        for client in list(lastfm_clients.values()):\n            await client.close()\n        log_event(\"lastfm-service\", \"INFO\", \"Shutting down Last.fm service\")\n\n\napp = FastAPI(lifespan=lifespan)\n\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\", \"service\": \"lastfm\"}\n\n\n@app.get(\"/auth/url\")\nasync def get_auth_url():\n    try:\n        temp_auth = LastFMAuthManager()\n        token = await temp_auth.get_token()\n        if not token:\n            raise HTTPException(status_code=500, detail=\"Failed to get Last.fm token\")\n        \n        auth_url = temp_auth.get_auth_url(token)\n        auth_managers[token] = (temp_auth, time.time())\n        log_event(\"lastfm-service\", \"INFO\", f\"Generated auth URL with token: {token[:10]}...\")\n        \n        return {\n            \"auth_url\": auth_url,\n            \"token\": token\n        }\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Failed to generate auth URL: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/auth/callback\")\nasync def auth_callback(token: str):\n    try:\n        if token not in auth_managers:\n            raise HTTPException(status_code=400, detail=\"Invalid token\")\n        \n        auth_manager, created_time = auth_managers[token]\n        \n        if time.time() - created_time > AUTH_TOKEN_TTL:\n            del auth_managers[token]\n            raise HTTPException(status_code=400, detail=\"Token expired\")\n        \n        success = await auth_manager.get_session(token)\n        if not success:\n            raise HTTPException(status_code=400, detail=\"Failed to get session\")\n        \n        username = auth_manager.get_username()\n        log_event(\"lastfm-service\", \"INFO\", f\"User authenticated: {username}\")\n        \n        if username in lastfm_clients:\n            log_event(\"lastfm-service\", \"INFO\", f\"Closing existing client for {username}\")\n            old_client = lastfm_clients[username]\n            await old_client.close()\n            del lastfm_clients[username]\n        \n        api_key = os.getenv(\"LASTFM_API_KEY\")\n        client = LastFMClient(api_key, username)\n        await client.start()\n        lastfm_clients[username] = client\n        \n        del auth_managers[token]\n        \n        return {\n            \"status\": \"success\",\n            \"username\": username\n        }\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Auth callback failed: {str(e)}\")\n        if token in auth_managers:\n            del auth_managers[token]\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.get(\"/auth/status\")\nasync def auth_status(username: str = None):\n    if username and username in lastfm_clients:\n        return {\n            \"authenticated\": True,\n            \"username\": username\n        }\n    return {\n        \"authenticated\": False,\n        \"username\": None\n    }\n\n\n@app.post(\"/top-tracks\")\nasync def get_top_tracks(request: TimeRangeRequest):\n    if request.username not in lastfm_clients:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    client = lastfm_clients[request.username]\n    \n    period_map = {\n        \"short_term\": \"7day\",\n        \"medium_term\": \"3month\",\n        \"long_term\": \"12month\"\n    }\n    \n    period = period_map.get(request.time_range, \"3month\")\n    \n    try:\n        tracks = await client.get_top_tracks(period=period)\n        log_event(\"lastfm-service\", \"INFO\", f\"Retrieved {len(tracks)} top tracks for {request.username}, period={period}\")\n        return {\"tracks\": tracks, \"total\": len(tracks)}\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Failed to get top tracks: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/top-artists\")\nasync def get_top_artists(request: TimeRangeRequest):\n    if request.username not in lastfm_clients:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    client = lastfm_clients[request.username]\n    \n    period_map = {\n        \"short_term\": \"7day\",\n        \"medium_term\": \"3month\",\n        \"long_term\": \"12month\"\n    }\n    \n    period = period_map.get(request.time_range, \"3month\")\n    \n    try:\n        artists = await client.get_top_artists(period=period)\n        log_event(\"lastfm-service\", \"INFO\", f\"Retrieved {len(artists)} top artists for {request.username}, period={period}\")\n        return {\"artists\": artists, \"total\": len(artists)}\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Failed to get top artists: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.post(\"/top-albums\")\nasync def get_top_albums(request: TimeRangeRequest):\n    if request.username not in lastfm_clients:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    client = lastfm_clients[request.username]\n    \n    period_map = {\n        \"short_term\": \"7day\",\n        \"medium_term\": \"3month\",\n        \"long_term\": \"12month\"\n    }\n    \n    period = period_map.get(request.time_range, \"3month\")\n    \n    try:\n        albums = await client.get_top_albums(period=period)\n        log_event(\"lastfm-service\", \"INFO\", f\"Retrieved {len(albums)} top albums for {request.username}, period={period}\")\n        return {\"albums\": albums, \"total\": len(albums)}\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Failed to get top albums: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.get(\"/search\")\nasync def search_artists(q: str):\n    \"\"\"Search for artists (public endpoint, no auth required)\"\"\"\n    if len(q) < 2:\n        raise HTTPException(status_code=400, detail=\"Query must be at least 2 characters\")\n    \n    try:\n        api_key = os.getenv(\"LASTFM_API_KEY\")\n        temp_client = LastFMClient(api_key, \"public\")\n        await temp_client.start()\n        \n        try:\n            artists = await temp_client.search_artist(q)\n            log_event(\"lastfm-service\", \"INFO\", f\"Found {len(artists)} artists for query: {q}\")\n            return {\"artists\": artists, \"total\": len(artists)}\n        finally:\n            await temp_client.close()\n    except Exception as e:\n        log_event(\"lastfm-service\", \"ERROR\", f\"Artist search failed: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n","size_bytes":7906},"scripts/seed_database.py":{"content":"import json\nimport os\nimport time\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nimport httpx\nimport re\nfrom typing import Optional, Dict, Any, List, Tuple\n\nMB_BASE = \"https://musicbrainz.org/ws/2\"\nDISCOGS_BASE = \"https://api.discogs.com\"\nHEADERS = {\"User-Agent\": \"VinylRecommendationSystem/1.0\"}\n\nDISCOGS_KEY = os.getenv(\"DISCOGS_CONSUMER_KEY\", \"\")\nDISCOGS_SECRET = os.getenv(\"DISCOGS_CONSUMER_SECRET\", \"\")\n\n_RE_DISCOGS_MASTER = re.compile(\n    r\"https?://(?:www\\.)?discogs\\.com/(?:[a-z]{2}/)?master/(\\d+)\", re.I\n)\n\nCLIENT = httpx.Client(\n    headers=HEADERS,\n    http2=False,\n    timeout=httpx.Timeout(30.0),\n    limits=httpx.Limits(max_connections=10, max_keepalive_connections=10),\n    follow_redirects=True,\n)\n\n\ndef get_db_connection():\n    \"\"\"Get PostgreSQL connection\"\"\"\n    return psycopg2.connect(os.getenv(\"DATABASE_URL\"))\n\n\ndef _mb_get(path: str, params: Dict[str, Any], tries: int = 5,\n            sleep_after_ok: float = 1.0) -> Dict[str, Any]:\n    \"\"\"MusicBrainz API call with retry\"\"\"\n    url = f\"{MB_BASE}{path}\"\n    params = {**params, \"fmt\": \"json\"}\n    last_exc = None\n    backoff = 0.6\n\n    for attempt in range(1, tries + 1):\n        try:\n            r = CLIENT.get(url, params=params)\n            if r.status_code in (429, 500, 502, 503, 504):\n                raise httpx.HTTPStatusError(\"Transient\", request=r.request, response=r)\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            time.sleep(backoff)\n            backoff = min(backoff * 1.7, 5.0)\n\n    raise RuntimeError(f\"MusicBrainz failed: {last_exc}\")\n\n\ndef _discogs_get(path: str, params: Dict[str, Any],\n                 sleep_after_ok: float = 0.5,\n                 tries: int = 5):\n    \"\"\"Discogs API call with retry and rate limiting\"\"\"\n    url = f\"{DISCOGS_BASE}{path}\"\n    params = {**params, \"key\": DISCOGS_KEY, \"secret\": DISCOGS_SECRET}\n    last_exc = None\n    backoff = 1.0\n    \n    for attempt in range(1, tries + 1):\n        try:\n            r = CLIENT.get(url, params=params)\n            if r.status_code == 429:\n                if attempt < tries:\n                    print(f\"  [DISCOGS] Rate limit hit, retrying in {backoff}s... (attempt {attempt}/{tries})\")\n                    time.sleep(backoff)\n                    backoff = min(backoff * 2.0, 10.0)\n                    continue\n            r.raise_for_status()\n            time.sleep(sleep_after_ok)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            if attempt < tries:\n                time.sleep(backoff)\n                backoff = min(backoff * 2.0, 10.0)\n    \n    raise RuntimeError(f\"Discogs API failed after {tries} attempts: {last_exc}\")\n\n\ndef find_artist_mbid(name: str) -> Optional[str]:\n    \"\"\"Find artist MBID from MusicBrainz\"\"\"\n    try:\n        data = _mb_get(\"/artist\", {\"query\": f'artist:\"{name}\"', \"limit\": 10})\n        artists = data.get(\"artists\", []) or []\n        if not artists:\n            return None\n        exact = [a for a in artists if a.get(\"name\", \"\").lower() == name.lower()]\n        chosen = exact[0] if exact else artists[0]\n        return chosen.get(\"id\")\n    except Exception as e:\n        print(f\"  [ERROR] Could not find MBID for {name}: {e}\")\n        return None\n\n\ndef fetch_studio_albums(artist_mbid: str, artist_name: str) -> List[Dict[str, Any]]:\n    \"\"\"Fetch studio albums from MusicBrainz\"\"\"\n    try:\n        data = _mb_get(\n            \"/release-group\",\n            {\n                \"artist\": artist_mbid,\n                \"primary-type\": \"Album\",\n                \"inc\": \"artist-credits+url-rels\",\n                \"limit\": 100,\n            }\n        )\n        release_groups = data.get(\"release-groups\", []) or []\n        \n        studio_albums = []\n        for rg in release_groups:\n            if rg.get(\"primary-type\") != \"Album\":\n                continue\n            if rg.get(\"secondary-types\"):\n                continue\n            \n            ac = rg.get(\"artist-credit\") or []\n            if len(ac) != 1:\n                continue\n            if (ac[0].get(\"artist\") or {}).get(\"id\") != artist_mbid:\n                continue\n            \n            title = rg.get(\"title\", \"\")\n            first_release = rg.get(\"first-release-date\", \"\")\n            year = first_release.split(\"-\")[0] if first_release else \"\"\n            \n            relations = rg.get(\"relations\") or []\n            discogs_master_id = None\n            for rel in relations:\n                if rel.get(\"type\") == \"discogs\":\n                    url = (rel.get(\"url\") or {}).get(\"resource\", \"\")\n                    m = _RE_DISCOGS_MASTER.search(url)\n                    if m:\n                        discogs_master_id = m.group(1)\n                        break\n            \n            studio_albums.append({\n                \"title\": title,\n                \"year\": year,\n                \"discogs_master_id\": discogs_master_id\n            })\n        \n        return studio_albums\n    except Exception as e:\n        print(f\"  [ERROR] Could not fetch albums for {artist_name}: {e}\")\n        return []\n\n\ndef get_discogs_master_data(master_id: str) -> Tuple[Optional[float], Optional[int], Optional[str]]:\n    \"\"\"Get rating, votes, and cover from Discogs master\"\"\"\n    if not master_id:\n        return None, None, None\n    \n    try:\n        data = _discogs_get(f\"/masters/{master_id}\", {})\n        r = (data.get(\"community\") or {}).get(\"rating\") or {}\n        \n        cover_url = None\n        images = data.get(\"images\", [])\n        if images and len(images) > 0:\n            cover_url = images[0].get(\"uri\")\n        \n        rating = float(r[\"average\"]) if r.get(\"average\") is not None else None\n        votes = int(r.get(\"count\", 0)) if r.get(\"average\") is not None else None\n        \n        return rating, votes, cover_url\n    except Exception as e:\n        print(f\"  [WARNING] Could not get Discogs data for master {master_id}: {e}\")\n        return None, None, None\n\n\ndef get_artist_image_from_discogs(artist_name: str) -> Optional[str]:\n    \"\"\"Get artist image from Discogs search\"\"\"\n    try:\n        data = _discogs_get(\"/database/search\", {\n            \"q\": artist_name,\n            \"type\": \"artist\",\n            \"per_page\": 1\n        })\n        results = data.get(\"results\", [])\n        if results:\n            return results[0].get(\"cover_image\")\n    except Exception as e:\n        print(f\"  [WARNING] Could not get artist image for {artist_name}: {e}\")\n    return None\n\n\ndef seed_artist(artist_name: str):\n    \"\"\"Seed a single artist with all albums\"\"\"\n    conn = get_db_connection()\n    \n    try:\n        cursor = conn.cursor(cursor_factory=RealDictCursor)\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"Processing: {artist_name}\")\n        print(f\"{'='*60}\")\n        \n        cursor.execute(\"SELECT id FROM artists WHERE name = %s\", (artist_name,))\n        existing = cursor.fetchone()\n        if existing:\n            print(f\"‚úì Artist '{artist_name}' already exists in database (ID: {existing['id']}), skipping...\")\n            return\n        \n        print(f\"[1/4] Finding MusicBrainz ID...\")\n        mbid = find_artist_mbid(artist_name)\n        if not mbid:\n            print(f\"‚úó Could not find MBID for {artist_name}, skipping...\")\n            return\n        print(f\"‚úì Found MBID: {mbid}\")\n        \n        print(f\"[2/4] Fetching discography...\")\n        albums = fetch_studio_albums(mbid, artist_name)\n        print(f\"‚úì Found {len(albums)} studio albums\")\n        \n        print(f\"[3/4] Getting artist image...\")\n        image_url = get_artist_image_from_discogs(artist_name)\n        if image_url:\n            print(f\"‚úì Got artist image\")\n        \n        print(f\"[4/4] Saving to database...\")\n        cursor.execute(\n            \"INSERT INTO artists (name, mbid, image_url) VALUES (%s, %s, %s) RETURNING id\",\n            (artist_name, mbid, image_url)\n        )\n        artist_id = cursor.fetchone()[\"id\"]\n        print(f\"‚úì Artist saved (ID: {artist_id})\")\n        \n        albums_saved = 0\n        for i, album in enumerate(albums, 1):\n            print(f\"  [{i}/{len(albums)}] Processing: {album['title']} ({album['year']})\")\n            \n            rating, votes, cover_url = None, None, None\n            if album[\"discogs_master_id\"]:\n                rating, votes, cover_url = get_discogs_master_data(album[\"discogs_master_id\"])\n                if rating:\n                    print(f\"    ‚úì Rating: {rating:.1f}/5 ({votes} votes)\")\n            \n            cursor.execute(\n                \"\"\"INSERT INTO albums (artist_id, title, year, discogs_master_id, rating, votes, cover_url) \n                   VALUES (%s, %s, %s, %s, %s, %s, %s)\n                   ON CONFLICT (artist_id, title, year) DO NOTHING\"\"\",\n                (artist_id, album[\"title\"], album[\"year\"], album[\"discogs_master_id\"], rating, votes, cover_url)\n            )\n            albums_saved += 1\n        \n        conn.commit()\n        print(f\"‚úì Saved {albums_saved} albums for {artist_name}\")\n        print(f\"{'='*60}\\n\")\n    \n    finally:\n        conn.close()\n\n\ndef main():\n    \"\"\"Main seeding function\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"VINYL RECOMMENDATION SYSTEM - DATABASE SEEDER\")\n    print(\"=\"*60 + \"\\n\")\n    \n    if not DISCOGS_KEY or not DISCOGS_SECRET:\n        print(\"‚úó ERROR: DISCOGS_CONSUMER_KEY and DISCOGS_CONSUMER_SECRET environment variables must be set\")\n        return\n    \n    with open(\"seed_artists.json\", \"r\") as f:\n        artist_names = json.load(f)\n    \n    print(f\"üìã Loaded {len(artist_names)} artists to seed\")\n    print(f\"‚è±Ô∏è  Estimated time: ~{len(artist_names) * 2} minutes (with rate limiting)\\n\")\n    \n    successful = 0\n    failed = 0\n    \n    for i, artist_name in enumerate(artist_names, 1):\n        print(f\"[{i}/{len(artist_names)}] \", end=\"\")\n        try:\n            seed_artist(artist_name)\n            successful += 1\n        except Exception as e:\n            print(f\"‚úó FAILED to seed {artist_name}: {e}\")\n            failed += 1\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"SEEDING COMPLETE\")\n    print(\"=\"*60)\n    print(f\"‚úì Successful: {successful}\")\n    print(f\"‚úó Failed: {failed}\")\n    print(f\"üìä Total: {len(artist_names)}\")\n    print(\"=\"*60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":10304},"scripts/update_missing_ratings.py":{"content":"import os\nimport time\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nimport httpx\nfrom typing import Optional, Tuple\n\nDISCOGS_BASE = \"https://api.discogs.com\"\nDISCOGS_KEY = os.getenv(\"DISCOGS_CONSUMER_KEY\", \"\")\nDISCOGS_SECRET = os.getenv(\"DISCOGS_CONSUMER_SECRET\", \"\")\n\nHEADERS = {\"User-Agent\": \"VinylRecommendationSystem/1.0\"}\n\nCLIENT = httpx.Client(\n    headers=HEADERS,\n    http2=False,\n    timeout=httpx.Timeout(30.0),\n    limits=httpx.Limits(max_connections=10, max_keepalive_connections=10),\n    follow_redirects=True,\n)\n\n\ndef get_db_connection():\n    \"\"\"Get PostgreSQL connection\"\"\"\n    return psycopg2.connect(os.getenv(\"DATABASE_URL\"))\n\n\ndef _discogs_get(path: str, params: dict, tries: int = 5):\n    \"\"\"Discogs API call with retry and rate limiting\"\"\"\n    url = f\"{DISCOGS_BASE}{path}\"\n    params = {**params, \"key\": DISCOGS_KEY, \"secret\": DISCOGS_SECRET}\n    last_exc = None\n    backoff = 1.0\n    \n    for attempt in range(1, tries + 1):\n        try:\n            r = CLIENT.get(url, params=params)\n            if r.status_code == 429:\n                if attempt < tries:\n                    print(f\"  [DISCOGS] Rate limit, retry in {backoff}s... ({attempt}/{tries})\")\n                    time.sleep(backoff)\n                    backoff = min(backoff * 2.0, 10.0)\n                    continue\n            r.raise_for_status()\n            time.sleep(0.5)\n            return r.json()\n        except Exception as e:\n            last_exc = e\n            if attempt < tries:\n                time.sleep(backoff)\n                backoff = min(backoff * 2.0, 10.0)\n    \n    raise RuntimeError(f\"Discogs API failed: {last_exc}\")\n\n\ndef get_discogs_master_rating(master_id: str) -> Tuple[Optional[float], Optional[int], Optional[str]]:\n    \"\"\"Get rating, votes, and cover from Discogs master\"\"\"\n    if not master_id:\n        return None, None, None\n    \n    try:\n        data = _discogs_get(f\"/masters/{master_id}\", {})\n        r = (data.get(\"community\") or {}).get(\"rating\") or {}\n        \n        cover_url = None\n        images = data.get(\"images\", [])\n        if images and len(images) > 0:\n            cover_url = images[0].get(\"uri\")\n        \n        if r.get(\"average\") is not None:\n            rating = float(r[\"average\"])\n            votes = int(r.get(\"count\", 0))\n            return rating, votes, cover_url\n        \n        # Fallback to main_release if master has no rating\n        main_rel = data.get(\"main_release\")\n        if not main_rel:\n            return None, None, cover_url\n        \n        rel = _discogs_get(f\"/releases/{main_rel}\", {})\n        rr = (rel.get(\"community\") or {}).get(\"rating\") or {}\n        \n        if not cover_url:\n            rel_images = rel.get(\"images\", [])\n            if rel_images and len(rel_images) > 0:\n                cover_url = rel_images[0].get(\"uri\")\n        \n        if rr.get(\"average\") is not None:\n            rating = float(rr[\"average\"])\n            votes = int(rr.get(\"count\", 0))\n            return rating, votes, cover_url\n        \n        return None, None, cover_url\n    \n    except Exception as e:\n        print(f\"  [ERROR] Master {master_id}: {e}\")\n        return None, None, None\n\n\ndef main():\n    print(\"\\n\" + \"=\"*60)\n    print(\"ACTUALIZACI√ìN DE RATINGS FALTANTES\")\n    print(\"=\"*60 + \"\\n\")\n    \n    if not DISCOGS_KEY or not DISCOGS_SECRET:\n        print(\"‚úó ERROR: DISCOGS credentials not found\")\n        return\n    \n    conn = get_db_connection()\n    cursor = conn.cursor(cursor_factory=RealDictCursor)\n    \n    # Get albums without rating\n    cursor.execute(\"\"\"\n        SELECT a.id, a.title, a.year, a.discogs_master_id, ar.name as artist_name\n        FROM albums a\n        JOIN artists ar ON a.artist_id = ar.id\n        WHERE a.rating IS NULL AND a.discogs_master_id IS NOT NULL\n        ORDER BY ar.name, a.year\n    \"\"\")\n    \n    albums_to_update = cursor.fetchall()\n    total = len(albums_to_update)\n    \n    if total == 0:\n        print(\"‚úì No hay √°lbumes sin rating para actualizar\")\n        conn.close()\n        return\n    \n    print(f\"üìã Encontrados {total} √°lbumes sin rating\")\n    print(f\"‚è±Ô∏è  Tiempo estimado: ~{total * 0.6 / 60:.1f} minutos\\n\")\n    \n    updated = 0\n    failed = 0\n    no_rating = 0\n    \n    for i, album in enumerate(albums_to_update, 1):\n        print(f\"[{i}/{total}] {album['artist_name']} - {album['title']} ({album['year']})\")\n        \n        try:\n            rating, votes, cover_url = get_discogs_master_rating(album['discogs_master_id'])\n            \n            if rating is not None:\n                cursor.execute(\"\"\"\n                    UPDATE albums \n                    SET rating = %s, votes = %s, cover_url = COALESCE(cover_url, %s)\n                    WHERE id = %s\n                \"\"\", (rating, votes, cover_url, album['id']))\n                conn.commit()\n                print(f\"  ‚úì Rating: {rating:.2f}/5 ({votes} votos)\")\n                updated += 1\n            else:\n                print(f\"  ‚ö† Sin rating en Discogs\")\n                no_rating += 1\n        \n        except Exception as e:\n            print(f\"  ‚úó Error: {e}\")\n            failed += 1\n            conn.rollback()\n    \n    conn.close()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"ACTUALIZACI√ìN COMPLETA\")\n    print(\"=\"*60)\n    print(f\"‚úì Actualizados: {updated}\")\n    print(f\"‚ö† Sin rating: {no_rating}\")\n    print(f\"‚úó Fallidos: {failed}\")\n    print(f\"üìä Total: {total}\")\n    print(\"=\"*60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":5461},"scripts/import_artists_from_csv.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nScript para importar artistas desde un archivo CSV a la base de datos.\n\nFormato del CSV:\n--------------\nname\nRadiohead\nBlur\nPink Floyd\nThe Beatles\n\nO con encabezado opcional:\nname\nArtist Name 1\nArtist Name 2\n\nEl script:\n- Lee el CSV l√≠nea por l√≠nea\n- Consulta cada artista a trav√©s de la API para obtener √°lbumes con ratings\n- Guarda autom√°ticamente en PostgreSQL con imagen y ratings\n- Maneja errores por artista (si uno falla, contin√∫a con los dem√°s)\n- Respeta rate limiting de APIs externas\n\"\"\"\n\nimport csv\nimport httpx\nimport time\nimport sys\nfrom pathlib import Path\n\n\ndef import_artists_from_csv(csv_file_path: str, top_albums_per_artist: int = 10):\n    \"\"\"Import artists from CSV file\"\"\"\n    \n    csv_path = Path(csv_file_path)\n    if not csv_path.exists():\n        print(f\"‚úó ERROR: Archivo no encontrado: {csv_file_path}\")\n        print(f\"\\nUso: python scripts/import_artists_from_csv.py <archivo.csv>\")\n        return\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"IMPORTACI√ìN DE ARTISTAS DESDE CSV\")\n    print(\"=\"*60 + \"\\n\")\n    print(f\"üìÅ Archivo: {csv_file_path}\")\n    print(f\"üìÄ √Ålbumes por artista: {top_albums_per_artist}\\n\")\n    \n    # Read CSV\n    artists = []\n    with open(csv_path, 'r', encoding='utf-8') as f:\n        reader = csv.DictReader(f)\n        \n        # Check if header exists\n        if not reader.fieldnames or 'name' not in reader.fieldnames:\n            print(\"‚úó ERROR: El CSV debe tener una columna 'name'\")\n            print(\"\\nFormato esperado:\")\n            print(\"name\")\n            print(\"Radiohead\")\n            print(\"Blur\")\n            return\n        \n        for row in reader:\n            artist_name = row.get('name', '').strip()\n            if artist_name:\n                artists.append(artist_name)\n    \n    if not artists:\n        print(\"‚úó ERROR: No se encontraron artistas en el CSV\")\n        return\n    \n    print(f\"üìã Encontrados {len(artists)} artistas para importar\")\n    print(f\"‚è±Ô∏è  Tiempo estimado: ~{len(artists) * 6 / 60:.1f} minutos (primera carga)\\n\")\n    \n    # Import each artist\n    successful = 0\n    failed = 0\n    already_cached = 0\n    \n    client = httpx.Client(timeout=120.0)\n    \n    for i, artist_name in enumerate(artists, 1):\n        print(f\"[{i}/{len(artists)}] {artist_name}\")\n        \n        try:\n            start = time.time()\n            response = client.post(\n                'http://localhost:5000/api/recommendations/artist-single',\n                json={\n                    'artist_name': artist_name,\n                    'top_albums': top_albums_per_artist\n                }\n            )\n            elapsed = time.time() - start\n            \n            if response.status_code == 200:\n                data = response.json()\n                total_albums = data.get('total', 0)\n                \n                if elapsed < 1.0:\n                    print(f\"  ‚úì Cargado desde cach√© ({elapsed:.2f}s) - {total_albums} √°lbumes\")\n                    already_cached += 1\n                else:\n                    print(f\"  ‚úì Importado exitosamente ({elapsed:.2f}s) - {total_albums} √°lbumes con ratings\")\n                    successful += 1\n                \n                # Show top album\n                if data.get('recommendations'):\n                    top = data['recommendations'][0]\n                    rating = top.get('rating', 'N/A')\n                    print(f\"    Top: \\\"{top.get('album_name')}\\\" ({top.get('year')}) - Rating: {rating}/5\")\n            \n            elif response.status_code == 404:\n                print(f\"  ‚ö† No se encontraron √°lbumes\")\n                failed += 1\n            \n            else:\n                print(f\"  ‚úó Error HTTP {response.status_code}: {response.text[:100]}\")\n                failed += 1\n        \n        except httpx.TimeoutException:\n            print(f\"  ‚úó Timeout (>120s) - artista muy lento, saltando...\")\n            failed += 1\n        \n        except Exception as e:\n            print(f\"  ‚úó Error: {e}\")\n            failed += 1\n        \n        # Small delay between artists to avoid overwhelming the system\n        if i < len(artists):\n            time.sleep(0.5)\n    \n    client.close()\n    \n    # Summary\n    print(\"\\n\" + \"=\"*60)\n    print(\"IMPORTACI√ìN COMPLETA\")\n    print(\"=\"*60)\n    print(f\"‚úì Importados nuevos: {successful}\")\n    print(f\"‚ö° Ya en cach√©: {already_cached}\")\n    print(f\"‚úó Fallidos: {failed}\")\n    print(f\"üìä Total procesados: {len(artists)}\")\n    print(\"=\"*60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"\\n\" + \"=\"*60)\n        print(\"USO DEL SCRIPT\")\n        print(\"=\"*60)\n        print(\"\\nFormato del CSV:\")\n        print(\"-\" * 60)\n        print(\"name\")\n        print(\"Radiohead\")\n        print(\"Blur\")\n        print(\"Pink Floyd\")\n        print(\"The Beatles\")\n        print(\"-\" * 60)\n        print(\"\\nEjemplo de uso:\")\n        print(\"  python scripts/import_artists_from_csv.py artists.csv\")\n        print(\"\\nNotas importantes:\")\n        print(\"  ‚Ä¢ La columna 'name' es obligatoria\")\n        print(\"  ‚Ä¢ Cada artista se consultar√° en APIs externas (~5-7s por artista)\")\n        print(\"  ‚Ä¢ Los artistas se guardan autom√°ticamente con ratings e im√°genes\")\n        print(\"  ‚Ä¢ Consultas futuras ser√°n ~30x m√°s r√°pidas (desde cach√© PostgreSQL)\")\n        print(\"  ‚Ä¢ El script maneja errores por artista (si uno falla, contin√∫a)\")\n        print(\"=\"*60 + \"\\n\")\n        sys.exit(1)\n    \n    csv_file = sys.argv[1]\n    import_artists_from_csv(csv_file)\n","size_bytes":5532},"tests/lastfm_top_artists_exporter.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nlastfm_top_artists_exporter.py\n\nPeque√±a UI para exportar CSVs de top artistas de Last.fm:\n- Global\n- Por pa√≠s\n- Por g√©nero/tag\n\nEjecutar con:\n\n    streamlit run lastfm_top_artists_exporter.py --server.port 8000 --server.address 0.0.0.0\n\"\"\"\n\nimport os\nimport csv\nimport io\nimport requests\nimport streamlit as st\n\nAPI_KEY = os.getenv(\"LASTFM_API_KEY\")\nBASE_URL = \"https://ws.audioscrobbler.com/2.0/\"\n\n\ndef extract_best_image(image_list):\n    \"\"\"Devuelve la mejor imagen disponible seg√∫n prioridad de tama√±o.\"\"\"\n    priority = [\"mega\", \"extralarge\", \"large\", \"medium\", \"small\"]\n    for size in priority:\n        for img in image_list:\n            if img.get(\"size\") == size and img.get(\"#text\"):\n                return img[\"#text\"]\n    return \"\"\n\n\ndef fetch_artists(mode: str, limit: int, page: int = 1, country: str | None = None, tag: str | None = None):\n    \"\"\"Llama a la API de Last.fm y devuelve la lista de artistas ya normalizada.\"\"\"\n    if not API_KEY:\n        raise RuntimeError(\"No se encontr√≥ LASTFM_API_KEY en los secrets/variables de entorno.\")\n\n    params = {\n        \"api_key\": API_KEY,\n        \"format\": \"json\",\n        \"limit\": limit,\n        \"page\": page,\n    }\n\n    if mode == \"global\":\n        params[\"method\"] = \"chart.gettopartists\"\n    elif mode == \"country\":\n        params[\"method\"] = \"geo.gettopartists\"\n        params[\"country\"] = country\n    elif mode == \"tag\":\n        params[\"method\"] = \"tag.gettopartists\"\n        params[\"tag\"] = tag\n    else:\n        raise ValueError(f\"Modo no soportado: {mode}\")\n\n    resp = requests.get(BASE_URL, params=params, timeout=20)\n    resp.raise_for_status()\n    data = resp.json()\n\n    # Estructuras de respuesta distintas seg√∫n m√©todo\n    if mode == \"global\":\n        artists = data.get(\"artists\", {}).get(\"artist\", [])\n    else:\n        artists = data.get(\"topartists\", {}).get(\"artist\", [])\n\n    return artists\n\n\ndef build_csv(artists):\n    \"\"\"Genera un CSV en memoria (StringIO) con las columnas deseadas.\"\"\"\n    output = io.StringIO()\n    writer = csv.writer(output)\n    writer.writerow([\"rank\", \"name\", \"mbid\", \"listeners\", \"playcount\", \"url\", \"image_url\"])\n\n    for i, a in enumerate(artists, start=1):\n        image_url = extract_best_image(a.get(\"image\", []))\n        writer.writerow([\n            i,\n            a.get(\"name\", \"\"),\n            a.get(\"mbid\", \"\"),\n            a.get(\"listeners\", \"\"),\n            a.get(\"playcount\", \"\"),\n            a.get(\"url\", \"\"),\n            image_url,\n        ])\n\n    return output.getvalue()\n\n\n# ----------------- UI con Streamlit -----------------\n\nst.title(\"üéß Last.fm Top Artists ‚Üí CSV\")\nst.write(\"Exporta un CSV con los artistas top por **mundo**, **pa√≠s** o **g√©nero (tag)**.\")\n\nif not API_KEY:\n    st.error(\"‚ùå No se encontr√≥ `LASTFM_API_KEY` en las variables de entorno. Config√∫ralo en Replit/entorno.\")\n    st.stop()\n\nmode = st.selectbox(\n    \"¬øQu√© quieres exportar?\",\n    options=[\"Global (chart.gettopartists)\", \"Por pa√≠s (geo.gettopartists)\", \"Por g√©nero/tag (tag.gettopartists)\"],\n)\n\nlimit = st.slider(\"N√∫mero de artistas\", min_value=10, max_value=1000, value=200, step=10)\n\ncountry = None\ntag = None\nsuffix = \"global\"\n\nif mode.startswith(\"Por pa√≠s\"):\n    country = st.text_input(\"Pa√≠s (en ingl√©s, p.ej. Spain, United States, Brazil)\", value=\"Spain\")\n    suffix = f\"country_{country.replace(' ', '_')}\"\nelif mode.startswith(\"Por g√©nero\"):\n    tag = st.text_input(\"G√©nero/tag (p.ej. rock, indie, hip-hop)\", value=\"rock\")\n    suffix = f\"tag_{tag.replace(' ', '_')}\"\nelse:\n    suffix = \"global\"\n\nif st.button(\"üì° Descargar datos y generar CSV\"):\n    try:\n        with st.spinner(\"Llamando a la API de Last.fm...\"):\n            if mode.startswith(\"Global\"):\n                artists = fetch_artists(\"global\", limit=limit)\n            elif mode.startswith(\"Por pa√≠s\"):\n                if not country.strip():\n                    st.error(\"Por favor, introduce un pa√≠s.\")\n                    st.stop()\n                artists = fetch_artists(\"country\", limit=limit, country=country.strip())\n            else:  # g√©nero/tag\n                if not tag.strip():\n                    st.error(\"Por favor, introduce un g√©nero/tag.\")\n                    st.stop()\n                artists = fetch_artists(\"tag\", limit=limit, tag=tag.strip())\n\n        st.success(f\"‚úî Recibidos {len(artists)} artistas\")\n\n        csv_str = build_csv(artists)\n        file_name = f\"lastfm_top_artists_{suffix}_{limit}.csv\"\n\n        st.download_button(\n            label=\"üíæ Descargar CSV\",\n            data=csv_str.encode(\"utf-8\"),\n            file_name=file_name,\n            mime=\"text/csv\",\n        )\n\n        # Vista previa r√°pida de los primeros 20\n        preview = []\n        for i, a in enumerate(artists[:20], start=1):\n            preview.append({\n                \"rank\": i,\n                \"name\": a.get(\"name\", \"\"),\n                \"listeners\": a.get(\"listeners\", \"\"),\n                \"playcount\": a.get(\"playcount\", \"\"),\n            })\n\n        if preview:\n            st.subheader(\"Vista previa (primeros 20)\")\n            st.dataframe(preview)\n\n    except Exception as e:\n        st.error(f\"‚ùå Error al obtener datos: {e}\")\n","size_bytes":5212},"services/lastfm/__init__.py":{"content":"","size_bytes":0},"services/lastfm/lastfm_client.py":{"content":"import os\nimport hashlib\nimport httpx\nfrom typing import List, Dict, Any, Optional\nimport sys\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))\nfrom libs.shared.utils import log_event\n\n\nclass LastFMClient:\n    def __init__(self, api_key: str, username: str):\n        self.api_key = api_key\n        self.username = username\n        self.api_base = \"http://ws.audioscrobbler.com/2.0/\"\n        self.client = None\n    \n    async def start(self):\n        self.client = httpx.AsyncClient()\n    \n    async def close(self):\n        if self.client:\n            await self.client.aclose()\n    \n    async def _request(self, method: str, params: Dict[str, Any]) -> dict:\n        if not self.client:\n            raise ValueError(\"Client not started\")\n        \n        params[\"api_key\"] = self.api_key\n        params[\"format\"] = \"json\"\n        \n        resp = await self.client.get(self.api_base, params=params)\n        resp.raise_for_status()\n        return resp.json()\n    \n    async def get_top_tracks(self, period: str = \"3month\", limit: int = 300) -> List[dict]:\n        \"\"\"\n        Get user's top tracks for a given period\n        period: overall | 7day | 1month | 3month | 6month | 12month\n        \"\"\"\n        all_tracks = []\n        page = 1\n        per_page = 50\n        \n        while len(all_tracks) < limit:\n            log_event(\"lastfm-client\", \"INFO\", f\"Fetching tracks page={page}, period={period}\")\n            \n            params = {\n                \"method\": \"user.getTopTracks\",\n                \"user\": self.username,\n                \"period\": period,\n                \"limit\": per_page,\n                \"page\": page\n            }\n            \n            data = await self._request(\"GET\", params)\n            tracks_data = data.get(\"toptracks\", {}).get(\"track\", [])\n            \n            if not tracks_data:\n                break\n            \n            if isinstance(tracks_data, dict):\n                tracks_data = [tracks_data]\n            \n            all_tracks.extend(tracks_data)\n            \n            if len(tracks_data) < per_page:\n                break\n            \n            page += 1\n        \n        return all_tracks[:limit]\n    \n    async def get_top_artists(self, period: str = \"3month\", limit: int = 300) -> List[dict]:\n        \"\"\"\n        Get user's top artists for a given period\n        period: overall | 7day | 1month | 3month | 6month | 12month\n        \"\"\"\n        all_artists = []\n        page = 1\n        per_page = 50\n        \n        while len(all_artists) < limit:\n            log_event(\"lastfm-client\", \"INFO\", f\"Fetching artists page={page}, period={period}\")\n            \n            params = {\n                \"method\": \"user.getTopArtists\",\n                \"user\": self.username,\n                \"period\": period,\n                \"limit\": per_page,\n                \"page\": page\n            }\n            \n            data = await self._request(\"GET\", params)\n            artists_data = data.get(\"topartists\", {}).get(\"artist\", [])\n            \n            if not artists_data:\n                break\n            \n            if isinstance(artists_data, dict):\n                artists_data = [artists_data]\n            \n            all_artists.extend(artists_data)\n            \n            if len(artists_data) < per_page:\n                break\n            \n            page += 1\n        \n        return all_artists[:limit]\n    \n    async def get_top_albums(self, period: str = \"3month\", limit: int = 50) -> List[dict]:\n        \"\"\"\n        Get user's top albums for a given period\n        period: overall | 7day | 1month | 3month | 6month | 12month\n        \"\"\"\n        all_albums = []\n        page = 1\n        per_page = 50\n        \n        while len(all_albums) < limit:\n            log_event(\"lastfm-client\", \"INFO\", f\"Fetching albums page={page}, period={period}\")\n            \n            params = {\n                \"method\": \"user.getTopAlbums\",\n                \"user\": self.username,\n                \"period\": period,\n                \"limit\": per_page,\n                \"page\": page\n            }\n            \n            data = await self._request(\"GET\", params)\n            albums_data = data.get(\"topalbums\", {}).get(\"album\", [])\n            \n            if not albums_data:\n                break\n            \n            if isinstance(albums_data, dict):\n                albums_data = [albums_data]\n            \n            all_albums.extend(albums_data)\n            \n            if len(albums_data) < per_page:\n                break\n            \n            page += 1\n        \n        return all_albums[:limit]\n    \n    async def search_artist(self, query: str, limit: int = 30) -> List[dict]:\n        \"\"\"\n        Search for artists by name\n        \"\"\"\n        log_event(\"lastfm-client\", \"INFO\", f\"Searching artists: {query}\")\n        \n        params = {\n            \"method\": \"artist.search\",\n            \"artist\": query,\n            \"limit\": limit\n        }\n        \n        data = await self._request(\"GET\", params)\n        results = data.get(\"results\", {})\n        artist_matches = results.get(\"artistmatches\", {})\n        artists = artist_matches.get(\"artist\", [])\n        \n        if isinstance(artists, dict):\n            artists = [artists]\n        \n        return artists\n    \n    async def get_user_info(self) -> dict:\n        \"\"\"Get user profile information\"\"\"\n        params = {\n            \"method\": \"user.getInfo\",\n            \"user\": self.username\n        }\n        data = await self._request(\"GET\", params)\n        return data.get(\"user\", {})\n","size_bytes":5551},"services/lastfm/auth.py":{"content":"import os\nimport hashlib\nfrom urllib.parse import urlencode\nimport httpx\nfrom typing import Optional\n\n\nclass LastFMAuthManager:\n    def __init__(self):\n        self.api_key = os.getenv(\"LASTFM_API_KEY\")\n        self.api_secret = os.getenv(\"LASTFM_API_SECRET\")\n        \n        replit_domain = os.getenv(\"REPLIT_DEV_DOMAIN\")\n        if replit_domain:\n            default_redirect = f\"https://{replit_domain}/lastfm/callback\"\n        else:\n            default_redirect = \"http://localhost:5000/lastfm/callback\"\n        \n        self.redirect_uri = os.getenv(\"LASTFM_REDIRECT_URI\", default_redirect)\n        self.api_base = \"http://ws.audioscrobbler.com/2.0/\"\n        self.auth_url_base = \"http://www.last.fm/api/auth\"\n        self.session_key = None\n        self.username = None\n    \n    def _generate_signature(self, params: dict) -> str:\n        \"\"\"Generate MD5 signature for Last.fm API calls\"\"\"\n        params_without_format = {k: v for k, v in params.items() if k != 'format'}\n        sorted_params = sorted(params_without_format.items())\n        sig_string = ''.join([f'{k}{v}' for k, v in sorted_params])\n        sig_string += self.api_secret\n        return hashlib.md5(sig_string.encode('utf-8')).hexdigest()\n    \n    async def get_token(self) -> Optional[str]:\n        \"\"\"Get temporary token from Last.fm\"\"\"\n        params = {\n            \"method\": \"auth.getToken\",\n            \"api_key\": self.api_key,\n            \"format\": \"json\"\n        }\n        params[\"api_sig\"] = self._generate_signature(params)\n        \n        async with httpx.AsyncClient() as client:\n            resp = await client.get(self.api_base, params=params)\n            if resp.status_code != 200:\n                return None\n            \n            data = resp.json()\n            return data.get(\"token\")\n    \n    def get_auth_url(self, token: str) -> str:\n        \"\"\"Get authorization URL for user to approve\"\"\"\n        if not all([self.api_key, self.api_secret]):\n            raise ValueError(\"Missing Last.fm credentials\")\n        \n        params = {\n            \"api_key\": self.api_key,\n            \"token\": token\n        }\n        return f\"{self.auth_url_base}?{urlencode(params)}\"\n    \n    async def get_session(self, token: str) -> bool:\n        \"\"\"Exchange token for session key after user authorization\"\"\"\n        params = {\n            \"method\": \"auth.getSession\",\n            \"api_key\": self.api_key,\n            \"token\": token,\n            \"format\": \"json\"\n        }\n        params[\"api_sig\"] = self._generate_signature(params)\n        \n        async with httpx.AsyncClient() as client:\n            resp = await client.get(self.api_base, params=params)\n            \n            if resp.status_code != 200:\n                print(f\"Last.fm API error: status={resp.status_code}, body={resp.text}\")\n                return False\n            \n            data = resp.json()\n            \n            if \"error\" in data:\n                error_msg = data.get(\"message\", \"Unknown error\")\n                print(f\"Last.fm error response: {error_msg}\")\n                return False\n            \n            session = data.get(\"session\", {})\n            self.session_key = session.get(\"key\")\n            self.username = session.get(\"name\")\n            \n            success = bool(self.session_key)\n            print(f\"Session key obtained: {success}, username: {self.username}\")\n            return success\n    \n    def get_session_key(self) -> Optional[str]:\n        return self.session_key\n    \n    def get_username(self) -> Optional[str]:\n        return self.username\n    \n    def is_authenticated(self) -> bool:\n        return bool(self.session_key and self.username)\n","size_bytes":3648},"services/recommender/db_utils.py":{"content":"import os\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nfrom psycopg2 import pool\nfrom datetime import datetime\nimport sys\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))\nfrom libs.shared.utils import log_event\n\n_db_pool = None\n\ndef _get_pool():\n    \"\"\"Get or create database connection pool\"\"\"\n    global _db_pool\n    if _db_pool is None:\n        _db_pool = pool.SimpleConnectionPool(\n            1, 5, os.getenv(\"DATABASE_URL\"),\n            connect_timeout=5\n        )\n    return _db_pool\n\ndef get_cached_album(artist_name: str, album_name: str) -> dict:\n    \"\"\"Check if album exists in cache (thread-safe)\"\"\"\n    try:\n        conn = _get_pool().getconn()\n        try:\n            with conn.cursor(cursor_factory=RealDictCursor) as cur:\n                query = \"\"\"\n                    SELECT \n                        a.id as album_id,\n                        a.title,\n                        a.year,\n                        a.discogs_master_id,\n                        a.discogs_release_id,\n                        a.rating,\n                        a.votes,\n                        a.cover_url,\n                        ar.name as artist_name\n                    FROM albums a\n                    JOIN artists ar ON a.artist_id = ar.id\n                    WHERE LOWER(ar.name) = LOWER(%s)\n                    AND LOWER(a.title) = LOWER(%s)\n                    LIMIT 1\n                \"\"\"\n                cur.execute(query, (artist_name, album_name))\n                result = cur.fetchone()\n                \n                if result:\n                    log_event(\"recommender-db\", \"DEBUG\", f\"‚úì Cache HIT: {artist_name} - {album_name}\")\n                    return dict(result)\n                else:\n                    log_event(\"recommender-db\", \"DEBUG\", f\"‚óã Cache MISS: {artist_name} - {album_name}\")\n                    return None\n        finally:\n            _get_pool().putconn(conn)\n    except Exception as e:\n        log_event(\"recommender-db\", \"ERROR\", f\"Error fetching album: {str(e)}\")\n        return None\n\ndef create_basic_album_entry(artist_name: str, album_name: str, cover_url: str = None) -> bool:\n    \"\"\"Create basic artist and album entries (thread-safe)\"\"\"\n    try:\n        conn = _get_pool().getconn()\n        try:\n            with conn.cursor() as cur:\n                artist_id = _get_or_create_artist(cur, artist_name)\n                \n                existing_check = \"\"\"\n                    SELECT id FROM albums \n                    WHERE artist_id = %s AND LOWER(title) = LOWER(%s)\n                \"\"\"\n                cur.execute(existing_check, (artist_id, album_name))\n                existing = cur.fetchone()\n                \n                if existing:\n                    log_event(\"recommender-db\", \"DEBUG\", f\"Album exists: {artist_name} - {album_name}\")\n                    return False\n                \n                insert_album = \"\"\"\n                    INSERT INTO albums (artist_id, title, cover_url, last_updated)\n                    VALUES (%s, %s, %s, %s)\n                \"\"\"\n                cur.execute(insert_album, (artist_id, album_name, cover_url, datetime.now()))\n                conn.commit()\n                \n                log_event(\"recommender-db\", \"DEBUG\", f\"‚úì Created album: {artist_name} - {album_name}\")\n                return True\n        finally:\n            _get_pool().putconn(conn)\n    except Exception as e:\n        log_event(\"recommender-db\", \"ERROR\", f\"Error creating album: {artist_name} - {album_name}: {str(e)}\")\n        return False\n\ndef _get_or_create_artist(cur, artist_name: str) -> int:\n    \"\"\"Get or create artist (cursor transaction)\"\"\"\n    check_query = \"SELECT id FROM artists WHERE LOWER(name) = LOWER(%s)\"\n    cur.execute(check_query, (artist_name,))\n    result = cur.fetchone()\n    \n    if result:\n        return result[0]\n    \n    insert_query = \"\"\"\n        INSERT INTO artists (name, last_updated)\n        VALUES (%s, %s)\n        RETURNING id\n    \"\"\"\n    cur.execute(insert_query, (artist_name, datetime.now()))\n    artist_id = cur.fetchone()[0]\n    \n    log_event(\"recommender-db\", \"DEBUG\", f\"‚úì Created artist: {artist_name}\")\n    return artist_id\n\ndef close_pool():\n    \"\"\"Close database pool\"\"\"\n    global _db_pool\n    if _db_pool:\n        _db_pool.closeall()\n        _db_pool = None\n","size_bytes":4334}},"version":2}